<!doctype html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Layout Assistant - Cirrus Design System</title><style>/**************************************
     * SHARED/GLOBAL STYLES - BOTH UIs
     **************************************/
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Helvetica Neue", sans-serif;
    font-size: var(--semantic-typography-body-md-size);
    color: var(--semantic-text-primary, #333);
    padding: 0;
    margin: 0;
    background: var(--semantic-surface-bg, #fff);
    height: 100vh;
    min-height: 300px;
    min-width: 360px;
    width: 100vw;
    overflow: hidden;
    position: relative;
  }
  
  /* Resize handle */
  .resize-handle {
    position: fixed;
    bottom: 0;
    right: 0;
    width: 20px;
    height: 20px;
    cursor: nwse-resize;
    z-index: 10000;
    background: transparent;
    user-select: none;
    -webkit-user-select: none;
    color: var(--semantic-text-secondary, #8C8C8C);
    transition: opacity var(--semantic-transition-base);
  }
  
  .resize-handle svg {
    width: 100%;
    height: 100%;
    pointer-events: none;
  }
  
  .resize-handle:hover {
    opacity: 1;
    color: var(--semantic-text-secondary, #666);
  }
  
  /* Dark mode support for resize handle */
  @media (prefers-color-scheme: dark) {
    .resize-handle {
      color: var(--semantic-text-secondary, #666);
    }
    
    .resize-handle:hover {
      color: var(--semantic-surface-neutral-500, #999);
    }
  }
  
  .header-buttons {
    display: flex;
    align-items: center;
    gap: var(--semantic-spacing-lg);
  }
  
  .ui-toggle-container {
    margin-bottom: 0;
  }

    .container {
      display: flex;
      flex-direction: column;
      gap: var(--semantic-spacing-2xl);
      width: 100%;
      height: 100%;
      margin: 0 auto;
    }

    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: var(--semantic-spacing-2xl);
    }

    h1 {
      font-size: var(--semantic-typography-headingMd-size);
      font-weight: var(--semantic-typography-headingMd-weight);
      color: var(--semantic-text-primary, #000);
      margin: 0;
    }

    .help-button {
      border-radius: var(--semantic-radius-md);
      background: transparent;
      border: none;
      font-size: var(--semantic-typography-body-md-size);
      font-weight: var(--semantic-typography-label-lg-weight);
      color: var(--semantic-text-secondary, #666);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all var(--semantic-transition-base);
      padding: var(--semantic-spacing-md) var(--semantic-spacing-lg);
    }

    .help-button:hover {
      background: var(--surface-neutral-100, #f0f0f0);
      color: var(--semantic-text-primary, #000);
    }

    .help-button.active {
      background: var(--semantic-button-brand-fill-default, #0d99ff);
      color: var(--semantic-button-brand-text, white);
    }

    .help-content {
      margin-bottom: var(--semantic-spacing-xl);
    }

    .description {
      color: var(--semantic-text-secondary, #666);
      line-height: var(--semantic-typography-bodyMd-lineHeight);
      margin-bottom: var(--semantic-spacing-lg);
    }

    .info-box {
      background: var(--surface-neutral-75, #f5f5f5);
      border-radius: var(--semantic-radius-lg);
      padding: var(--semantic-spacing-xl);
      border: 1px solid var(--surface-neutral-200, #e0e0e0);
    }
    
    /**************************************
     * CURRENT UI STYLES
     **************************************/

    .info-title {
      font-weight: var(--semantic-typography-headingSm-weight);
      margin-bottom: var(--semantic-spacing-md);
      color: var(--semantic-text-primary, #000);
    }

    .info-list {
      list-style: none;
      padding-left: 0;
    }

    .info-list li {
      padding: var(--semantic-spacing-xs) 0;
      color: var(--semantic-text-secondary, #666);
      display: flex;
      align-items: center;
      gap: var(--semantic-spacing-md);
    }

    .info-list li::before {
      content: "â€¢";
      color: var(--semantic-button-brand-fill-default, #0d99ff);
      font-weight: bold;
    }

    /* Accordion styles */
    .accordion {
      margin-bottom: var(--semantic-spacing-xl);
      border: 1px solid var(--surface-neutral-200, #e0e0e0);
      border-radius: var(--semantic-radius-md);
      overflow: hidden;
    }

    .accordion-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: var(--semantic-spacing-lg) var(--semantic-spacing-xl);
      background: var(--surface-neutral-75, #f5f5f5);
      cursor: pointer;
      user-select: none;
    }

    .accordion-header:hover {
      background: var(--surface-neutral-100, #efefef);
    }

    .accordion-icon {
      font-size: var(--semantic-typography-bodyXs-size);
      transition: transform var(--semantic-transition-slow);
    }

    .accordion-icon.open {
      transform: rotate(180deg);
    }

    .accordion-content {
      padding: var(--semantic-spacing-xl);
      background: var(--semantic-surface-bg, #fff);
      border-top: 1px solid var(--semantic-surface-neutral-200, #e0e0e0);
    }

    /* Rename panel styles */
    .rename-panel {
      display: flex;
      flex-direction: column;
      gap: var(--semantic-spacing-lg);
    }

    .rename-preview {
      margin-bottom: var(--semantic-spacing-md);
    }

    .preview-label {
      font-size: var(--semantic-typography-bodySm-size);
      color: var(--semantic-text-secondary, #666);
      margin-bottom: var(--semantic-spacing-xs);
    }
    
    .preview-parent {
      font-size: var(--semantic-typography-bodySm-size);
      color: var(--semantic-text-secondary, #888);
      margin-bottom: var(--semantic-spacing-xs);
      display: flex;
      align-items: center;
      flex-wrap: wrap;
      gap: 0;
    }

    .preview-name {
      font-size: var(--semantic-typography-bodyMd-size);
      color: var(--semantic-text-primary, #333);
      font-weight: var(--semantic-typography-label-md-weight);
      word-break: break-all;
      display: flex;
      align-items: center;
      flex-wrap: wrap;
      gap: 0;
    }
    
    .auto-adjust-section {
      margin-bottom: var(--semantic-spacing-xl);
    }
    
    .auto-adjust-button {
      width: 100%;
      padding: var(--semantic-spacing-md);
      background-color: var(--surface-neutral-100, #F0F0F0);
      border: 1px solid var(--surface-neutral-200, #E0E0E0);
      border-radius: var(--semantic-radius-md);
      font-size: var(--semantic-typography-bodyMd-size);
      font-weight: var(--semantic-typography-label-md-weight);
      color: var(--semantic-text-primary, #333);
      cursor: pointer;
      transition: all var(--semantic-transition-base);
      margin-bottom: var(--semantic-spacing-md);
    }
    
    .auto-adjust-button:hover {
      background-color: var(--surface-neutral-200, #E5E5E5);
    }
    
    .auto-adjust-description {
      font-size: var(--semantic-typography-bodySm-size);
      color: var(--semantic-text-secondary, #666);
      line-height: var(--semantic-typography-bodySm-lineHeight);
    }
    
    .section-divider {
      position: relative;
      text-align: center;
      margin: var(--semantic-spacing-2xl) 0;
    }
    
    .section-divider:before {
      content: '';
      position: absolute;
      top: 50%;
      left: 0;
      right: 0;
      height: 1px;
      background-color: var(--surface-neutral-200, #E0E0E0);
      z-index: 0;
    }
    
    .section-divider span {
      position: relative;
      background-color: var(--semantic-surface-bg, white);
      padding: 0 var(--semantic-spacing-md);
      font-size: var(--semantic-typography-bodySm-size);
      color: var(--semantic-text-secondary, #888);
      z-index: 1;
    }
    
    .rename-preview-hover {
      font-size: var(--semantic-typography-labelMd-size);
      color: var(--semantic-button-brand-fill-default, #0D99FF);
      margin: var(--semantic-spacing-md) 0;
      min-height: 20px;
      font-style: italic;
    }

    .rename-buttons {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: var(--semantic-spacing-md);
    }

    .rename-button {
      padding: var(--semantic-spacing-md) var(--semantic-spacing-lg);
      border: 1px solid var(--surface-neutral-300, #d0d0d0);
      border-radius: var(--semantic-radius-sm);
      font-size: var(--semantic-typography-labelMd-size);
      background: var(--surface-neutral-100, #f0f0f0);
      cursor: pointer;
      text-align: center;
    }

    .rename-button:hover {
      background: var(--surface-neutral-150, #e8e8e8);
    }

    .rename-options {
      margin-top: var(--semantic-spacing-md);
    }

    .toggle-container {
      display: flex;
      align-items: center;
      cursor: pointer;
      margin-bottom: var(--semantic-spacing-md);
    }

    .toggle-label {
      margin-left: var(--semantic-spacing-lg);
      font-size: var(--semantic-typography-labelMd-size);
      color: var(--semantic-text-primary, #333);
    }
    
    .toggle-slider {
      position: relative;
      display: inline-block;
      width: 34px;
      height: 18px;
      background-color: var(--surface-neutral-200, #E0E0E0);
      border-radius: var(--semantic-radius-2xl);
      transition: all var(--semantic-transition-slow);
    }
    
    .toggle-slider:before {
      position: absolute;
      content: "";
      height: 14px;
      width: 14px;
      left: var(--semantic-spacing-xs);
      bottom: var(--semantic-spacing-xs);
      background-color: white;
      border-radius: var(--semantic-radius-full);
      transition: all var(--semantic-transition-slow);
    }
    
    input[type="checkbox"] {
      opacity: 0;
      width: 0;
      height: 0;
    }
    
    input[type="checkbox"]:checked + .toggle-slider {
      background-color: var(--semantic-button-brand-fill-default, #0D99FF);
    }
    
    input[type="checkbox"]:checked + .toggle-slider:before {
      transform: translateX(16px);
    }

    .button-container {
      display: flex;
      gap: var(--semantic-spacing-lg);
      margin-top: var(--semantic-spacing-lg);
    }

    button {
      flex: 1;
      padding: var(--semantic-spacing-lg) var(--semantic-spacing-2xl);
      border-radius: var(--semantic-radius-md);
      font-size: var(--semantic-typography-body-md-size);
      font-weight: var(--semantic-typography-label-md-weight);
      cursor: pointer;
      transition: all var(--semantic-transition-base);
      border: none;
    }

    .primary-button {
      background: var(--semantic-button-brand-fill-default, #0d99ff);
      color: var(--semantic-button-brand-text, white);
    }

    .primary-button:hover {
      background: var(--semantic-button-brand-fill-pressed, #0a7fd4);
    }

    .primary-button:active {
      transform: translateY(1px);
    }

    .secondary-button {
      background: var(--surface-neutral-100, #f0f0f0);
      color: var(--semantic-text-primary, #333);
      border: 1px solid var(--surface-neutral-300, #d0d0d0);
    }

    .secondary-button:hover {
      background: var(--surface-neutral-150, #e8e8e8);
    }

    .message {
      padding: var(--semantic-spacing-lg);
      border-radius: var(--semantic-radius-md);
      margin-top: var(--semantic-spacing-lg);
      display: none;
      animation: slideIn 0.3s ease;
    }

    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateY(-10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .success {
      background: #d4edda;
      color: #155724;
      border: 1px solid #c3e6cb;
    }

    .error {
      background: #f8d7da;
      color: #721c24;
      border: 1px solid #f5c6cb;
    }

    .loading {
      display: none;
      align-items: center;
      gap: var(--semantic-spacing-md);
      color: var(--semantic-text-secondary, #666);
      margin-top: var(--semantic-spacing-lg);
    }

    .spinner {
      width: 16px;
      height: 16px;
      border: 2px solid var(--semantic-surface-neutral-100, #f0f0f0);
      border-top-color: var(--semantic-button-brand-fill-default, #0d99ff);
      border-radius: var(--semantic-radius-full);
      animation: spin 0.8s linear infinite;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }
    
    /**************************************
     * NEW UI STYLES
     **************************************/
     
    /* Development UI Styles */
    .dev-ui {
      display: flex;
      flex-direction: column;
      gap: var(--semantic-spacing-lg);
      padding: var(--semantic-spacing-md);
      background-color: var(--surface-bg-bg, #2c2c2c);
      width: 100%;
      height: 100%;
      box-sizing: border-box;
    }
    
    /* Section styles */
    .section-inside,
    .section-active {
      display: flex;
      gap: var(--semantic-spacing-sm);
      padding: 0;
      width: 100%;
      align-items: flex-start;
      position: relative;
      box-sizing: border-box;
    }
    
    .section-nested {
      display: flex;
      gap: var(--semantic-spacing-sm);
      padding: 0;
      width: 100%;
      align-items: flex-start;
      position: relative;
      box-sizing: border-box;
      flex-grow: 1;
      height: 100%;
      min-height: 1px;
    }

    .section-inside {
      height: auto;
    }

    .section-active {

      height: auto;
      flex-direction: row;
      gap: var(--semantic-spacing-md);
    }

    
    /* Section header wrapper for icon and label */
    .section-header {
      display: flex;
      flex-direction: row;
      align-items: center;
      gap: var(--semantic-spacing-sm);
      flex-shrink: 0;
    }
    
    /* Section label - hidden by default, shown in columned layout */
    .section-label {
      display: none;
      font-size: var(--semantic-typography-labelSm-size);
      font-weight: var(--semantic-typography-labelSm-weight);
      color: var(--text-text-secondary, rgba(255, 255, 255, 0.60));
      white-space: nowrap;
    }
    
    /* Icon styles */
    .icon-container {
      width: 16px;
      height: 24px;
      position: relative;
      flex-shrink: 0;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .icon-container img {
      width: 16px;
      height: 16px;
      display: block;
      max-width: none;
    }
    
    .icon-container.flipped {
      transform: scaleY(-1);
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    /* Section container styles */
    .section-container {
      flex-grow: 1;
      flex-basis: 0;
      width: 100%;
      min-width: 1px;
      min-height: 1px;
      border-radius: 12px;
      background-color: var(--surface-neutral-100, rgba(255, 255, 255, 0.1)); /* neutral container */
      padding: 8px;
      display: flex;
      flex-direction: column;
      gap: var(--semantic-spacing-md);
    }
    
    /* Nested section container should fill height */
    .section-nested .section-container {
      height: 100%;
      min-height: 32px;
      overflow-y: auto;
      overflow-x: hidden;
      gap: 4px;
    }
    
    .section-container.active {
      background-color: var(--surface-brand-200, rgba(120, 172, 250, 0.2));
      height: fit-content;
      min-height: fit-content;
      flex-direction: column;
      gap: var(--semantic-spacing-md);
    }
    
    /* Responsive breakpoint: 3-column layout when width exceeds 640px */
    @media (min-width: 640px) {
      /* Change main container to horizontal layout */
      .dev-ui {
        flex-direction: row !important;
        align-items: stretch;
        gap: 16px; /* Increased gap between sections in columned layout */
      }
      
      /* Override the grouped selector that sets width: 100% */
      .section-inside,
      .section-active {
        width: auto !important;
        flex: 1 1 0% !important;
        flex-grow: 1 !important;
        flex-shrink: 1 !important;
        flex-basis: 0% !important;
        min-width: 0 !important;
        max-width: none !important;
        height: 100% !important;
        align-items: stretch !important;
      }
      
      /* Override section-nested base styles */
      .section-nested {
        width: auto !important;
        flex: 1 1 0% !important;
        flex-grow: 1 !important;
        flex-shrink: 1 !important;
        flex-basis: 0% !important;
        min-width: 0 !important;
        max-width: none !important;
        height: 100% !important;
        align-items: stretch !important;
        min-height: 0 !important;
      }
      
      /* Specific overrides for each section to ensure consistency */
      /* Stack section header above container in columned layout */
      .section-inside {
        height: 100% !important;
        min-height: 0 !important;
        flex-direction: column !important;
        align-items: stretch !important;
        gap: 4px !important; /* Reduced vertical gap within sections */
      }
      
      .section-active {
        height: 100% !important;
        flex-direction: column !important; /* Stack header above container */
        align-items: stretch !important;
        gap: 4px !important; /* Reduced vertical gap within sections */
      }
      
      .section-nested {
        flex-direction: column !important; /* Stack header above container */
        align-items: stretch !important;
        gap: 4px !important; /* Reduced vertical gap within sections */
      }
      
      /* Show labels in columned layout */
      .section-label {
        display: inline-block !important;
      }
      
      /* Adjust section header for columned layout */
      .section-header {
        flex-direction: row !important;
        align-items: center !important;
        justify-content: flex-start !important;
        margin-bottom: 4px; /* Reduced margin to match reduced gaps */
      }
      
      /* Adjust icon container for columned layout */
      .icon-container {
        height: 16px !important;
      }
      
      /* Ensure section containers fill height in 3-column layout */
      .section-inside .section-container,
      .section-active .section-container,
      .section-nested .section-container {
        height: 100% !important;
        min-height: 0 !important;
        flex: 1 1 0% !important;
      }
      
      .section-container.active {
        height: fit-content !important;
        min-height: fit-content !important;
      }
      
      /* Reduce layout selection container min-height in columned layout */
      .layout-selection-container {
        min-height: 104px !important;
      }
    }
    
    /* Structure item styles */
    .structure-item {
      display: flex;
      align-items: center;
      gap: 4px;
      width: 100%;
      border-radius: 8px;
      box-sizing: border-box;
      min-width: 0; /* Allow flex shrinking */
    }
    
    .structure-item.active {
      gap: var(--semantic-spacing-sm);
    }

    .structure-item.action-item {
      height: 24px;
      min-height: 24px;
    }
    
    /* Tree structure nesting for nested section */
    .section-nested .structure-item {
      position: relative;
      margin-left: 0px; /* Default: no offset for top-level */
      min-height: 24px;
      height: 24px;
    }
    
    /* Collapse/expand controls for nested items */
    .structure-item-collapse {
      width: 16px;
      height: 16px;
      min-width: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      border-radius: 2px;
      transition: background-color 0.2s ease;
      flex-shrink: 0;
      margin-right: 4px;
    }
    
    .structure-item-collapse:hover {
      background-color: var(--semantic-surface-neutral-100, rgba(255, 255, 255, 0.1));
    }
    
    .structure-item-collapse svg {
      width: 12px;
      height: 12px;
      transition: transform var(--semantic-transition-base);
      color: var(--text-text-secondary, rgba(255, 255, 255, 0.60));
    }
    
    .structure-item-wrapper.collapsed .structure-item-collapse svg {
      transform: rotate(-90deg);
    }
    
    .structure-item-wrapper.expanded .structure-item-collapse svg {
      transform: rotate(0deg);
    }
    
    .structure-item-nested-count {
      font-size: 10px;
      color: var(--text-text-secondary, rgba(255, 255, 255, 0.60));
      margin-left: auto;
      padding: 0 4px;
      flex-shrink: 0;
    }
    
    .structure-item-nested-children {
      display: none;
      margin-left: 12px;
      margin-top: 4px;
      width: calc(100% - 12px); /* Subtract margin to prevent overflow */
      max-width: calc(100% - 12px);
      box-sizing: border-box;
    }
    
    .structure-item-wrapper {
      margin-bottom: 0;
      width: 100%;
      box-sizing: border-box;
      min-width: 0; /* Allow flex shrinking */
    }
    
    .section-nested .structure-item-wrapper {
      margin-bottom: 0;
      width: 100%;
      max-width: 100%;
      overflow: hidden; /* Prevent overflow */
      min-height: 24px;
    }
    
    .structure-item-wrapper.expanded .structure-item-nested-children {
      display: block;
    }
    
    .structure-item-wrapper.collapsed .structure-item-nested-children {
      display: none;
    }
    
    /* Explicit rule for level 1 (top-level) items */
    .section-nested .structure-item[data-level="1"] {
      margin-left: 0px !important;
    }
    
    .section-nested .structure-item[data-level="2"] {
      margin-left: 8px;
    }
    
    .section-nested .structure-item[data-level="3"] {
      margin-left: 16px;
    }
    
    .section-nested .structure-item[data-level="4"] {
      margin-left: 32px;
    }
    
    /* Ensure items don't exceed container width */
    .section-nested .structure-item-wrapper .structure-item {
      max-width: 100%;
      overflow: hidden;
    }
    
    .section-nested .structure-item-wrapper .structure-item .layer-name {
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      min-width: 0; /* Allow flex shrinking */
    }
    
    
    /* Layer name text styles */
    .structure-item .layer-name {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      font-size: 11px;
      font-style: normal;
      font-weight: 450;
      line-height: 16px;
      letter-spacing: 0.055px;
      flex-grow: 1;
      min-width: 0;
    }
    
    /* 'inside' section - secondary text color */
    /* 'inside' section - secondary text color */
    .section-inside .structure-item .layer-name {
      color: var(--text-text-secondary, rgba(255, 255, 255, 0.60));
    }
    
    /* 'active' section - primary text color */
    /* 'active' section - primary text color */
    .section-active .structure-item .layer-name {
      color: var(--text-text-primary, #FFF);
    }
    
    /* 'nested' section - secondary text color */
    /* 'nested' section - secondary text color */
    .section-nested .structure-item .layer-name {
      color: var(--text-text-secondary, rgba(255, 255, 255, 0.60));
    }
    
    /* SVG Button styles */
    .svg-button {
      background: none;
      border: none;
      cursor: pointer;
      padding: 8px;
      border-radius: 4px;
      transition: all 0.2s ease;
    }
    
    .svg-button:hover {
      background-color: var(--semantic-surface-neutral-50, rgba(0, 0, 0, 0.05));
    }
    
    .svg-button:active {
      transform: scale(0.95);
    }
    
    .svg-button svg {
      width: 24px;
      height: 24px;
      vertical-align: middle;
    }
    
    /* Example of SVG as background image */
    .svg-bg-button {
      width: 24px;
      height: 24px;
      background-color: transparent;
      background-repeat: no-repeat;
      background-position: center;
      border: none;
      cursor: pointer;
      padding: 8px;
      border-radius: 4px;
      transition: all 0.2s ease;
    }
    
    .svg-bg-button:hover {
      background-color: var(--semantic-surface-neutral-50, rgba(0, 0, 0, 0.05));
    }
    
    .svg-buttons-container {
      display: flex;
      gap: 8px;
      margin-bottom: 16px;
    }
    
    /**************************************
     * STICKY FOOTER STYLES
     **************************************/
    
    .sticky-footer {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background-color: var(--semantic-surface-bg, rgba(255, 255, 255, 0.95));
      border-top: 1px solid var(--semantic-surface-neutral-200, #E0E0E0);
      padding: 8px 16px;
      z-index: 1000;
      box-shadow: 0 -2px 5px var(--semantic-surface-neutral-50, rgba(0, 0, 0, 0.05));
    }
    
    .sticky-footer-content {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 12px;
    }
    
    .test-modal-button {
      padding: 4px 8px;
      border-radius: 4px;
      border: 1px solid var(--surface-neutral-200, #E0E0E0);
      background-color: var(--surface-neutral-100, #f0f0f0);
      color: var(--semantic-text-secondary, #666);
      font-size: 11px;
      font-family: Inter, -apple-system, BlinkMacSystemFont, sans-serif;
      cursor: pointer;
      transition: all 0.2s ease;
      height: 24px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }
    
    .test-modal-button:hover {
      background-color: var(--surface-neutral-150, #e8e8e8);
      border-color: var(--surface-neutral-300, #d0d0d0);
    }
    
    .test-modal-button:active {
      background-color: var(--surface-neutral-200, #E0E0E0);
    }
    
    /* Add padding to the bottom of both UIs */
    #currentUi {
      padding-bottom: 8px;
      display: flex;
      flex-direction: column;
    }
    
    /* The new UI is already a flex container with padding */
    #newUi {
      /* Adjust height to account for zoom - divide by zoom factor to prevent overflow */
      height: calc(100vh / 1.1);
      width: 100%; /* Keep full width */
      gap: 8px; /* Reduce spacing between sections to 8px */
      zoom: 1.1; /* Scale everything up by 10% for better legibility */
      transform-origin: top left; /* Ensure scaling starts from top-left corner */
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      padding-bottom: 8px;
      /* Alternative: transform: scale(1.15); transform-origin: top left; */
    }
    
    /* You can add more custom styles for the new UI */
    
    /**************************************
     * TAG COMPONENT STYLES
     **************************************/
    
    .tag {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0 4px;
      border-radius: 4px;
      border: 1px solid;
      font-family: var(--body-medium-fontFamily, Inter), -apple-system, BlinkMacSystemFont, sans-serif;
      font-size: var(--body-medium-fontSize, 11px);
      font-style: normal;
      font-weight: var(--body-medium-fontWeight, 450);
      line-height: var(--body-medium-lineHeight, 16px);
      letter-spacing: 0.055px;
      white-space: nowrap;
      height: 24px;
      min-width: fit-content;
      flex-shrink: 0;
    }
    
    .tag.hero {
      background-color: var(--badge-hero-hero-fill, #8315684d);
      border-color: var(--badge-hero-hero-stroke, #d01b9c);
      color: var(--badge-hero-hero-text, #fce8f6);
    }
    
    .tag.parent {
      background-color: var(--badge-parent-parent-fill, #6818b14d);
      border-color: var(--badge-parent-parent-stroke, #7a2ed6);
      color: var(--badge-parent-parent-text, #f7f2fc);
    }
    
    .tag.child {
      background-color: var(--badge-child-child-fill, #0d43d64d);
      border-color: var(--badge-child-child-stroke, #0a6dc2);
      color: var(--badge-child-child-text, #eaf4fc);
    }
    
    .tag.subchild {
      background-color: var(--badge-sub-child-subChild-fill, #013a6b4d);
      border-color: var(--badge-sub-child-subChild-stroke, #087691);
      color: var(--badge-sub-child-subChild-text, #ecf4fc);
    }
    
    /* Reference tag variants - smaller, no background for non-selected hierarchical relationships */
    .tag.reference {
      background-color: transparent !important;
      height: 16px;
      line-height: 16px;
    }
    
    .tag.reference.hero {
      border-color: var(--badge-hero-hero-stroke, #d01b9c);
      color: var(--badge-hero-hero-text, #fce8f6);
    }
    
    .tag.reference.parent {
      border-color: var(--badge-parent-parent-stroke, #7a2ed6);
      color: var(--badge-parent-parent-text, #f7f2fc);
    }
    
    .tag.reference.child {
      border-color: var(--badge-child-child-stroke, #0a6dc2);
      color: var(--badge-child-child-text, #eaf4fc);
    }
    
    .tag.reference.subchild {
      border-color: var(--badge-sub-child-subChild-stroke, #087691);
      color: var(--badge-sub-child-subChild-text, #ecf4fc);
    }
    
    /* Directional extension tag - neutral colors for row/column, matching adjust tag style */
    .tag.directional {
      background-color: transparent;
      border-color: var(--semantic-surface-neutral-300);
      color: var(--semantic-text-primary);
      position: relative;
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }
    
    .tag.reference.directional {
      background-color: transparent !important;
      border-color: var(--semantic-surface-neutral-300);
      color: var(--semantic-text-primary);
      position: relative;
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    /* X icon button for removing directional prefix */
    .tag.directional .directional-remove-btn {
      display: none;
      align-items: center;
      justify-content: center;
      width: 16px;
      height: 16px;
      padding: 0;
      margin: 0;
      border: none;
      background: transparent;
      cursor: pointer;
      border-radius: 2px;
      color: var(--semantic-text-primary);
      transition: background-color 0.2s ease;
      flex-shrink: 0;
    }

    .tag.directional:hover .directional-remove-btn {
      display: flex;
    }

    .tag.directional .directional-remove-btn:hover {
      background-color: var(--surface-neutral-200, rgba(0, 0, 0, 0.1));
    }

    .tag.directional .directional-remove-btn svg {
      width: 12px;
      height: 12px;
      display: block;
    }

    /* Plus icon button for adding directional prefix */
    .structure-item .directional-add-btn {
      display: none;
      align-items: center;
      justify-content: center;
      width: 0;
      height: 16px;
      padding: 0;
      margin: 0;
      border: none;
      background-color: var(--surface-neutral-100, rgba(0, 0, 0, 0.05));
      cursor: pointer;
      border-radius: 2px;
      color: var(--semantic-text-primary);
      transition: width 0.2s ease, padding 0.2s ease, opacity 0.2s ease;
      flex-shrink: 0;
      gap: 4px;
      opacity: 0;
      pointer-events: none;
      overflow: hidden;
      white-space: nowrap;
    }

    .structure-item .directional-add-btn.show {
      display: flex !important;
      width: 16px;
      max-width: 16px;
      margin: 0 4px 0 0;
      opacity: 1;
      pointer-events: auto;
      transition: width 0.2s ease, padding 0.2s ease, opacity 0.2s ease;
    }

    .structure-item .directional-add-btn:hover {
      background-color: var(--surface-neutral-200, rgba(0, 0, 0, 0.1));
      width: auto;
      min-width: fit-content;
      padding: 0 4px;
    }

    .structure-item .directional-add-btn:hover .directional-add-text {
      display: inline;
    }

    .structure-item .directional-add-btn svg {
      width: 12px;
      height: 12px;
      display: block;
      flex-shrink: 0;
    }

    .structure-item .directional-add-btn .directional-add-text {
      display: none;
      font-family: var(--body-medium-fontFamily, Inter), -apple-system, BlinkMacSystemFont, sans-serif;
      font-size: var(--body-medium-fontSize, 11px);
      font-weight: var(--body-medium-fontWeight, 450);
      line-height: var(--body-medium-lineHeight, 16px);
      color: var(--semantic-text-primary);
      white-space: nowrap;
    }

    /* Action tag variants - with dropdown controls */
    .tag.action {
      display: inline-flex;
      align-items: center;
      justify-content: space-between;
      padding: 2px;
      border-radius: 4px;
      border: 1px solid;
      font-family: var(--body-medium-fontFamily, Inter), -apple-system, BlinkMacSystemFont, sans-serif;
      font-size: var(--body-medium-fontSize, 11px);
      font-style: normal;
      font-weight: var(--body-medium-fontWeight, 450);
      line-height: var(--body-medium-lineHeight, 16px);
      letter-spacing: 0.055px;
      white-space: nowrap;
      height: 24px;
      min-width: fit-content;
      flex-shrink: 0;
      gap: 1px; /* Gap between prefix and chevron */
    }

    .tag.action .tag-prefix {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 2px;
      border-radius: 3px 0 0 3px; /* Rounded left corners only */
      flex-shrink: 0;
    }

      .tag.action .tag-chevron {
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 0;
        border-radius: 2px;
        flex-shrink: 0;
        width: 16px;
        height: 20px; /* Fixed height to fit within container padding */
        transition: background-color 0.2s ease;
      }

      .tag.action .tag-chevron:hover {
        background-color: var(--badge-hero-hero-button-hover, rgba(131, 21, 104, 0.4));
      }

      .tag.action.hero .tag-chevron:hover {
        background-color: var(--badge-hero-hero-button-hover, rgba(131, 21, 104, 0.4));
      }

      .tag.action.parent .tag-chevron:hover {
        background-color: var(--badge-parent-parent-button-hover, rgba(104, 24, 177, 0.4));
      }

      .tag.action.child .tag-chevron:hover {
        background-color: var(--badge-child-child-button-hover, rgba(13, 67, 214, 0.4));
      }

      .tag.action.subchild .tag-chevron:hover {
        background-color: var(--badge-sub-child-subChild-button-hover, rgba(1, 58, 107, 0.4));
      }

      .tag.action.adjust .tag-chevron:hover {
        background-color: var(--surface-neutral-200, rgba(0, 0, 0, 0.1));
      }

      /* Pressed states for chevron buttons */
      .tag.action .tag-chevron:active {
        background-color: var(--badge-hero-hero-button-pressed, rgba(131, 21, 104, 0.6));
      }

      .tag.action.hero .tag-chevron:active {
        background-color: var(--badge-hero-hero-button-pressed, rgba(131, 21, 104, 0.6));
      }

      .tag.action.parent .tag-chevron:active {
        background-color: var(--badge-parent-parent-button-pressed, rgba(104, 24, 177, 0.6));
      }

      .tag.action.child .tag-chevron:active {
        background-color: var(--badge-child-child-button-pressed, rgba(13, 67, 214, 0.6));
      }

      .tag.action.subchild .tag-chevron:active {
        background-color: var(--badge-sub-child-subChild-button-pressed, rgba(1, 58, 107, 0.6));
      }

      .tag.action.adjust .tag-chevron:active {
        background-color: var(--surface-neutral-300, rgba(0, 0, 0, 0.2));
      }
      
      .tag.action.setup .tag-chevron:hover {
        background-color: var(--surface-neutral-200, rgba(0, 0, 0, 0.1));
      }
      
      .tag.action.setup .tag-chevron:active {
        background-color: var(--surface-neutral-300, rgba(0, 0, 0, 0.2));
      }

    .tag.action .tag-chevron svg {
      width: 8px;
      height: 8px;
      display: block;
    }

    /* Action tag color variants */
    .tag.action.hero {
      background-color: var(--badge-hero-hero-fill, #8315684d);
      border-color: var(--badge-hero-hero-stroke, #d01b9c);
    }

    .tag.action.hero .tag-prefix {
      background-color: transparent;
      color: var(--badge-hero-hero-text, #ffffff);
    }

    .tag.action.hero .tag-chevron {
      color: var(--badge-hero-hero-icon, #ffffff);
    }

    .tag.action.parent {
      background-color: var(--badge-parent-parent-fill, #6818b14d);
      border-color: var(--badge-parent-parent-stroke, #7a2ed6);
    }

    .tag.action.parent .tag-prefix {
      background-color: transparent;
      color: var(--badge-parent-parent-text, #ffffff);
    }

    .tag.action.parent .tag-chevron {
      color: var(--badge-parent-parent-icon, #ffffff);
    }

    .tag.action.child {
      background-color: var(--badge-child-child-fill, #0d43d64d);
      border-color: var(--badge-child-child-stroke, #0a6dc2);
    }

    .tag.action.child .tag-prefix {
      background-color: transparent;
      color: var(--badge-child-child-text, #ffffff);
    }

    .tag.action.child .tag-chevron {
      color: var(--badge-child-child-icon, #ffffff);
    }

    .tag.action.subchild {
      background-color: var(--badge-sub-child-subChild-fill, #013a6b4d);
      border-color: var(--badge-sub-child-subChild-stroke, #087691);
    }

    .tag.action.subchild .tag-prefix {
      background-color: transparent;
      color: var(--badge-sub-child-subChild-text, #ffffff);
    }

    .tag.action.subchild .tag-chevron {
      color: var(--badge-sub-child-subChild-icon, #ffffff);
    }

    /* Adjust variant - special action tag */
    .tag.action.adjust {
      background-color: transparent;
      border-color: var(--surface-neutral-300, rgba(0, 0, 0, 0.3));
    }

    .tag.action.adjust .tag-prefix {
      background-color: transparent;
      color: var(--text-text-primary, #2c2c2c);
    }

    .tag.action.adjust .tag-chevron {
      color: var(--text-text-primary, #ffffff);
    }
    
    /* Setup variant - special action tag for frames without prefix */
    .tag.action.setup {
      background-color: var(--surface-brand-100, rgba(50, 122, 255, 0.1));
      border-color: var(--surface-brand-200, rgba(50, 122, 255, 0.3));
    }

    .tag.action.setup .tag-prefix {
      background-color: transparent;
      color: var(--text-neutral-primary, rgba(255, 255, 255, 0.9));
    }

    .tag.action.setup .tag-chevron {
      display: none; /* Hide chevron in setup mode */
    }
    
    /**************************************
     * LAYOUT BUTTON SHARED STATE COLORS
     **************************************/
    
    /* Shared color tokens for layout buttons */
    :root {
      --layout-active-default: var(--surface-brand-300, rgba(50, 122, 255, 0.3));
      --layout-active-hover: var(--surface-brand-500, rgba(50, 122, 255, 0.5));
      --layout-active-pressed: var(--surface-brand-300, rgba(50, 122, 255, 0.3));
      --layout-inactive-default: var(--surface-inverted-200, rgba(255, 255, 255, 0.2));
      --layout-inactive-hover: var(--surface-neutral-200, rgba(0, 0, 0, 0.2));
      --layout-inactive-pressed: var(--surface-inverted-200, rgba(255, 255, 255, 0.2));
      
      --layout-icon-active-default: var(--icon-brand-active, #78ACFA);
      --layout-icon-active-hover: var(--icon-neutral-active, #FFFFFF);
      --layout-icon-active-pressed: var(--icon-neutral-inactive, rgba(255, 255, 255, 0.70));
      --layout-icon-inactive-default: var(--icon-neutral-inactive, rgba(255, 255, 255, 0.70));
      --layout-icon-inactive-hover: var(--icon-neutral-active, #FFFFFF);
      --layout-icon-inactive-pressed: var(--icon-neutral-inactive, rgba(255, 255, 255, 0.70));
    }

    /**************************************
     * BUTTON STYLES
     **************************************/
    
    /* Primary Button */
    .btn-primary {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 4px 8px;
      height: 24px;
      border-radius: 5px;
      border: none;
      background-color: var(--button-brand-fill-default, #0d99ff);
      color: var(--button-brand-text, #ffffff);
      font-family: var(--body-medium-fontFamily, Inter), -apple-system, BlinkMacSystemFont, sans-serif;
      font-size: var(--body-medium-fontSize, 11px);
      font-style: normal;
      font-weight: var(--body-medium-fontWeight, 450);
      line-height: var(--body-medium-lineHeight, 16px);
      letter-spacing: 0.055px;
      text-align: center;
      white-space: nowrap;
      height: 24px;
      min-width: fit-content;
      cursor: pointer;
      transition: background-color 0.2s ease;
      user-select: none;
    }

    .btn-primary:hover {
      background-color: var(--button-brand-fill-hover, #0b8ae6);
    }

    .btn-primary:active {
      background-color: var(--button-brand-fill-pressed, #007be5);
    }

    .btn-primary:disabled {
      background-color: var(--button-brand-fill-disabled, rgba(13, 153, 255, 0.5));
      cursor: not-allowed;
      opacity: 0.6;
    }

    .btn-primary:disabled:hover {
      background-color: var(--button-brand-fill-disabled, rgba(13, 153, 255, 0.5));
    }

    .btn-primary:focus {
      outline: none;
      border: none;
      box-shadow: none;
    }

    .btn-primary:focus-visible {
      outline: none;
      border: none;
      box-shadow: none;
    }

    /* Secondary Neutral Button */
    .btn-secondary {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 4px 8px;
      height: 24px;
      border-radius: 5px;
      border: 1px solid var(--button-secondary-neutral-button-secondary-neutral-stroke-default, rgba(0, 0, 0, 0.1));
      background-color: var(--button-secondary-neutral-button-secondary-neutral-fill-default, transparent);
      color: var(--button-secondary-neutral-button-secondary-neutral-text-default, #2c2c2c);
      font-family: var(--body-medium-fontFamily, Inter), -apple-system, BlinkMacSystemFont, sans-serif;
      font-size: var(--body-medium-fontSize, 11px);
      font-style: normal;
      font-weight: var(--body-medium-fontWeight, 450);
      line-height: var(--body-medium-lineHeight, 16px);
      letter-spacing: 0.055px;
      text-align: center;
      white-space: nowrap;
      height: 24px;
      min-width: fit-content;
      cursor: pointer;
      transition: all 0.2s ease;
      user-select: none;
    }

    .btn-secondary:hover {
      background-color: var(--button-secondary-neutral-button-secondary-neutral-fill-hover, rgba(0, 0, 0, 0.05));
      border-color: var(--button-secondary-neutral-button-secondary-neutral-stroke-hover, rgba(0, 0, 0, 0.15));
    }

    .btn-secondary:active {
      background-color: var(--button-secondary-neutral-button-secondary-neutral-fill-pressed, rgba(0, 0, 0, 0.07));
      border-color: var(--button-secondary-neutral-button-secondary-neutral-stroke-pressed, transparent);
    }

    .btn-secondary:disabled {
      background-color: var(--button-secondary-neutral-button-secondary-neutral-fill-disabled, transparent);
      border-color: var(--button-secondary-neutral-button-secondary-neutral-stroke-disabled, transparent);
      color: var(--button-secondary-neutral-button-secondary-neutral-disabled, rgba(0, 0, 0, 0.5));
      cursor: not-allowed;
      opacity: 0.6;
    }

    .btn-secondary:disabled:hover {
      background-color: var(--button-secondary-neutral-button-secondary-neutral-fill-disabled, transparent);
      border-color: var(--button-secondary-neutral-button-secondary-neutral-stroke-disabled, transparent);
    }

    .btn-secondary:focus {
      outline: none;
      box-shadow: none;
    }

    .btn-secondary:focus-visible {
      outline: none;
      box-shadow: none;
    }

    /* Secondary Brand Button */
    .btn-secondary-brand {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 4px 8px;
      border-radius: 5px;
      border: 1px solid var(--button-secondary-brand-button-secondary-brand-stroke-default, rgba(50, 122, 255, 0.5));
      background-color: var(--button-secondary-brand-button-secondary-brand-fill-default, transparent);
      color: var(--button-secondary-brand-button-secondary-brand-text-default, #2c2c2c);
      font-family: var(--body-medium-fontFamily, Inter), -apple-system, BlinkMacSystemFont, sans-serif;
      font-size: var(--body-medium-fontSize, 11px);
      font-style: normal;
      font-weight: var(--body-medium-fontWeight, 450);
      line-height: var(--body-medium-lineHeight, 16px);
      letter-spacing: 0.055px;
      text-align: center;
      white-space: nowrap;
      height: 24px;
      min-width: fit-content;
      cursor: pointer;
      transition: all 0.2s ease;
      user-select: none;
    }

    .btn-secondary-brand:hover {
      background-color: var(--button-secondary-brand-button-secondary-brand-fill-hover, rgba(50, 122, 255, 0.05));
      border-color: var(--button-secondary-brand-button-secondary-brand-stroke-hover, rgba(50, 122, 255, 0.7));
    }

    .btn-secondary-brand:active {
      background-color: var(--button-secondary-brand-button-secondary-brand-fill-pressed, rgba(50, 122, 255, 0.07));
      border-color: var(--button-secondary-brand-button-secondary-brand-stroke-pressed, transparent);
    }

    .btn-secondary-brand.active {
      background-color: var(--button-secondary-brand-button-secondary-brand-fill-active, rgba(50, 122, 255, 0.07));
      border-color: var(--button-secondary-brand-button-secondary-brand-stroke-active, rgba(50, 122, 255, 0.5));
    }

    /* Option selection buttons - deselected state uses neutral colors */
    .dropdown-option-btn.btn-secondary-brand:not(.selected) {
      border: 1px solid var(--button-secondary-neutral-button-secondary-neutral-stroke-default, rgba(255, 255, 255, 0.1));
      background-color: var(--button-secondary-neutral-button-secondary-neutral-fill-default, transparent);
      color: var(--text-text-secondary, rgba(255, 255, 255, 0.60));
    }

    .dropdown-option-btn.btn-secondary-brand:not(.selected):hover {
      background-color: var(--button-secondary-neutral-button-secondary-neutral-fill-hover, rgba(255, 255, 255, 0.05));
      border-color: var(--button-secondary-neutral-button-secondary-neutral-stroke-hover, rgba(255, 255, 255, 0.15));
    }

    .dropdown-option-btn.btn-secondary-brand:not(.selected):active {
      background-color: var(--button-secondary-neutral-button-secondary-neutral-fill-pressed, rgba(255, 255, 255, 0.07));
      border-color: var(--button-secondary-neutral-button-secondary-neutral-stroke-pressed, transparent);
    }

    /* Toggle button selected state (for Fix Nested / Fix Variables) */
    .btn-secondary-brand.selected {
      background-color: var(--button-secondary-brand-button-secondary-brand-fill-active, rgba(50, 122, 255, 0.20));
      border-color: var(--button-secondary-brand-button-secondary-brand-stroke-active, rgba(50, 122, 255, 0.8));
      color: var(--button-secondary-brand-button-secondary-brand-text-default, #ffffff);
    }

    .btn-secondary-brand:disabled {
      background-color: var(--button-secondary-brand-button-secondary-brand-fill-disabled, transparent);
      border-color: var(--button-secondary-brand-button-secondary-brand-stroke-disabled, transparent);
      color: var(--button-secondary-brand-button-secondary-brand-disabled, rgba(0, 0, 0, 0.5));
      cursor: not-allowed;
      opacity: 0.6;
    }

    .btn-secondary-brand:disabled:hover {
      background-color: var(--button-secondary-brand-button-secondary-brand-fill-disabled, transparent);
      border-color: var(--button-secondary-brand-button-secondary-brand-stroke-disabled, transparent);
    }

    /* Action Tag Dropdown */
    .action-tag-dropdown {
      display: flex;
      flex-direction: row;
      gap: 4px;
      padding: 4px;
      border-radius: 8px;
      background-color: var(--surface-brand-150, rgba(50, 122, 255, 0.15));
      width: 100%;
      max-height: 0;
      opacity: 0;
      align-items: center;
      overflow: hidden;
      position: relative;
      transition: max-height 0.3s ease-in-out, opacity 0.3s ease-in-out, padding 0.3s ease-in-out;
      padding-top: 0;
      padding-bottom: 0;
    }

    .action-tag-dropdown.show {
      max-height: 40px;
      opacity: 1;
      padding-top: 4px;
      padding-bottom: 4px;
    }

    .dropdown-spacer {
      display: block;
      height: 4px;
      transition: height 0.3s ease-in-out, opacity 0.3s ease-in-out;
      opacity: 1;
    }

    .action-tag-dropdown.show + .dropdown-spacer {
      height: 0;
      opacity: 0;
      overflow: hidden;
    }

    .dropdown-content-area {
      height: 24px;
      width: 100%;
      display: flex;
      align-items: center;
      overflow: hidden;
      position: relative;
    }

    .dropdown-tags-section {
      position: absolute;
      left: 0;
      top: 0;
      width: 100%;
      max-width: 100%;
      flex-shrink: 0;
      display: inline-flex;
      align-items: start;
      gap: 8px;
      height: 24px;
      transition: left 0.3s ease-in-out;
      box-sizing: border-box;
      overflow: hidden;
    }
    
    .dropdown-auto-container {
      display: flex;
      align-items: center;
      min-width: 0;
      max-width: 100%;
      box-sizing: border-box;
      overflow: hidden;
    }
    
    .dropdown-tag-wrapper {
      display: flex;
      align-items: center;
      gap: 4px;
      padding-left: 8px;
      border-left: 1px solid var(--surface-brand-300, rgba(50, 122, 255, 0.4));
      height: 100%;
      min-width: 0;
      max-width: 100%;
      box-sizing: border-box;
      overflow: hidden;
      flex-shrink: 0; /* Don't shrink in setup mode */
    }
    
    .dropdown-prefix-tag {
      box-sizing: border-box;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      min-width: 0;
    }
    .dropdown-options-section {
      position: absolute;
      left: 100%;
      top: 0;
      width: 100%;
      flex-shrink: 0;
      display: flex;
      align-items: center;
      gap: 4px;
      height: 100%;
      transition: left 0.3s ease-in-out;
    }

    .dropdown-auto-adjust {
      width: 100%;
    }

    .dropdown-tag-wrapper {
      display: flex;
      align-items: center;
      gap: 4px;
      padding-left: 8px;
      border-left: 1px solid var(--surface-brand-300, rgba(50, 122, 255, 0.4));
      height: 100%;
    }


    .dropdown-separator {
      width: 1px;
      height: 16px;
      background-color: var(--surface-brand-200, rgba(50, 122, 255, 0.2));
      flex-shrink: 0;
    }

    .dropdown-prefixes {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .dropdown-prefix-tag {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 2px 6px;
      height: 24px;
      border-radius: 4px;
      border: 1px solid;
      font-family: var(--body-medium-fontFamily, Inter), -apple-system, BlinkMacSystemFont, sans-serif;
      font-size: var(--body-medium-fontSize, 11px);
      font-style: normal;
      font-weight: var(--body-medium-fontWeight, 450);
      line-height: var(--body-medium-lineHeight, 16px);
      letter-spacing: 0.055px;
      text-align: center;
      white-space: nowrap;
      height: 100%;
      min-width: fit-content;
      cursor: pointer;
      transition: all 0.2s ease;
      user-select: none;
      opacity: 0.5; /* Default deselected state */
    }
    
    /* Selected state - full opacity */
    .dropdown-prefix-tag.selected {
      opacity: 1;
      border-width: 2px;
    }

    .dropdown-prefix-tag.hero {
      background-color: var(--badge-hero-hero-fill, #da52b833);
      border-color: var(--badge-hero-hero-stroke, #d01b9c);
      color: var(--badge-hero-hero-text, #831568);
    }

    .dropdown-prefix-tag.parent {
      background-color: var(--badge-parent-parent-fill, #681b8133);
      border-color: var(--badge-parent-parent-stroke, #7a2ed6);
      color: var(--badge-parent-parent-text, #681b81);
    }

    .dropdown-prefix-tag.child {
      background-color: var(--badge-child-child-fill, #0d43d633);
      border-color: var(--badge-child-child-stroke, #0a6dc2);
      color: var(--badge-child-child-text, #075292);
    }

    .dropdown-prefix-tag.subchild {
      background-color: var(--badge-sub-child-subChild-fill, #013a6b33);
      border-color: var(--badge-sub-child-subChild-stroke, #0f92b2);
      color: var(--badge-sub-child-subChild-text, #013a6b);
    }
    
    .dropdown-prefix-tag.auto {
      background-color: var(--surface-neutral-100, rgba(255, 255, 255, 0.05));
      border-color: var(--surface-neutral-200, rgba(255, 255, 255, 0.2));
      color: var(--text-neutral-primary, rgba(255, 255, 255, 0.9));
    }
    
    .dropdown-prefix-tag.auto:hover {
      background-color: var(--surface-neutral-200, rgba(255, 255, 255, 0.1));
    }

    .dropdown-prefix-tag:hover {
      transform: translateY(-1px);
      opacity: 0.8; /* Increased opacity on hover for deselected state */
    }
    
    .dropdown-prefix-tag.selected:hover {
      opacity: 1; /* Keep full opacity when selected */
    }

    .dropdown-prefix-tag.hero:hover {
      background-color: var(--badge-hero-hero-button-hover, rgba(208, 27, 156, 0.3));
    }

    .dropdown-prefix-tag.parent:hover {
      background-color: var(--badge-parent-parent-button-hover, rgba(122, 46, 214, 0.25));
    }

    .dropdown-prefix-tag.child:hover {
      background-color: var(--badge-child-child-button-hover, rgba(10, 109, 194, 0.3));
    }

    .dropdown-prefix-tag.subchild:hover {
      background-color: var(--badge-sub-child-subChild-button-hover, rgba(15, 146, 178, 0.3));
    }

    /* Divider between option buttons */
    .dropdown-option-divider {
      width: 1px;
      height: 16px;
      background-color: var(--surface-brand-300, rgba(50, 122, 255, 0.4));
      margin: 0 4px;
    }

    /* Ghost Brand Button Style */
    .btn-ghost-brand {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 24px;
      height: 24px;
      border-radius: 5px;
      border: none;
      background-color: var(--button-ghost-brand-fill-default, rgba(50, 122, 255, 0));
      color: var(--button-ghost-brand-icon-default, #327aff);
      cursor: pointer;
      transition: all 0.2s ease;
      user-select: none;
    }

    .btn-ghost-brand:hover {
      background-color: var(--button-ghost-brand-fill-hover, rgba(50, 122, 255, 0.2));
      color: var(--button-ghost-brand-icon-hover, #327aff);
    }

    .btn-ghost-brand:active {
      background-color: var(--button-ghost-brand-fill-pressed, rgba(50, 122, 255, 0.3));
      color: var(--button-ghost-brand-icon-pressed, #327aff);
    }

    .btn-ghost-brand:disabled {
      background-color: var(--button-ghost-brand-fill-disabled, rgba(50, 122, 255, 0));
      color: var(--button-ghost-brand-icon-disabled, rgba(50, 122, 255, 0.5));
      cursor: not-allowed;
    }

    .btn-ghost-brand:focus {
      outline: none;
      border: none;
      box-shadow: none;
    }

    .btn-ghost-brand:focus-visible {
      outline: none;
      border: none;
      box-shadow: none;
    }

    /* Ghost Neutral Button Style */
    .btn-ghost-neutral {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 24px;
      height: 24px;
      border-radius: 5px;
      border: none;
      background-color: var(--button-ghost-neutral-fill-default, rgba(0, 0, 0, 0));
      color: var(--button-ghost-neutral-icon-default, rgba(0, 0, 0, 0.9));
      cursor: pointer;
      transition: all 0.2s ease;
      user-select: none;
    }

    .btn-ghost-neutral:hover {
      background-color: var(--button-ghost-neutral-fill-hover, rgba(0, 0, 0, 0.2));
      color: var(--button-ghost-neutral-icon-hover, rgba(0, 0, 0, 0.9));
    }

    .btn-ghost-neutral:active {
      background-color: var(--button-ghost-neutral-fill-pressed, rgba(0, 0, 0, 0.1));
      color: var(--button-ghost-neutral-icon-pressed, rgba(0, 0, 0, 0.9));
    }

    .btn-ghost-neutral:disabled {
      background-color: var(--button-ghost-neutral-fill-disabled, rgba(0, 0, 0, 0));
      color: var(--button-ghost-neutral-icon-disabled, rgba(0, 0, 0, 0.5));
      cursor: not-allowed;
    }

    .btn-ghost-neutral:focus {
      outline: none;
      border: none;
      box-shadow: none;
    }

    .btn-ghost-neutral:focus-visible {
      outline: none;
      border: none;
      box-shadow: none;
    }

    /* Dark mode support */
    @media (prefers-color-scheme: dark) {
      .btn-ghost-brand {
        background-color: var(--button-ghost-brand-fill-default, rgba(50, 122, 255, 0));
        color: var(--button-ghost-brand-icon-default, #5a9eff);
      }

      .btn-ghost-brand:hover {
        background-color: var(--button-ghost-brand-fill-hover, rgba(50, 122, 255, 0.3));
        color: var(--button-ghost-brand-icon-hover, #5a9eff);
      }

      .btn-ghost-brand:active {
        background-color: var(--button-ghost-brand-fill-pressed, rgba(50, 122, 255, 0.4));
        color: var(--button-ghost-brand-icon-pressed, #5a9eff);
      }

      .btn-ghost-brand:disabled {
        background-color: var(--button-ghost-brand-fill-disabled, rgba(50, 122, 255, 0));
        color: var(--button-ghost-brand-icon-disabled, rgba(90, 158, 255, 0.5));
      }

      .btn-ghost-neutral {
        background-color: var(--button-ghost-neutral-fill-default, rgba(255, 255, 255, 0));
        color: var(--button-ghost-neutral-icon-default, #ffffff);
      }

      .btn-ghost-neutral:hover {
        background-color: var(--button-ghost-neutral-fill-hover, rgba(255, 255, 255, 0.2));
        color: var(--button-ghost-neutral-icon-default, #ffffff);
      }

      .btn-ghost-neutral:active {
        background-color: var(--button-ghost-neutral-fill-pressed, rgba(255, 255, 255, 0.1));
        color: var(--button-ghost-neutral-icon-pressed, #ffffff);
      }

      .btn-ghost-neutral:disabled {
        background-color: var(--button-ghost-neutral-fill-disabled, rgba(255, 255, 255, 0));
        color: var(--button-ghost-neutral-icon-disabled, rgba(255, 255, 255, 0.5));
      }

      .btn-secondary {
        background-color: var(--button-secondary-neutral-button-secondary-neutral-fill-default, transparent);
        border-color: var(--button-secondary-neutral-button-secondary-neutral-stroke-default, rgba(255, 255, 255, 0.1));
        color: var(--button-secondary-neutral-button-secondary-neutral-text-default, #ffffff);
      }

      .btn-secondary:hover {
        background-color: var(--button-secondary-neutral-button-secondary-neutral-fill-hover, rgba(255, 255, 255, 0.05));
        border-color: var(--button-secondary-neutral-button-secondary-neutral-stroke-hover, rgba(255, 255, 255, 0.15));
      }

      .btn-secondary:active {
        background-color: var(--button-secondary-neutral-button-secondary-neutral-fill-pressed, rgba(255, 255, 255, 0.07));
        border-color: var(--button-secondary-neutral-button-secondary-neutral-stroke-pressed, transparent);
      }

      .btn-secondary:disabled {
        background-color: var(--button-secondary-neutral-button-secondary-neutral-fill-disabled, transparent);
        border-color: var(--button-secondary-neutral-button-secondary-neutral-stroke-disabled, transparent);
        color: var(--button-secondary-neutral-button-secondary-neutral-disabled, rgba(255, 255, 255, 0.5));
      }

      .btn-primary {
        background-color: var(--button-brand-fill-default, #0d99ff);
        color: var(--button-brand-text, #ffffff);
      }

      .btn-primary:hover {
        background-color: var(--button-brand-fill-hover, #0b8ae6);
      }

      .btn-primary:active {
        background-color: var(--button-brand-fill-pressed, #007be5);
      }

      .btn-primary:disabled {
        background-color: var(--button-brand-fill-disabled, rgba(13, 153, 255, 0.5));
        color: var(--button-brand-text, #ffffff);
      }

      .btn-primary:focus {
        outline: none;
        border: none;
        box-shadow: none;
      }

      .btn-primary:focus-visible {
        outline: none;
        border: none;
        box-shadow: none;
      }
    }

    /* Chevron button for going back - inherits from btn-ghost-neutral */
    .dropdown-chevron-btn {
      width: 24px;
      height: 24px;
      min-width: 24px;
      min-height: 24px;
      max-width: 24px;
      max-height: 24px;
      padding: 0;
      margin: 0;
    }

    .dropdown-chevron-btn svg {
      width: 16px;
      height: 16px;
      color: inherit;
    }

    /* Shared Layout Button Base Styles */
    .btn-layout-corner-radius,
    .btn-layout-padding,
    .btn-layout-spacing {
      border: none;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
      padding: 0;
      background: transparent;
      position: relative;
    }

    /* Layout Corner Radius Button - Specific Styles */
    .btn-layout-corner-radius {
      width: 36px;
      height: 36px;
      border-radius: 4px;
      flex-shrink: 0;
      flex-grow: 0;
    }

    .btn-layout-corner-radius svg {
      width: 100%;
      height: 100%;
      transition: fill 0.2s ease;
    }

    /* Layout Padding Button - Specific Styles */
    .btn-layout-padding {
      width: 36px;
      height: 36px;
      border-radius: 2px;
    }

    /* Left/Right Padding Buttons */
    .btn-layout-padding[data-padding="left"],
    .btn-layout-padding[data-padding="right"] {
      width: 16px;
      min-width: 16px;
      max-width: 16px;
      height: 100%;
    }

    /* Top/Bottom Padding Buttons */
    .btn-layout-padding[data-padding="top"],
    .btn-layout-padding[data-padding="bottom"] {
      width: 100%;
      height: 16px;
      flex-shrink: 0;
      flex-grow: 0;
    }

    .btn-layout-padding svg {
      width: 16px;
      height: 16px;
      transition: fill 0.2s ease;
    }

    .btn-layout-padding svg path {
      transition: fill 0.2s ease;
    }

    /* Spacing Control Buttons - Specific Styles */
    .btn-layout-spacing {
      max-width: 16px;
      height: 100%;
      border-radius: 2px;
      flex-shrink: 0;
      pointer-events: auto;
    }

    .btn-layout-spacing svg {
      width: 16px;
      height: 16px;
      transition: fill 0.2s ease;
    }

    .btn-layout-spacing svg path {
      transition: fill 0.2s ease;
    }

    /* Shared Active States - Background/Color Buttons (Padding & Spacing) */
    .btn-layout-padding.active,
    .btn-layout-spacing.active {
      background-color: var(--surface-brand-300, rgba(50, 122, 255, 0.4));
      color: var(--icon-brand-active, #327AFF);
    }

    .btn-layout-padding.active svg path,
    .btn-layout-spacing.active svg path {
      fill: currentColor;
    }

    .btn-layout-padding.active:hover,
    .btn-layout-spacing.active:hover {
      background-color: var(--surface-brand-500, rgba(50, 122, 255, 0.6));
      color: var(--icon-neutral-active, #2C2C2C);
    }

    .btn-layout-padding.active:hover svg path,
    .btn-layout-spacing.active:hover svg path {
      fill: currentColor;
    }

    .btn-layout-padding.active:active,
    .btn-layout-spacing.active:active {
      background-color: var(--surface-brand-300, rgba(50, 122, 255, 0.4));
      color: var(--icon-neutral-inactive, rgba(0, 0, 0, 0.5));
    }

    .btn-layout-padding.active:active svg path,
    .btn-layout-spacing.active:active svg path {
      fill: currentColor;
    }

    /* Shared Inactive States - Background/Color Buttons (Padding & Spacing) */
    .btn-layout-padding.inactive,
    .btn-layout-spacing.inactive {
      background-color: var(--surface-inverted-200, rgba(128, 128, 128, 0.2));
      color: var(--icon-neutral-inactive, rgba(0, 0, 0, 0.5));
    }

    .btn-layout-padding.inactive svg path,
    .btn-layout-spacing.inactive svg path {
      fill: currentColor;
    }

    .btn-layout-padding.inactive:hover,
    .btn-layout-spacing.inactive:hover {
      background-color: var(--surface-neutral-200, rgba(0, 0, 0, 0.2));
      color: var(--icon-neutral-active, #2C2C2C);
    }

    .btn-layout-padding.inactive:hover svg path,
    .btn-layout-spacing.inactive:hover svg path {
      fill: currentColor;
    }

    .btn-layout-padding.inactive:active,
    .btn-layout-spacing.inactive:active {
      background-color: var(--surface-inverted-300, rgba(128, 128, 128, 0.30));
      color: var(--icon-neutral-inactive, rgba(0, 0, 0, 0.5));
    }

    .btn-layout-padding.inactive:active svg path,
    .btn-layout-spacing.inactive:active svg path {
      fill: currentColor;
    }

    /* Corner Radius Active States - SVG Fill Only */
    .btn-layout-corner-radius.active svg {
      fill: var(--surface-brand-300, rgba(50, 122, 255, 0.4));
    }

    .btn-layout-corner-radius.active:hover svg {
      fill: var(--surface-brand-500, rgba(50, 122, 255, 0.6));
    }

    .btn-layout-corner-radius.active:active svg {
      fill: var(--surface-brand-300, rgba(50, 122, 255, 0.4));
    }

    /* Corner Radius Inactive States - SVG Fill Only */
    .btn-layout-corner-radius.inactive svg {
      fill: var(--surface-inverted-200, rgba(128, 128, 128, 0.2));
    }

    .btn-layout-corner-radius.inactive:hover svg {
      fill: var(--surface-neutral-200, rgba(0, 0, 0, 0.2));
    }

    .btn-layout-corner-radius.inactive:active svg {
      fill: var(--surface-inverted-200, rgba(128, 128, 128, 0.20));
    }

    /* Shared Disabled States - when dropdown is active */
    .layout-selection-container.disabled .btn-layout-corner-radius.active svg,
    .layout-selection-container.disabled .btn-layout-padding.active,
    .layout-selection-container.disabled .btn-layout-spacing.active {
      opacity: 0.5;
    }

    .layout-selection-container.disabled .btn-layout-corner-radius.active svg {
      fill: var(--surface-neutral-100, rgba(255, 255, 255, 0.10));
    }

    .layout-selection-container.disabled .btn-layout-padding.active,
    .layout-selection-container.disabled .btn-layout-spacing.active {
      background-color: var(--surface-neutral-100, rgba(255, 255, 255, 0.10));
      color: var(--icon-neutral-inactive, rgba(255, 255, 255, 0.50));
    }

    .layout-selection-container.disabled .btn-layout-padding.active svg path,
    .layout-selection-container.disabled .btn-layout-spacing.active svg path {
      fill: currentColor;
    }

    .layout-selection-container.disabled .btn-layout-corner-radius.inactive svg,
    .layout-selection-container.disabled .btn-layout-padding.inactive,
    .layout-selection-container.disabled .btn-layout-spacing.inactive {
      opacity: 0.5;
    }

    .layout-selection-container.disabled .btn-layout-corner-radius.inactive svg {
      fill: var(--surface-neutral-100, rgba(255, 255, 255, 0.10));
    }

    .layout-selection-container.disabled .btn-layout-padding.inactive,
    .layout-selection-container.disabled .btn-layout-spacing.inactive {
      background-color: var(--surface-neutral-100, rgba(255, 255, 255, 0.10));
      color: var(--icon-neutral-inactive, rgba(255, 255, 255, 0.50));
    }

    .layout-selection-container.disabled .btn-layout-padding.inactive svg path,
    .layout-selection-container.disabled .btn-layout-spacing.inactive svg path {
      fill: currentColor;
    }

    .layout-selection-container.disabled .btn-layout-corner-radius,
    .layout-selection-container.disabled .btn-layout-padding,
    .layout-selection-container.disabled .btn-layout-spacing {
      cursor: not-allowed;
      pointer-events: none;
    }

    /* Variable Mode Control Section Disabled State - when dropdown is active */
    .variable-mode-control-section.disabled {
      opacity: 0.5;
      pointer-events: none;
      cursor: not-allowed;
    }

    .variable-mode-control-section.disabled .variable-mode-segment,
    .variable-mode-control-section.disabled .variable-mode-input,
    .variable-mode-control-section.disabled .variable-mode-slider-container {
      cursor: not-allowed;
      pointer-events: none;
    }

    /* Layout Nested Wrapper */
    .layout-nested-wrapper {
      display: flex;
      align-items: center;
      gap: 8px;
      height: 100%;
      width: 100%;
    }

    /* Variable Mode Control Styles */
    .variable-mode-segment.active {
      background: var(--surface-neutral-200, rgba(255, 255, 255, 0.2)) !important;
      color: var(--text-text-primary, #2C2C2C) !important;
    }

    .variable-mode-segment:not(.active) {
      background: transparent !important;
      color: var(--text-text-secondary, rgba(0, 0, 0, 0.6)) !important;
    }

    .variable-mode-segment:hover:not(.active) {
      background: transparent;
    }

    .variable-mode-inputs {
      display: flex;
      flex-direction: row;
      gap: 4px;
      min-height: 24px;
      overflow: visible;
    }

    .variable-mode-input {
      position: relative;
      flex: 1;
      min-height: 24px;
    }

    .variable-mode-input:hover {
      background: var(--semantic-surface-neutral-200, rgba(0, 0, 0, 0.2)) !important;
    }

    .variable-mode-input-icon {
      color: var(--semantic-icon-neutral-active, #2c2c2c);
    }

    .variable-mode-input-chevron {
      color: var(--semantic-icon-neutral-active, #2c2c2c);
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .variable-mode-input-chevron svg {
      width: 12px;
      height: 12px;
      transition: transform 0.2s ease;
    }

    .variable-mode-input.has-open-dropdown .variable-mode-input-chevron svg {
      transform: rotate(180deg);
    }

    /* Manual Input Icon Wrapper Styles */
    .variable-mode-input-icon-wrapper {
      background: transparent;
    }

    .variable-mode-input-icon-wrapper:hover {
      background: var(--button-brand-fill-default, #0d99ff) !important;
    }

    .variable-mode-input-icon-wrapper.active {
      background: rgba(13, 153, 255, 0.5) !important;
    }

    /* Disabled state for manual inputs when slider is visible */
    .manual-inputs.has-active-slider .variable-mode-input:not(.slider-active) {
      opacity: 0.5;
      pointer-events: none;
      transition: opacity 0.2s ease;
    }

    /* Manual slider row animations */
    .manual-input-slider-row {
      max-height: 0;
      opacity: 0;
      overflow: hidden;
      transition: max-height 0.3s ease-in-out, opacity 0.3s ease-in-out, margin-top 0.3s ease-in-out;
    }

    .manual-input-slider-row.visible {
      max-height: 32px;
      opacity: 1;
    }

    /* Manual slider container dragging state */
    .manual-slider.dragging .variable-mode-slider-detent-markers {
      display: flex !important;
    }

    .manual-slider.dragging .variable-mode-slider-detent-marker {
      opacity: 1;
    }

    /* Variable Mode Slider Styles */
    .variable-mode-slider-handle:hover:not(:active) {
      background: var(--button-brand-fill-hover, #0b8ae6) !important;
      transform: translate(-50%, -50%) scale(1.15);
    }

    .variable-mode-slider-handle:active {
      background: var(--button-brand-fill-pressed, #007be5) !important;
      transform: translate(-50%, -50%) scale(1.05);
    }

    .variable-mode-slider-track:hover {
      background: transparent;
    }

    /* Variable Mode Slider Detent Markers */
    .variable-mode-slider-detent-marker {
      width: 4px;
      height: 4px;
      border-radius: 4px;
      background: var(--semantic-surface-neutral-300, rgba(0, 0, 0, 0.3));
      flex-shrink: 0;
      opacity: 0;
      transition: opacity 0.2s ease;
    }

    .variable-mode-slider-container.dragging .variable-mode-slider-detent-markers {
      display: flex !important;
    }

    .variable-mode-slider-container.dragging .variable-mode-slider-detent-marker {
      opacity: 1;
    }

    /* Global Scrollbar Styles */
    /* Scrollbar visibility: visible while scrolling/hovering, hidden otherwise */
    * {
      scrollbar-width: thin; /* Firefox */
      scrollbar-color: transparent transparent; /* Firefox - hidden by default */
    }

    /* Show scrollbar on hover of scrollable containers */
    *:hover {
      scrollbar-color: var(--surface-neutral-500, rgba(0, 0, 0, 0.5)) var(--surface-bg-bg, #FFFFFF); /* Firefox - visible on hover */
    }

    /* Show scrollbar when actively scrolling */
    *.scrolling {
      scrollbar-color: var(--surface-neutral-inverted-300, rgba(255, 255, 255, 0.3)) var(--surface-bg-bg, #FFFFFF);
    }

    /* Webkit scrollbar styles */
    *::-webkit-scrollbar {
      width: 8px;
      height: 8px;
      margin: 8px 0px 8px 0px;
      background: transparent; /* Hidden by default */
    }

    *::-webkit-scrollbar-track {
      background: var(--surface-bg-bg, #FFFFFF);
      border-radius: 4px;
    }

    *::-webkit-scrollbar-thumb {
      background: transparent; /* Hidden by default */
      border-radius: 4px;
      transition: background 0.2s ease;
    }

    /* Show scrollbar on hover */
    *:hover::-webkit-scrollbar-thumb {
      background: transparent;
    }

    /* Show scrollbar when actively scrolling */
    *.scrolling::-webkit-scrollbar-thumb {
      background: transparent;
    }

    /* Global Dropdown Container Styles */
    .variable-mode-dropdown {
      position: absolute;
      overflow: hidden;
      top: 100%;
      left: 0;
      right: 0;
      background: var(--surface-bg-bg, #FFFFFF);
      border: 1px solid var(--surface-neutral-200, rgba(0, 0, 0, 0.2));
      border-radius: var(--semantic-radius-xl, 12px);
      color: var(--surface-neutral-inverted-900, #808080);
      padding: 8px 0px 8px 8px; /* 8px top/bottom/left, 0px right to compensate for 8px scrollbar */
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
      z-index: 10000;
      max-height: 200px;
      min-height: 20px;
      overflow-y: auto;
      margin-top: 2px;
      display: block;
      visibility: visible;
    }

    /* Global Dropdown Scrollbar Styles - Positioned at right edge with 0px offsets */
    /* Apply to all dropdown containers */
    .variable-mode-dropdown,
    [class*="dropdown"]:not(.action-tag-dropdown):not(.dropdown-content-area):not(.dropdown-tags-section):not(.dropdown-options-section) {
      scrollbar-width: thin;
      scrollbar-color: transparent transparent; /* thumb transparent, track transparent */
    }

    .variable-mode-dropdown:hover,
    .variable-mode-dropdown.scrolling,
    [class*="dropdown"]:not(.action-tag-dropdown):not(.dropdown-content-area):not(.dropdown-tags-section):not(.dropdown-options-section):hover,
    [class*="dropdown"]:not(.action-tag-dropdown):not(.dropdown-content-area):not(.dropdown-tags-section):not(.dropdown-options-section).scrolling {
      scrollbar-color: var(--surface-neutral-inverted-300, rgba(255, 255, 255, 0.3)) transparent; /* thumb visible, track transparent */
    }

    /* Webkit scrollbar - positioned at right edge with 0px offsets from top, right, bottom */
    .variable-mode-dropdown::-webkit-scrollbar,
    [class*="dropdown"]:not(.action-tag-dropdown):not(.dropdown-content-area):not(.dropdown-tags-section):not(.dropdown-options-section)::-webkit-scrollbar {
      width: 8px;
      height: 8px;
      margin: 8px 0px 8px 0px;
      background: transparent;
    }

    .variable-mode-dropdown::-webkit-scrollbar-track,
    [class*="dropdown"]:not(.action-tag-dropdown):not(.dropdown-content-area):not(.dropdown-tags-section):not(.dropdown-options-section)::-webkit-scrollbar-track {
      background: none !important;
      background-color: transparent !important;
      border-radius: 0;
      margin-top: 8px;
      margin-bottom: 8px;
      margin-right: 0;
      border: none;
      box-shadow: none;
    }

    .variable-mode-dropdown::-webkit-scrollbar-thumb,
    [class*="dropdown"]:not(.action-tag-dropdown):not(.dropdown-content-area):not(.dropdown-tags-section):not(.dropdown-options-section)::-webkit-scrollbar-thumb {
      background: transparent;
      border-radius: 4px;
      transition: background 0.2s ease;
      border: 0;
      margin: 0;
    }

    .variable-mode-dropdown:hover::-webkit-scrollbar-thumb,
    .variable-mode-dropdown.scrolling::-webkit-scrollbar-thumb,
    [class*="dropdown"]:not(.action-tag-dropdown):not(.dropdown-content-area):not(.dropdown-tags-section):not(.dropdown-options-section):hover::-webkit-scrollbar-thumb,
    [class*="dropdown"]:not(.action-tag-dropdown):not(.dropdown-content-area):not(.dropdown-tags-section):not(.dropdown-options-section).scrolling::-webkit-scrollbar-thumb {
      background: transparent;
    }

    /* Global Dropdown Item Styles */
    .variable-mode-option {
      position: relative;
      padding: 6px 12px;
      cursor: pointer;
      font-family: var(--body-medium-fontfamily, 'Inter', sans-serif);
      font-size: 11px;
      color: var(--text-text-primary, #2C2C2C);
      background: none; /* Inactive: bg-fill none */
      border-radius: var(--semantic-radius-lg, 8px);
      transition: background 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }
    
    /* Text truncation for dropdown option text */
    .variable-mode-option > span {
      flex: 1;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      min-width: 0; /* Allows flex item to shrink below content size */
    }

    /* Check icon - hidden by default (inactive state) */
    .variable-mode-option .check-icon {
      width: 16px;
      height: 16px;
      flex-shrink: 0;
      opacity: 0; /* Hidden in inactive state */
      transition: opacity 0.2s ease;
      color: var(--text-text-primary, #2C2C2C);
    }

    .variable-mode-option .check-icon svg {
      width: 100%;
      height: 100%;
    }

    /* Inactive state - bg-fill: none, checkIcon: hidden */
    .variable-mode-option:not(.selected):not(:hover) {
      background: none;
    }

    .variable-mode-option:not(.selected):not(:hover) .check-icon {
      opacity: 0;
    }

    /* Hover state - bg-fill: brand-600, border-radius: lg, checkIcon: hidden */
    .variable-mode-option:hover:not(.selected) {
      background: var(--semantic-surface-brand-600, rgba(50, 122, 255, 0.7));
      border-radius: var(--semantic-radius-lg, 8px);
    }

    .variable-mode-option:hover:not(.selected) .check-icon {
      opacity: 0; /* Hidden on hover */
    }

    /* Active/Current state - bg-fill: brand-900, border-radius: lg, checkIcon: visible */
    .variable-mode-option.selected {
      background: var(--semantic-surface-brand-900, #327aff);
      border-radius: var(--semantic-radius-lg, 8px);
      color: var(--text-text-primary, #2C2C2C);
    }

    .variable-mode-option.selected .check-icon {
      opacity: 1; /* Visible when selected */
    }

    .variable-mode-option.selected:hover {
      background: var(--semantic-surface-brand-900, #327aff);
    }

    .variable-mode-option.selected:hover .check-icon {
      opacity: 1; /* Keep visible on hover when selected */
    }

    /* Tooltip styles */
    .padding-tooltip {
      position: absolute;
      bottom: calc(100% + 8px);
      left: 50%;
      transform: translateX(-50%);
      background-color: var(--surface-neutral-900, #2C2C2C);
      color: var(--text-on-dark, #FFFFFF);
      padding: 6px 10px;
      border-radius: 4px;
      font-size: 11px;
      font-weight: 400;
      white-space: nowrap;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s ease;
      z-index: 1000;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
    }

    /* Adjust tooltip position for left/right buttons */
    .btn-layout-padding[data-padding="left"] .padding-tooltip,
    .btn-layout-padding[data-padding="right"] .padding-tooltip {
      left: auto;
      right: 0;
      transform: none;
    }

    .btn-layout-padding[data-padding="right"] .padding-tooltip {
      left: 0;
      right: auto;
    }

    .padding-tooltip::after {
      content: '';
      position: absolute;
      top: 100%;
      left: 50%;
      transform: translateX(-50%);
      border: 4px solid transparent;
      border-top-color: var(--surface-neutral-900, #2C2C2C);
    }

    .btn-layout-padding[data-padding="left"] .padding-tooltip::after,
    .btn-layout-padding[data-padding="right"] .padding-tooltip::after {
      left: 8px;
      transform: none;
    }

    .btn-layout-padding[data-padding="right"] .padding-tooltip::after {
      left: auto;
      right: 8px;
    }

    /* Tooltip delay handled by JavaScript - CSS provides smooth transition */
    .btn-layout-padding .padding-tooltip,
    .btn-layout-corner-radius .padding-tooltip {
      transition: opacity 0.2s ease;
    }

    /* Light mode tooltip adjustments */
    @media (prefers-color-scheme: light) {
      .padding-tooltip {
        background-color: var(--surface-neutral-900, #2C2C2C);
        color: var(--text-on-dark, #FFFFFF);
      }
      .padding-tooltip::after {
        border-top-color: var(--surface-neutral-900, #2C2C2C);
      }
    }

    /* Dark mode tooltip adjustments */
    @media (prefers-color-scheme: dark) {
      .padding-tooltip {
        background-color: var(--surface-neutral-800, #3A3A3A);
        color: var(--text-on-dark, #FFFFFF);
      }
      .padding-tooltip::after {
        border-top-color: var(--surface-neutral-800, #3A3A3A);
      }
    }

    /* Layout Selection Container */
    .layout-selection-container {
      position: relative;
      display: flex;
      flex-direction: row;
      gap: 8px;
      width: 100%;
      height: 136px;
    }

    /* Layout Selection Wrapper */
    .layout-selection-wrapper {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100%;
      width: 100%;
      flex: 1;
      min-height: 0;
    }

    /* Absolute positioned container for nested layout */
    .layout-nested-container {
      position: absolute;
      top: 0;
      right: 0;
      bottom: 0;
      left: 0;
      padding: 24px;
      pointer-events: none;
    }

    /* Layout Nested Button */
    .btn-layout-nested {
      width: 100%;
      height: 100%;
      border: none;
      border-radius: 2px;
      cursor: pointer;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 8px;
      transition: all 0.2s ease;
      padding: 16px 0 0 0;
      background: transparent;
      pointer-events: auto;
      flex: 1 0 0;
      align-self: stretch;
    }

    .nested-icon-wrapper {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 24px;
      height: 24px;
      flex-shrink: 0;
      border-radius: 5px;
      transition: background-color 0.2s ease;
    }

    .btn-layout-nested svg {
      width: 24px;
      height: 25px;
      transition: fill 0.2s ease;
    }

    .btn-layout-nested svg path {
      transition: fill 0.2s ease;
    }

    .nested-text {
      font-family: 'Inter', sans-serif;
      font-weight: 450;
      font-size: 11px;
      line-height: 16px;
      letter-spacing: 0.055px;
      color: #2C2C2C;
      text-align: center;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      flex-shrink: 0;
    }

    /* Active States */
    .btn-layout-nested.active {
      background-color: var(--surface-brand-300, rgba(50, 122, 255, 0.4));
      color: var(--icon-brand-active, #327AFF);
    }

    .btn-layout-nested.active .nested-icon-wrapper {
      background-color: var(--surface-brand-300, rgba(50, 122, 255, 0.4));
    }

    .btn-layout-nested.active svg path {
      fill: currentColor;
    }

    .btn-layout-nested.active .nested-text {
      color: currentColor;
    }

    .btn-layout-nested.active:hover {
      background-color: var(--surface-brand-500, rgba(50, 122, 255, 0.6));
      color: var(--icon-neutral-active, #2C2C2C);
    }

    .btn-layout-nested.active:hover .nested-icon-wrapper {
      background-color: var(--surface-brand-500, rgba(50, 122, 255, 0.6));
    }

    .btn-layout-nested.active:hover svg path {
      fill: currentColor;
    }

    .btn-layout-nested.active:hover .nested-text {
      color: currentColor;
    }

    .btn-layout-nested.active:active {
      background-color: var(--surface-brand-300, rgba(50, 122, 255, 0.4));
      color: var(--icon-neutral-inactive, rgba(0, 0, 0, 0.5));
    }

    .btn-layout-nested.active:active .nested-icon-wrapper {
      background-color: var(--surface-brand-300, rgba(50, 122, 255, 0.4));
    }

    .btn-layout-nested.active:active svg path {
      fill: currentColor;
    }

    .btn-layout-nested.active:active .nested-text {
      color: currentColor;
    }

    /* Inactive States */
    .btn-layout-nested.inactive {
      background-color: var(--surface-inverted-200, rgba(128, 128, 128, 0.2));
      color: var(--icon-neutral-inactive, rgba(0, 0, 0, 0.5));
    }

    .btn-layout-nested.inactive .nested-icon-wrapper {
      background-color: var(--surface-inverted-200, rgba(128, 128, 128, 0.2));
    }

    .btn-layout-nested.inactive svg path {
      fill: currentColor;
    }

    .btn-layout-nested.inactive .nested-text {
      color: currentColor;
    }

    .btn-layout-nested.inactive:hover {
      background-color: var(--surface-neutral-200, rgba(0, 0, 0, 0.2));
      color: var(--icon-neutral-active, #2C2C2C);
    }

    .btn-layout-nested.inactive:hover .nested-icon-wrapper {
      background-color: var(--surface-neutral-200, rgba(0, 0, 0, 0.2));
    }

    .btn-layout-nested.inactive:hover svg path {
      fill: currentColor;
    }

    .btn-layout-nested.inactive:hover .nested-text {
      color: currentColor;
    }

    .btn-layout-nested.inactive:active {
      background-color: var(--surface-inverted-300, rgba(128, 128, 128, 0.30));
      color: var(--icon-neutral-inactive, rgba(0, 0, 0, 0.5));
    }

    .btn-layout-nested.inactive:active .nested-icon-wrapper {
      background-color: var(--surface-inverted-300, rgba(128, 128, 128, 0.30));
    }

    .btn-layout-nested.inactive:active svg path {
      fill: currentColor;
    }

    .btn-layout-nested.inactive:active .nested-text {
      color: currentColor;
    }

    /* Disabled States - when dropdown is active */
    .layout-selection-container.disabled .btn-layout-nested.active {
      background-color: var(--surface-neutral-100, rgba(255, 255, 255, 0.10));
      color: var(--icon-neutral-inactive, rgba(255, 255, 255, 0.50));
      opacity: 0.5;
    }

    .layout-selection-container.disabled .btn-layout-nested.active .nested-icon-wrapper {
      background-color: var(--surface-neutral-100, rgba(255, 255, 255, 0.10));
    }

    .layout-selection-container.disabled .btn-layout-nested.active svg path {
      fill: currentColor;
    }

    .layout-selection-container.disabled .btn-layout-nested.active .nested-text {
      color: currentColor;
    }

    .layout-selection-container.disabled .btn-layout-nested.inactive {
      background-color: var(--surface-neutral-100, rgba(255, 255, 255, 0.10));
      color: var(--icon-neutral-inactive, rgba(255, 255, 255, 0.50));
      opacity: 0.5;
    }

    .layout-selection-container.disabled .btn-layout-nested.inactive .nested-icon-wrapper {
      background-color: var(--surface-neutral-100, rgba(255, 255, 255, 0.10));
    }

    .layout-selection-container.disabled .btn-layout-nested.inactive svg path {
      fill: currentColor;
    }

    .layout-selection-container.disabled .btn-layout-nested.inactive .nested-text {
      color: currentColor;
    }

    .layout-selection-container.disabled .btn-layout-nested {
      cursor: not-allowed;
      pointer-events: none;
    }

    /* Spacing Control Container */
    .spacing-control-container {
      display: flex;
      align-items: center;
      justify-content: flex-start;
      width: 100%;
      max-width: 100%;
      height: 100%;
      box-sizing: border-box;
      min-width: 300px;
      overflow: hidden;
    }

    .spacing-control-wrapper {
      display: flex;
      flex-direction: row;
      align-items: center;
      width: 100%;
      max-width: 100%;
      height: 100%;
      min-width: 300px;
      box-sizing: border-box;
    }

    /* Spacing Layout Object Wrappers */
    .spacing-layout-object-wrapper {
      flex: 1 1 var(--spacing-layout-object-width, 7.14%); /* Dynamic width based on option count */
      min-width: var(--spacing-layout-object-width, 7.14%); /* Dynamic min-width based on option count */
      height: 100%;
      display: flex;
      align-items: center;
    }

    .spacing-layout-object-wrapper.left {
      padding-right: 6px; /* Padding on edge closest to drag control */
    }

    .spacing-layout-object-wrapper.right {
      padding-left: 6px; /* Padding on edge closest to drag control */
    }

    /* Spacing Layout Objects (left and right panels) */
    .spacing-layout-object {
      width: 100%;
      height: 100%;
      background: var(--surface-neutral-100, rgba(255, 255, 255, 0.1));
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 8px; /* 8px horizontal padding so detent markers aren't flush with edges */
      gap: 0;
    }

    /* Spacing Detent Markers */
    .spacing-detent-marker {
      width: 4px;
      height: 4px;
      border-radius: 4px;
      background: var(--surface-neutral-300, rgba(255, 255, 255, 0.3));
      flex-shrink: 0;
      opacity: 0;
      transition: opacity 0.2s ease;
    }

    .spacing-detent-marker.active {
      opacity: 1;
      background: var(--surface-neutral-400, rgba(255, 255, 255, 0.4));
    }
    
    .spacing-detent-marker.visible {
      opacity: 1;
      display: flex;
    }
    
    .spacing-detent-marker.hidden {
      opacity: 0;
      display: none;
    }
    
    /* Drag control markers are always visible when marked as visible, even during drag */
    .spacing-drag-control .spacing-detent-marker.visible {
      opacity: 1 !important;
      display: flex !important;
    }
    
    .spacing-control-container.dragging .spacing-drag-control .spacing-detent-marker.visible {
      opacity: 1 !important;
      display: flex !important;
    }
    
    /* Layout object markers only visible when dragging */
    .spacing-layout-object .spacing-detent-marker {
      opacity: 0;
      display: none;
    }
    
    .spacing-control-container.dragging .spacing-layout-object .spacing-detent-marker.visible {
      opacity: 1;
      display: flex;
    }

    /* Spacing Drag Control (central blue button) */
    .spacing-drag-control {
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: var(--button-brand-fill-default, #0c8ce9);
      border-radius: 2px;
      padding: 2px 4px; /* 4px horizontal padding */
      flex: 0 0 auto;
      position: relative;
      cursor: grab;
      transition: width 0.2s ease, min-width 0.2s ease;
      flex-shrink: 0;
    }
    
    /* Ensure smooth transitions even when width is set via inline styles */
    .spacing-drag-control[style*="width"] {
      transition: width 0.2s ease, min-width 0.2s ease !important;
    }

    .spacing-drag-control:active {
      cursor: grabbing;
    }

    /* Spacing Handles */
    .spacing-handle {
      width: 2px;
      height: 8px;
      cursor: ew-resize;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }

    .spacing-handle img {
      width: 100%;
      height: 100%;
      display: block;
    }

    /* Spacing Variable Mode Select */
    .spacing-variable-mode-select {
      display: flex;
      align-items: center;
      justify-content: space-between; /* Text on left, chevron on right when visible */
      gap: 4px;
      background: var(--surface-brand-300, rgba(120, 172, 250, 0.3));
      border-radius: 2px;
      padding: 0 4px 0 4px;
      cursor: pointer;
      transition: opacity 0.2s ease;
    }

    .spacing-control-container.dragging .spacing-variable-mode-select {
      opacity: 1;
      pointer-events: none;
      justify-content: center; /* Center text when chevron is hidden during drag */
    }
    
    .spacing-control-container.dragging .spacing-chevron-icon {
      opacity: 0;
      display: none; /* Hide completely during drag to center text */
    }

    .spacing-variable-mode-text {
      font-family: var(--body-medium-fontfamily, 'Inter:Medium', sans-serif);
      font-weight: var(--body-medium-fontweight, 450);
      font-size: var(--body-medium-fontsize, 11px);
      line-height: var(--body-medium-lineheight, 16px);
      letter-spacing: 0.055px;
      color: var(--text-text-primary, #ffffff);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .spacing-chevron-icon {
      width: 16px;
      height: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      color: var(--text-text-primary, #ffffff); /* Match text color so currentColor works */
    }

    .spacing-chevron-icon svg {
      width: 100%;
      height: 100%;
    }

    /* Action Buttons Row */
    .action-buttons-row {
      display: flex;
      flex-direction: row;
      gap: 8px;
      width: 100%;
      padding: 0;
      align-items: center;
      justify-content: space-between;
    }

    .layout-column {
      display: flex;
      flex-direction: column;
      gap: 8px;
      align-items: center;
      flex: 1;
      width: 100%;
    }

    /* Left and Right columns - fixed 36px width, fill height */
    .layout-column:first-child,
    .layout-column:last-child {
      width: 36px;
      height: 100%;
      flex: none;
      align-items: flex-start;
    }

    /* Right column - align to right */
    .layout-column:last-child {
      align-items: flex-end;
    }

    /* Center column with top/bottom padding buttons */
    .layout-column:has(.btn-layout-padding[data-padding="top"]) {
      justify-content: space-between;
    }

    .layout-spacer-column {
      flex: 1;
      width: 100%;
      height: 100%;
    }

    .layout-spacer {
      flex: 1;
      width: 100%;
      height: 100%;
    }


    /**************************************
     * MODAL STYLES (SHARED)
     **************************************/
    .modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(4px);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      opacity: 0;
      transition: opacity 0.2s ease-in-out;
    }
    
    .modal.show {
      opacity: 1;
    }
    
    .modal-content {
      background-color: var(--surface-bg-bg, #2C2C2C);
      border-radius: 12px;
      width: 90%;
      max-width: 400px;
      max-height: 90%;
      display: flex;
      flex-direction: column;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
      transform: scale(0.95);
      transition: transform 0.2s ease-in-out;
      overflow: hidden;
    }
    
    .modal.show .modal-content {
      transform: scale(1);
    }
    
    .modal-header {
      padding: 16px;
      border-bottom: 1px solid var(--surface-neutral-200, rgba(255, 255, 255, 0.2));
    }
    
    .modal-header h3 {
      margin: 0 0 8px 0;
      font-size: 14px;
      font-weight: 600;
      font-family: var(--body-medium-fontFamily, Inter), -apple-system, BlinkMacSystemFont, sans-serif;
      color: var(--text-text-primary, #FFFFFF);
      line-height: 20px;
    }
    
    .modal-header p {
      margin: 0;
      font-size: 12px;
      font-family: var(--body-medium-fontFamily, Inter), -apple-system, BlinkMacSystemFont, sans-serif;
      color: var(--text-text-secondary, rgba(255, 255, 255, 0.60));
      line-height: 16px;
    }
    
    .modal-body {
      padding: 12px 16px;
      overflow-y: auto;
      max-height: 400px;
      flex: 1;
      /* Firefox scrollbar */
      scrollbar-width: thin;
      scrollbar-color: var(--surface-neutral-200, rgba(255, 255, 255, 0.20)) var(--surface-neutral-100, rgba(255, 255, 255, 0.10));
    }
    
    /* Custom scrollbar styling for modal (Webkit browsers) */
    .modal-body::-webkit-scrollbar {
      width: 8px;
    }
    
    .modal-body::-webkit-scrollbar-track {
      background: var(--surface-neutral-100, rgba(255, 255, 255, 0.10));
      border-radius: 4px;
    }
    
    .modal-body::-webkit-scrollbar-thumb {
      background: var(--surface-neutral-200, rgba(255, 255, 255, 0.20));
      border-radius: 4px;
      transition: background 0.2s ease;
    }
    
    .modal-body::-webkit-scrollbar-thumb:hover {
      background: var(--surface-neutral-300, rgba(255, 255, 255, 0.30));
    }
    
    .modal-footer {
      padding: 12px 16px;
      border-top: 1px solid var(--surface-neutral-200, rgba(255, 255, 255, 0.2));
      display: flex;
      justify-content: flex-end;
      gap: var(--semantic-spacing-md);
    }
    
    .skip-nodes-list {
      display: flex;
      flex-direction: column;
      gap: var(--semantic-spacing-md);
    }
    
    .skip-node-item {
      display: flex;
      align-items: flex-start;
      padding: 10px 12px;
      border: 1px solid var(--surface-neutral-200, rgba(255, 255, 255, 0.2));
      border-radius: 8px;
      background-color: var(--surface-neutral-100, rgba(255, 255, 255, 0.10));
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    .skip-node-item:hover {
      background-color: var(--surface-neutral-200, rgba(255, 255, 255, 0.20));
      border-color: var(--surface-neutral-300, rgba(255, 255, 255, 0.30));
    }
    
    .skip-node-item.selected {
      background-color: var(--surface-brand-200, rgba(120, 172, 250, 0.20));
      border-color: var(--surface-brand-300, rgba(120, 172, 250, 0.30));
    }
    
    .skip-node-item.selected:hover {
      background-color: var(--surface-brand-300, rgba(120, 172, 250, 0.30));
      border-color: var(--surface-brand-500, rgba(120, 172, 250, 0.50));
    }
    
    .skip-node-checkbox {
      margin-right: 12px;
      margin-top: 2px;
      width: 16px;
      height: 16px;
      cursor: pointer;
      accent-color: var(--icon-brand-active, #78ACFA);
    }
    
    .skip-node-info {
      flex: 1;
      min-width: 0;
    }
    
    .skip-node-path {
      font-size: 11px;
      font-family: var(--body-medium-fontFamily, Inter), -apple-system, BlinkMacSystemFont, sans-serif;
      color: var(--text-text-secondary, rgba(255, 255, 255, 0.60));
      margin-bottom: 6px;
      word-break: break-all;
      line-height: 16px;
    }
    
    .skip-node-change {
      font-size: 12px;
      font-family: var(--body-medium-fontFamily, Inter), -apple-system, BlinkMacSystemFont, sans-serif;
      display: flex;
      align-items: center;
      gap: 8px;
      color: var(--text-text-primary, #FFFFFF);
      line-height: 16px;
    }
    
    .skip-node-arrow {
      color: var(--text-text-secondary, rgba(255, 255, 255, 0.60));
      flex-shrink: 0;
    }</style></head><body><div id="currentUi" class="container" style="display: none;"><div class="header"><h1>Layout Assistant - Cirrus Design System</h1><div class="header-buttons"><button id="helpButton" class="help-button">Need help?</button></div></div><div id="helpContent" class="help-content" style="display: none;"><p class="description">Apply layout variables from the Cirrus Native Design System to frames with specific naming patterns and auto-layout enabled.</p><div class="info-box"><div class="info-title">Variables to be applied:</div><ul class="info-list"><li><strong>Spacing</strong> â†’ Frame item spacing</li><li><strong>Padding</strong> â†’ Frame padding (all sides) - only for visual frames</li><li><strong>Corner Radius</strong> â†’ Frame corner radius</li></ul><p style="margin-top: 8px; font-size: 12px; color: #888;">Note: Padding is only applied to frames with visual styling (stroke, non-white fill, effects)</p></div><div class="info-box"><div class="info-title">Allowed Frame Names & Variable Modes:</div><ul class="info-list"><li><strong>parent.*</strong> â†’ Mode: "parent (default)"</li><li><strong>child.*</strong> â†’ Mode: "child"</li><li><strong>subChild.*</strong> â†’ Mode: "sub-child"</li><li><strong>hero.*</strong> â†’ Mode: "hero"</li></ul><p style="margin-top: 8px; font-size: 12px; color: #888;">Variable modes will be set for A1 Spacing, A4 Padding, and A5 Corner Radius collections</p></div><div class="info-box"><div class="info-title">Requirements:</div><ul class="info-list"><li>Frames must have auto-layout enabled</li><li>Frame names must start with an allowed prefix</li><li>"Cirrus - Native Design System" library must be enabled</li><li>Plugin will recursively check all nested frames</li><li>Only A6 Layout collection variables are applied</li></ul></div><div class="info-box"><div class="info-title">Visual vs. Structural Frames:</div><ul class="info-list"><li><strong>Visual frames</strong> (with stroke/color/effects) â†’ Get padding applied</li><li><strong>Structural frames</strong> (no visual styling) â†’ No padding applied</li></ul><p style="margin-top: 8px; font-size: 12px; color: #888;">Structural frames still get spacing and corner radius variables</p></div></div><div class="accordion"><div class="accordion-header" id="renameAccordionHeader"><span>Hierarchy Control</span><div class="accordion-icon">â–¼</div></div><div class="accordion-content" id="renameAccordionContent" style="display: none;"><div class="rename-panel"><div class="rename-preview"><div class="preview-label">Selected layer:</div><div class="preview-parent" id="parentLayerName"></div><div class="preview-name" id="currentLayerName">No layer selected</div></div><div class="auto-adjust-section"><button class="auto-adjust-button" id="autoAdjustButton">Auto Adjust</button><div class="auto-adjust-description">Automatically determines hierarchy based on parent container and adjusts this layer and its nested children.</div></div><div class="section-divider"><span>or manually adjust</span></div><div class="rename-buttons"><button class="rename-button" data-prefix="parent">parent</button> <button class="rename-button" data-prefix="child">child</button> <button class="rename-button" data-prefix="subChild">subChild</button> <button class="rename-button" data-prefix="hero">hero</button></div><div class="rename-preview-hover" id="previewNameChange"></div><div class="rename-options"><label class="toggle-container"><input type="checkbox" id="applyAfterRename"> <span class="toggle-slider"></span> <span class="toggle-label">Apply variables after rename</span></label> <label class="toggle-container"><input type="checkbox" id="renameNested"> <span class="toggle-slider"></span> <span class="toggle-label">Rename nested layers with prefixes</span></label></div></div></div></div><div class="button-container"><button class="primary-button" id="applyButton">Apply Variables</button> <button class="secondary-button" id="clearButton">Clear Variables</button></div><div class="loading" id="loading"><div class="spinner"></div><span id="loadingText">Processing...</span></div><div class="message" id="message"></div><div class="modal" id="hierarchySkipModal" style="display: none;"><div class="modal-content"><div class="modal-header"><h3>Hierarchy Skip Detected</h3><p>Some layers skip hierarchy levels (e.g., parent â†’ subChild). Select which layers to rename to follow natural hierarchy:</p></div><div class="modal-body"><div class="skip-nodes-list" id="skipNodesList"></div></div><div class="modal-footer"><button class="btn-secondary" id="skipCancelButton">Skip</button> <button class="btn-primary" id="skipApplyButton">Apply Selected</button></div></div></div></div><div id="newUi" class="dev-ui" style="padding: 8px;"><div class="section-inside" style="gap: 8px;"><div class="section-header"><div class="icon-container"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="none"><path d="M0.00390625 4C0.00390625 1.79086 1.79477 0 4.00391 0H12.0039C14.213 0 16.0039 1.79086 16.0039 4V12C16.0039 14.2091 14.213 16 12.0039 16H4.00391C1.79477 16 0.00390625 14.2091 0.00390625 12V4Z" fill="var(--surface-neutral-120, rgba(255, 255, 255, 0.12))"/><path fill-rule="evenodd" clip-rule="evenodd" d="M7.76819 2.93808C7.93419 2.82845 8.15998 2.84706 8.30612 2.99321L10.0168 4.70391C10.1838 4.87093 10.1838 5.14165 10.0168 5.30867C9.84981 5.47569 9.57908 5.47569 9.41206 5.30867L8.43142 4.32802V10.5661H11.4251C12.1337 10.5661 12.7082 11.1405 12.7082 11.8491C12.7082 12.5577 12.1337 13.1321 11.4251 13.1321H4.58234C3.87375 13.1321 3.29932 12.5577 3.29932 11.8491C3.29932 11.1405 3.87375 10.5661 4.58234 10.5661H7.57607V4.32802L6.59542 5.30867C6.42841 5.47569 6.15768 5.47569 5.99066 5.30867C5.82365 5.14165 5.82365 4.87093 5.99066 4.70391L7.70136 2.99321L7.76819 2.93808ZM4.58234 11.4214C4.34614 11.4214 4.15467 11.6129 4.15467 11.8491C4.15467 12.0853 4.34614 12.2768 4.58234 12.2768H11.4251C11.6613 12.2768 11.8528 12.0853 11.8528 11.8491C11.8528 11.6129 11.6613 11.4214 11.4251 11.4214H4.58234Z" fill="var(--icon-neutral-inactive, rgba(255, 255, 255, 0.70))"/><path d="M6.29304 7.14467C6.52924 7.14467 6.72072 7.33614 6.72072 7.57234C6.72072 7.80854 6.52924 8.00002 6.29304 8.00002H4.58234C4.34614 8.00002 4.15467 8.19149 4.15467 8.42769C4.15467 8.66389 4.34614 8.85537 4.58234 8.85537H6.29304C6.52924 8.85537 6.72072 9.04684 6.72072 9.28304C6.72072 9.51924 6.52924 9.71072 6.29304 9.71072H4.58234C3.87375 9.71072 3.29932 9.13629 3.29932 8.42769C3.29932 7.7191 3.87375 7.14467 4.58234 7.14467H6.29304Z" fill="var(--icon-neutral-inactive, rgba(255, 255, 255, 0.70))"/><path d="M11.4251 7.14467C12.1337 7.14467 12.7082 7.7191 12.7082 8.42769C12.7082 9.13629 12.1337 9.71072 11.4251 9.71072H9.71444C9.47825 9.71072 9.28677 9.51924 9.28677 9.28304C9.28677 9.04684 9.47825 8.85537 9.71444 8.85537H11.4251C11.6613 8.85537 11.8528 8.66389 11.8528 8.42769C11.8528 8.19149 11.6613 8.00002 11.4251 8.00002H9.71444C9.47825 8.00002 9.28677 7.80854 9.28677 7.57234C9.28677 7.33614 9.47825 7.14467 9.71444 7.14467H11.4251Z" fill="var(--icon-neutral-inactive, rgba(255, 255, 255, 0.70))"/></svg></div><span class="section-label">Inside</span></div><div class="section-container"><div class="structure-item" style="min-height: 24px; height: 24px;" id="devInsideItem"></div></div></div><div class="section-active" style="gap: 8px;"><div class="section-header"><div class="icon-container"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="none"><rect x="0.00390625" width="16" height="16" rx="4" fill="var(--surface-brand-300, rgba(120, 172, 250, 0.30))"/><path fill-rule="evenodd" clip-rule="evenodd" d="M7.32702 7.32311C7.56237 7.08776 7.91466 7.01436 8.22447 7.13594L13.2463 9.10903C13.5774 9.23911 13.7902 9.56435 13.7767 9.91984C13.7631 10.2752 13.5265 10.5828 13.1866 10.6873L11.2781 11.2742L10.6912 13.1827C10.5867 13.5226 10.2791 13.7592 9.92375 13.7728C9.56826 13.7863 9.24301 13.5735 9.11293 13.2424L7.13985 8.22057C7.01826 7.91075 7.09167 7.55846 7.32702 7.32311ZM9.89187 12.9367L10.6087 10.6048L12.9406 9.88796L7.91878 7.91488L9.89187 12.9367Z" fill="var(--icon-brand-active, #78ACFA)"/><path d="M10.4297 2.89307C11.3542 2.89307 12.1036 3.64251 12.1036 4.567V7.07791C12.1036 7.30903 11.9163 7.49639 11.6851 7.49639C11.454 7.49639 11.2667 7.30903 11.2667 7.07791V4.567C11.2667 4.10476 10.8919 3.73003 10.4297 3.73003H4.57091C4.10866 3.73003 3.73394 4.10476 3.73394 4.567V10.4258C3.73394 10.888 4.10866 11.2628 4.57091 11.2628H7.08181C7.31294 11.2628 7.5003 11.4501 7.5003 11.6812C7.5003 11.9124 7.31294 12.0997 7.08181 12.0997H4.57091C3.64642 12.0997 2.89697 11.3503 2.89697 10.4258V4.567C2.89697 3.64251 3.64642 2.89307 4.57091 2.89307H10.4297Z" fill="var(--icon-brand-active, #78ACFA)"/></svg></div><span class="section-label">Active</span></div><div class="section-container active" style="padding: 4px; display: flex; flex-direction: column; height: fit-content; min-height: fit-content;"><div class="header-dropdown-container" style="height: fit-content; min-height: 24px; padding-top: 4px; margin-bottom: 4px;"><div class="structure-item active" id="devActiveItem" style="padding: 0 4px;"></div><div class="dropdown-spacer" id="devActiveDropdownSpacer" style="height: 4px;"></div><div class="action-tag-dropdown" id="devActiveDropdown"><div class="dropdown-content-area" id="devActiveContentArea"><div class="dropdown-tags-section" id="devActiveTagsSection"></div><div class="dropdown-options-section" id="devActiveOptionsSection"><button class="btn-ghost-neutral dropdown-chevron-btn" data-action="back"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="none"><path d="M10 4L6 8L10 12" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg></button> <button class="btn-secondary-brand dropdown-option-btn" data-action="fix-nested">Fix Nested</button> <button class="btn-secondary-brand dropdown-option-btn" data-action="fix-variables">Fix Variables</button><div class="dropdown-option-divider"></div><button class="btn-primary dropdown-option-btn" data-action="apply">Apply</button></div></div></div></div><div class="variable-mode-control-section" id="variableModeControlSection" style="display: none; padding: 4px; margin-bottom: 2px; border-radius: 8px; background: rgba(0, 0, 0, 0.1); overflow: visible;"><div class="variable-mode-segmented-control" style="display: flex; gap: 2px;  min-height: 20px; border-radius: 8px; margin-bottom: 4px;"><button class="variable-mode-segment" data-mode="preset" style="flex: 1; padding: 2px; border-radius: 6px; border: none; background: transparent; cursor: pointer; font-family: var(--body-medium-fontfamily, 'Inter', sans-serif); font-size: 11px; color: var(--text-text-primary, #2C2C2C); transition: all 0.2s ease;">Preset</button> <button class="variable-mode-segment" data-mode="manual" style="flex: 1; padding: 2px; border-radius: 6px; border: none; background: transparent; cursor: pointer; font-family: var(--body-medium-fontfamily, 'Inter', sans-serif); font-size: 11px; color: var(--text-text-primary, #2C2C2C); transition: all 0.2s ease;">Manual</button></div><div class="variable-mode-inputs preset-inputs" id="presetModeInputs" style="display: none; gap: 4px; flex-direction: row; min-height: 24px; align-items: center;"><div class="variable-mode-input" data-collection="A1 ðŸ“ Layout" style="position: relative; background: var(--semantic-surface-neutral-100, rgba(0, 0, 0, 0.1)); border-radius: 4px; padding: 2px 4px 2px 4px; cursor: pointer; display: flex; align-items: center; gap: 2px; min-height: 24px; min-width: fit-content; flex-shrink: 1;"><div class="variable-mode-input-text" style="flex: 1; font-family: var(--body-medium-fontfamily, 'Inter', sans-serif); font-size: 11px; color: var(--text-text-primary, #2C2C2C); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; min-width: min-content;">Default</div><div class="variable-mode-input-chevron" style="width: 16px; height: 16px; flex-shrink: 1; display: flex; align-items: center; justify-content: center;"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 16 16" fill="none"><path d="M4 6L8 10L12 6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg></div></div><div class="variable-mode-slider-container" id="variableModeSliderContainer" style="display: flex; flex-grow: 2; align-items: center; background: var(--surface-brand-200, rgba(50, 122, 255, 0.2)); height: 24px; position: relative; min-width: 0; padding: 2px 10px 3px 10px; border-radius: 4px;"><div class="variable-mode-slider-detent-markers" id="variableModeSliderDetentMarkers" style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; display: none; flex-direction: row; align-items: center; justify-content: space-between; padding: 0 10px; z-index: 1; pointer-events: none;"></div><div class="variable-mode-slider-track" style="position: relative; width: 100%; height: 100%; border-radius: 2px; cursor: pointer;"><div class="variable-mode-slider-handle" id="variableModeSliderHandle" style="display: flex; align-items: center; justify-content: center; gap: 2px; position: absolute; width: 12px; height: 100%; background: var(--button-brand-fill-default, #0d99ff); border-radius: 2px; top: 50%; left: 0%; transform: translate(-50%, -50%); cursor: grab; transition: background 0.2s ease, transform 0.2s ease; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2); z-index: 1; pointer-events: auto;"><div class="variable-mode-slider-handle-icon" style="width: 2px; height: 8px; background: white; border-radius: 1px; flex-shrink: 0;"></div><div class="variable-mode-slider-handle-icon" style="width: 2px; height: 8px; background: white; border-radius: 1px; flex-shrink: 0;"></div></div></div></div></div><div class="variable-mode-inputs manual-inputs" id="manualModeInputs" style="display: none; gap: 4px; flex-direction: column; min-height: 24px;"><div class="manual-inputs-row" style="display: flex; flex-direction: row; gap: 4px; align-items: start;"><div class="variable-mode-input" data-collection="A2 ðŸ“¦ Padding" style="position: relative; background: var(--semantic-surface-neutral-100, rgba(0, 0, 0, 0.1)); border-radius: 4px; padding: 2px 4px; cursor: pointer; display: flex; align-items: center; gap: 2px; flex: 1; min-height: 24px;"><div class="variable-mode-input-icon-wrapper" style="width: 16px; height: 16px; display: flex; align-items: center; justify-content: center; border-radius: 2px; cursor: pointer; flex-shrink: 0; transition: background 0.2s ease;"><div class="variable-mode-input-icon" style="width: 16px; height: 16px;"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="none"><path d="M12 5.5C12 5.22386 12.2239 5 12.5 5C12.7761 5.00001 13 5.22387 13 5.5V10.5C13 10.7761 12.7761 11 12.5 11C12.2239 11 12 10.7761 12 10.5V5.5Z" fill="currentColor"/><path d="M5 12.5C5 12.2239 5.22386 12 5.5 12H10.5C10.7761 12 11 12.2239 11 12.5C11 12.7761 10.7761 13 10.5 13H5.5C5.22387 13 5.00002 12.7761 5 12.5Z" fill="currentColor"/><path d="M5 3.5C5 3.22386 5.22386 3 5.5 3H10.5C10.7761 3.00001 11 3.22387 11 3.5C11 3.77612 10.7761 3.99999 10.5 4H5.5C5.22387 4 5.00002 3.77612 5 3.5Z" fill="currentColor"/><path d="M3 5.5C3 5.22386 3.22386 5 3.5 5C3.77613 5.00001 4 5.22387 4 5.5V10.5C3.99998 10.7761 3.77612 11 3.5 11C3.22387 11 3.00002 10.7761 3 10.5V5.5Z" fill="currentColor"/></svg></div></div><div class="variable-mode-input-text" style="flex: 1; font-family: var(--body-medium-fontfamily, 'Inter', sans-serif); font-size: 11px; color: var(--text-text-primary, #2C2C2C); overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">Default</div><div class="variable-mode-input-chevron" style="width: 16px; height: 16px; flex-shrink: 0;"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="none"><path d="M4 6L8 10L12 6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg></div></div><div class="variable-mode-input" data-collection="A4 â•­ Corner Radius" style="position: relative; background: var(--semantic-surface-neutral-100, rgba(0, 0, 0, 0.1)); border-radius: 4px; padding: 2px 4px; cursor: pointer; display: flex; align-items: center; gap: 2px; flex: 1; min-height: 24px;"><div class="variable-mode-input-icon-wrapper" style="width: 16px; height: 16px; display: flex; align-items: center; justify-content: center; border-radius: 2px; cursor: pointer; flex-shrink: 0; transition: background 0.2s ease;"><div class="variable-mode-input-icon" style="width: 16px; height: 16px;"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="none"><path d="M2.5 10C2.77614 10 3 10.2239 3 10.5V11.0996C3 11.5279 3.00017 11.8199 3.01855 12.0449C3.03647 12.2639 3.06956 12.376 3.10938 12.4541C3.20521 12.6421 3.35793 12.7948 3.5459 12.8906C3.62405 12.9304 3.73615 12.9635 3.95508 12.9814C4.18012 12.9998 4.4721 13 4.90039 13H5.5C5.77614 13 6 13.2239 6 13.5C6 13.7761 5.77614 14 5.5 14H4.90039C4.4886 14 4.14924 14 3.87402 13.9775C3.59301 13.9546 3.33444 13.9059 3.0918 13.7822C2.71554 13.5905 2.40951 13.2845 2.21777 12.9082C2.09414 12.6656 2.04543 12.407 2.02246 12.126C1.99998 11.8508 2 11.5114 2 11.0996V10.5C2 10.2239 2.22386 10 2.5 10Z" fill="currentColor"/><path d="M13.5 10C13.7761 10 14 10.2239 14 10.5V11.0996C14 11.5114 14 11.8508 13.9775 12.126C13.9546 12.407 13.9059 12.6656 13.7822 12.9082C13.5905 13.2845 13.2845 13.5905 12.9082 13.7822C12.6656 13.9059 12.407 13.9546 12.126 13.9775C11.8508 14 11.5114 14 11.0996 14H10.5C10.2239 14 10 13.7761 10 13.5C10 13.2239 10.2239 13 10.5 13H11.0996C11.5279 13 11.8199 12.9998 12.0449 12.9814C12.2639 12.9635 12.376 12.9304 12.4541 12.8906C12.6421 12.7948 12.7948 12.6421 12.8906 12.4541C12.9304 12.376 12.9635 12.2639 12.9814 12.0449C12.9998 11.8199 13 11.5279 13 11.0996V10.5C13 10.2239 13.2239 10 13.5 10Z" fill="currentColor"/><path d="M5.5 2C5.77614 2 6 2.22386 6 2.5C6 2.77614 5.77614 3 5.5 3H4.90039C4.47217 3 4.1801 3.00017 3.95508 3.01855C3.73623 3.03647 3.62403 3.06956 3.5459 3.10938C3.35797 3.20522 3.2052 3.35796 3.10938 3.5459C3.06957 3.62405 3.03647 3.73619 3.01855 3.95508C3.00017 4.18012 3 4.47211 3 4.90039V5.5C3 5.77614 2.77614 6 2.5 6C2.22391 5.99993 2 5.7761 2 5.5V4.90039C2 4.48861 1.99998 4.14923 2.02246 3.87402C2.04543 3.59303 2.09416 3.33442 2.21777 3.0918C2.40949 2.71558 2.71559 2.40951 3.0918 2.21777C3.3344 2.09416 3.59306 2.04543 3.87402 2.02246C4.14921 1.99998 4.48866 2 4.90039 2H5.5Z" fill="currentColor"/><path d="M11.0996 2C11.5114 2 11.8508 1.99998 12.126 2.02246C12.407 2.04543 12.6656 2.09414 12.9082 2.21777C13.2845 2.40951 13.5905 2.71554 13.7822 3.0918C13.9059 3.33444 13.9546 3.59301 13.9775 3.87402C14 4.14924 14 4.4886 14 4.90039V5.5C14 5.77614 13.7761 6 13.5 6C13.2239 6 13 5.77614 13 5.5V4.90039C13 4.4721 12.9998 4.18012 12.9814 3.95508C12.9635 3.73615 12.9304 3.62405 12.8906 3.5459C12.7948 3.35793 12.6421 3.20521 12.4541 3.10938C12.376 3.06956 12.2639 3.03647 12.0449 3.01855C11.8199 3.00017 11.5279 3 11.0996 3H10.5C10.2239 3 10 2.77614 10 2.5C10 2.22386 10.2239 2 10.5 2H11.0996Z" fill="currentColor"/></svg></div></div><div class="variable-mode-input-text" style="flex: 1; font-family: var(--body-medium-fontfamily, 'Inter', sans-serif); font-size: 11px; color: var(--text-text-primary, #2C2C2C); overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">Default</div><div class="variable-mode-input-chevron" style="width: 16px; height: 16px; flex-shrink: 0;"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="none"><path d="M4 6L8 10L12 6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg></div></div><div class="variable-mode-input" data-collection="A3 â†”ï¸ Spacing" style="position: relative; background: var(--semantic-surface-neutral-100, rgba(0, 0, 0, 0.1)); border-radius: 4px; padding: 2px 4px; cursor: pointer; display: flex; align-items: center; gap: 2px; flex: 1; min-height: 24px;"><div class="variable-mode-input-icon-wrapper" style="width: 16px; height: 16px; display: flex; align-items: center; justify-content: center; border-radius: 2px; cursor: pointer; flex-shrink: 0; transition: background 0.2s ease;"><div class="variable-mode-input-icon" style="width: 16px; height: 16px;"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="none"><path d="M4.25 3.5C4.94036 3.5 5.5 4.05964 5.5 4.75V11.25C5.5 11.9404 4.94036 12.5 4.25 12.5H4C3.72386 12.5 3.5 12.2761 3.5 12C3.5 11.7239 3.72386 11.5 4 11.5H4.25C4.38807 11.5 4.5 11.3881 4.5 11.25V4.75C4.5 4.61193 4.38807 4.5 4.25 4.5H4C3.72386 4.5 3.5 4.27614 3.5 4C3.5 3.72386 3.72386 3.5 4 3.5H4.25ZM12 3.5C12.2761 3.5 12.4999 3.72397 12.5 4C12.4999 4.27609 12.2761 4.5 12 4.5H11.75C11.612 4.5 11.5001 4.61204 11.5 4.75V11.25C11.5 11.3881 11.6119 11.5 11.75 11.5H12C12.2761 11.5 12.4999 11.724 12.5 12C12.5 12.2761 12.2761 12.5 12 12.5H11.75C11.0596 12.5 10.5 11.9404 10.5 11.25V4.75C10.5001 4.05976 11.0597 3.5 11.75 3.5H12ZM8 5.5C8.27614 5.5 8.5 5.72386 8.5 6V10C8.5 10.2761 8.27614 10.5 8 10.5C7.72386 10.5 7.5 10.2761 7.5 10V6C7.5 5.72386 7.72386 5.5 8 5.5Z" fill="currentColor"/></svg></div></div><div class="variable-mode-input-text" style="flex: 1; font-family: var(--body-medium-fontfamily, 'Inter', sans-serif); font-size: 11px; color: var(--text-text-primary, #2C2C2C); overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">Default</div><div class="variable-mode-input-chevron" style="width: 16px; height: 16px; flex-shrink: 0;"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="none"><path d="M4 6L8 10L12 6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg></div></div></div><div class="manual-input-slider-row" data-collection="A2 ðŸ“¦ Padding" style="display: none; margin-top: 4px; width: 100%;"><div class="variable-mode-slider-container manual-slider" style="flex: 1; display: flex; align-items: center; background: var(--surface-brand-200, rgba(50, 122, 255, 0.2)); height: 24px; position: relative; min-width: 0; padding: 2px 10px 3px 10px; border-radius: 4px;"><div class="variable-mode-slider-detent-markers" style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; display: none; flex-direction: row; align-items: center; justify-content: space-between; padding: 0 10px; z-index: 1; pointer-events: none;"></div><div class="variable-mode-slider-track" style="position: relative; width: 100%; height: 100%; border-radius: 2px; cursor: pointer;"><div class="variable-mode-slider-handle manual-slider-handle" style="display: flex; align-items: center; justify-content: center; gap: 2px; position: absolute; width: 12px; height: 100%; background: var(--button-brand-fill-default, #0d99ff); border-radius: 2px; top: 50%; left: 0%; transform: translate(-50%, -50%); cursor: grab; transition: background 0.2s ease, transform 0.2s ease; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2); z-index: 1; pointer-events: auto;"><div class="variable-mode-slider-handle-icon" style="width: 2px; height: 8px; background: white; border-radius: 1px; flex-shrink: 0;"></div><div class="variable-mode-slider-handle-icon" style="width: 2px; height: 8px; background: white; border-radius: 1px; flex-shrink: 0;"></div></div></div></div></div><div class="manual-input-slider-row" data-collection="A4 â•­ Corner Radius" style="display: none; margin-top: 4px; width: 100%;"><div class="variable-mode-slider-container manual-slider" style="flex: 1; display: flex; align-items: center; background: var(--surface-brand-200, rgba(50, 122, 255, 0.2)); height: 24px; position: relative; min-width: 0; padding: 2px 10px 3px 10px; border-radius: 4px;"><div class="variable-mode-slider-detent-markers" style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; display: none; flex-direction: row; align-items: center; justify-content: space-between; padding: 0 10px; z-index: 1; pointer-events: none;"></div><div class="variable-mode-slider-track" style="position: relative; width: 100%; height: 100%; border-radius: 2px; cursor: pointer;"><div class="variable-mode-slider-handle manual-slider-handle" style="display: flex; align-items: center; justify-content: center; gap: 2px; position: absolute; width: 12px; height: 100%; background: var(--button-brand-fill-default, #0d99ff); border-radius: 2px; top: 50%; left: 0%; transform: translate(-50%, -50%); cursor: grab; transition: background 0.2s ease, transform 0.2s ease; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2); z-index: 1; pointer-events: auto;"><div class="variable-mode-slider-handle-icon" style="width: 2px; height: 8px; background: white; border-radius: 1px; flex-shrink: 0;"></div><div class="variable-mode-slider-handle-icon" style="width: 2px; height: 8px; background: white; border-radius: 1px; flex-shrink: 0;"></div></div></div></div></div><div class="manual-input-slider-row" data-collection="A3 â†”ï¸ Spacing" style="display: none; margin-top: 4px; width: 100%;"><div class="variable-mode-slider-container manual-slider" style="flex: 1; display: flex; align-items: center; background: var(--surface-brand-200, rgba(50, 122, 255, 0.2)); height: 24px; position: relative; min-width: 0; padding: 2px 10px 3px 10px; border-radius: 4px;"><div class="variable-mode-slider-detent-markers" style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; display: none; flex-direction: row; align-items: center; justify-content: space-between; padding: 0 10px; z-index: 1; pointer-events: none;"></div><div class="variable-mode-slider-track" style="position: relative; width: 100%; height: 100%; border-radius: 2px; cursor: pointer;"><div class="variable-mode-slider-handle manual-slider-handle" style="display: flex; align-items: center; justify-content: center; gap: 2px; position: absolute; width: 12px; height: 100%; background: var(--button-brand-fill-default, #0d99ff); border-radius: 2px; top: 50%; left: 0%; transform: translate(-50%, -50%); cursor: grab; transition: background 0.2s ease, transform 0.2s ease; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2); z-index: 1; pointer-events: auto;"><div class="variable-mode-slider-handle-icon" style="width: 2px; height: 8px; background: white; border-radius: 1px; flex-shrink: 0;"></div><div class="variable-mode-slider-handle-icon" style="width: 2px; height: 8px; background: white; border-radius: 1px; flex-shrink: 0;"></div></div></div></div></div></div></div><div class="layout-selection-wrapper" style="height: fit-content; min-height: 136px; padding: 2px 4px; align-items: flex-end;"><div class="spacing-control-container" id="spacingControlContainer" style="display: none; min-height: 136px; height: 100%; width: 100%;"><div class="spacing-control-wrapper" style="height: 100%; min-height: 136px; padding: 4px; background: var(--surface-neutral-inverted-200, rgba(0, 0, 0, 0.2)); border-radius: 8px;"><div class="spacing-layout-object-wrapper left" style="height: 100%; min-height: 136px;"><div class="spacing-layout-object" data-name="layoutObject" style="height: 100%; min-height: 136px;"><div class="spacing-detent-marker" data-name="detentMarker" data-index="0"></div><div class="spacing-detent-marker" data-name="detentMarker" data-index="1"></div><div class="spacing-detent-marker" data-name="detentMarker" data-index="2"></div><div class="spacing-detent-marker" data-name="detentMarker" data-index="3"></div><div class="spacing-detent-marker" data-name="detentMarker" data-index="4"></div><div class="spacing-detent-marker" data-name="detentMarker" data-index="5"></div></div></div><div class="spacing-drag-control" data-name="dragControl.gap"><div class="spacing-handle" data-name="handle" data-handle="left"><img src="data:image/svg+xml,%3Csvg width='2' height='8' viewBox='0 0 2 8' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M1 0V8' stroke='%23FFFFFF' stroke-width='1'/%3E%3C/svg%3E" alt=""/></div><div class="spacing-detent-marker" data-name="detentMarker" data-index="0"></div><div class="spacing-detent-marker" data-name="detentMarker" data-index="1"></div><div class="spacing-detent-marker" data-name="detentMarker" data-index="2"></div><div class="spacing-variable-mode-select" data-name="selectInput.variableMode"><div class="spacing-variable-mode-text" data-name="variableModeText">0</div><div class="spacing-chevron-icon" data-name="icon.16.chevron.down"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="none"><path d="M4 6L8 10L12 6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg></div></div><div class="spacing-detent-marker" data-name="detentMarker" data-index="3"></div><div class="spacing-detent-marker" data-name="detentMarker" data-index="4"></div><div class="spacing-detent-marker" data-name="detentMarker" data-index="5"></div><div class="spacing-handle" data-name="handle" data-handle="right"><img src="data:image/svg+xml,%3Csvg width='2' height='8' viewBox='0 0 2 8' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M1 0V8' stroke='%23FFFFFF' stroke-width='1'/%3E%3C/svg%3E" alt=""/></div></div><div class="spacing-layout-object-wrapper right" style="height: 100%; min-height: 136px;"><div class="spacing-layout-object" data-name="layoutObject" style="height: 100%; min-height: 136px;"><div class="spacing-detent-marker" data-name="detentMarker" data-index="0"></div><div class="spacing-detent-marker" data-name="detentMarker" data-index="1"></div><div class="spacing-detent-marker" data-name="detentMarker" data-index="2"></div><div class="spacing-detent-marker" data-name="detentMarker" data-index="3"></div><div class="spacing-detent-marker" data-name="detentMarker" data-index="4"></div><div class="spacing-detent-marker" data-name="detentMarker" data-index="5"></div></div></div></div></div><div class="layout-selection-container" id="layoutSelectionContainer" style="min-height: 136px; height: fit-content;"><div class="layout-column" style="width:36px; min-width:36px; max-width:36px; flex-direction: column; min-height: 136px;"><button class="btn-layout-corner-radius active" data-corner="top-left"><span class="padding-tooltip">Ctrl+Click to select individually</span> <svg width="36" height="36" viewBox="0 0 36 36" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M24 16.64H34.004C35.1086 16.64 36.004 15.7446 36.004 14.64V2.64044C36.004 1.53587 35.1086 0.640442 34.004 0.640442H24C10.7452 0.640442 0 11.3856 0 24.6404V34.6405C0 35.7451 0.895432 36.6405 2 36.6405H14C15.1046 36.6405 16 35.7451 16 34.6405V24.64C16 20.2217 19.5817 16.64 24 16.64Z"/></svg></button> <button class="btn-layout-padding active" data-padding="left"><span class="padding-tooltip">Ctrl+Click to select individually</span> <svg width="36" height="36" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3.5 3C3.77614 3 4 3.22386 4 3.5V12.5C4 12.7761 3.77614 13 3.5 13C3.22386 13 3 12.7761 3 12.5V3.5C3 3.22386 3.22386 3 3.5 3Z" fill="currentColor"/><path fill-rule="evenodd" clip-rule="evenodd" d="M9 6C9.55228 6 10 6.44772 10 7V9L9.99512 9.10254C9.94379 9.60667 9.51768 10 9 10H7L6.89746 9.99512C6.39333 9.94379 6 9.51768 6 9V7C6 6.44772 6.44772 6 7 6H9ZM9 7H7V9H9V7Z" fill="currentColor"/></svg></button> <button class="btn-layout-corner-radius active" data-corner="bottom-left"><span class="padding-tooltip">Ctrl+Click to select individually</span> <svg width="36" height="36" viewBox="0 0 36 36" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M24 20.2924H34.004C35.1086 20.2924 36.004 21.1878 36.004 22.2924V34.2919C36.004 35.3965 35.1086 36.2919 34.004 36.2919H24C10.7452 36.2919 0 25.5468 0 12.2919V2.29184C0 1.18727 0.895432 0.291847 2 0.291847H14C15.1046 0.291847 16 1.18728 16 2.29185V12.2924C16 16.7106 19.5817 20.2924 24 20.2924Z"/></svg></button></div><div class="layout-column"><button class="btn-layout-padding active" data-padding="top"><span class="padding-tooltip">Ctrl+Click to select individually</span> <svg width="36" height="36" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3 3.5C3 3.22386 3.22386 3 3.5 3H12.5C12.7761 3 13 3.22386 13 3.5C13 3.77614 12.7761 4 12.5 4H3.5C3.22386 4 3 3.77614 3 3.5Z" fill="currentColor"/><path fill-rule="evenodd" clip-rule="evenodd" d="M6 7C6 6.44772 6.44772 6 7 6H9L9.10254 6.00488C9.60667 6.05621 10 6.48232 10 7V9L9.99512 9.10254C9.94379 9.60667 9.51768 10 9 10H7C6.44772 10 6 9.55228 6 9V7ZM7 7V9H9V7H7Z" fill="currentColor"/></svg></button> <button class="btn-layout-padding active" data-padding="bottom"><span class="padding-tooltip">Ctrl+Click to select individually</span> <svg width="36" height="36" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M12.5 12C12.7761 12 13 12.2239 13 12.5C13 12.7761 12.7761 13 12.5 13H3.5C3.22386 13 3 12.7761 3 12.5C3 12.2239 3.22386 12 3.5 12H12.5Z" fill="currentColor"/><path fill-rule="evenodd" clip-rule="evenodd" d="M9.10254 6.00488C9.60667 6.05621 10 6.48232 10 7V9L9.99512 9.10254C9.94379 9.60667 9.51768 10 9 10H7C6.44772 10 6 9.55228 6 9V7C6 6.44772 6.44772 6 7 6H9L9.10254 6.00488ZM7 9H9V7H7V9Z" fill="currentColor"/></svg></button></div><div class="layout-column" style="width:36px; min-width:36px; max-width:36px; align-items: flex-end; flex-direction: column;"><button class="btn-layout-corner-radius active" data-corner="top-right"><span class="padding-tooltip">Ctrl+Click to select individually</span> <svg width="36" height="36" viewBox="0 0 36 36" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M12.9879 16.64H2.98389C1.87932 16.64 0.983887 15.7446 0.983887 14.64V2.64044C0.983887 1.53587 1.87932 0.640442 2.98389 0.640442H12.9879C26.2427 0.640442 36.9879 11.3856 36.9879 24.6404V34.6405C36.9879 35.7451 36.0925 36.6405 34.9879 36.6405H22.9879C21.8833 36.6405 20.9879 35.7451 20.9879 34.6405V24.64C20.9879 20.2217 17.4062 16.64 12.9879 16.64Z"/></svg></button> <button class="btn-layout-padding active" data-padding="right"><span class="padding-tooltip">Ctrl+Click to select individually</span> <svg width="36" height="36" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M12.5 3C12.7761 3 13 3.22386 13 3.5V12.5C13 12.7761 12.7761 13 12.5 13C12.2239 13 12 12.7761 12 12.5V3.5C12 3.22386 12.2239 3 12.5 3Z" fill="currentColor"/><path fill-rule="evenodd" clip-rule="evenodd" d="M9 6C9.55228 6 10 6.44772 10 7V9L9.99512 9.10254C9.94379 9.60667 9.51768 10 9 10H7L6.89746 9.99512C6.39333 9.94379 6 9.51768 6 9V7C6 6.44772 6.44772 6 7 6H9ZM9 7H7V9H9V7Z" fill="currentColor"/></svg></button> <button class="btn-layout-corner-radius active" data-corner="bottom-right"><span class="padding-tooltip">Ctrl+Click to select individually</span> <svg width="36" height="36" viewBox="0 0 36 36" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M12.9879 20.2924H2.98389C1.87932 20.2924 0.983887 21.1878 0.983887 22.2924V34.2919C0.983887 35.3965 1.87932 36.2919 2.98389 36.2919H12.9879C26.2427 36.2919 36.9879 25.5468 36.9879 12.2919V2.29184C36.9879 1.18727 36.0925 0.291847 34.9879 0.291847H22.9879C21.8833 0.291847 20.9879 1.18728 20.9879 2.29185V12.2924C20.9879 16.7106 17.4062 20.2924 12.9879 20.2924Z"/></svg></button></div><div class="layout-nested-container" style="position: absolute; top: 0; right: 0; bottom: 0; left: 0;"><div class="layout-nested-wrapper" style="display: flex; align-items: center; gap: 8px; height: 100%; width: 100%;"><div class="layout-representative-div" style="min-width: 16px; max-width: 24px; height: 100%; background-color: var(--surface-inverted-100, rgba(128, 128, 128, 0.10)); border-radius: 2px; pointer-events: none; user-select: none; -webkit-user-select: none;"></div><button class="btn-layout-spacing active" data-spacing="left"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="none"><path d="M4.25 3.5C4.94036 3.5 5.5 4.05964 5.5 4.75V11.25C5.5 11.9404 4.94036 12.5 4.25 12.5H4C3.72386 12.5 3.5 12.2761 3.5 12C3.5 11.7239 3.72386 11.5 4 11.5H4.25C4.38807 11.5 4.5 11.3881 4.5 11.25V4.75C4.5 4.61193 4.38807 4.5 4.25 4.5H4C3.72386 4.5 3.5 4.27614 3.5 4C3.5 3.72386 3.72386 3.5 4 3.5H4.25ZM12 3.5C12.2761 3.5 12.4999 3.72397 12.5 4C12.4999 4.27609 12.2761 4.5 12 4.5H11.75C11.612 4.5 11.5001 4.61204 11.5 4.75V11.25C11.5 11.3881 11.6119 11.5 11.75 11.5H12C12.2761 11.5 12.4999 11.724 12.5 12C12.5 12.2761 12.2761 12.5 12 12.5H11.75C11.0596 12.5 10.5 11.9404 10.5 11.25V4.75C10.5001 4.05976 11.0597 3.5 11.75 3.5H12ZM8 5.5C8.27614 5.5 8.5 5.72386 8.5 6V10C8.5 10.2761 8.27614 10.5 8 10.5C7.72386 10.5 7.5 10.2761 7.5 10V6C7.5 5.72386 7.72386 5.5 8 5.5Z" fill="currentColor"/></svg></button> <button class="btn-layout-nested active" data-nested="control"><div class="nested-icon-wrapper"><svg width="24" height="25" viewBox="0 0 24 25" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M11.7773 18.4178C11.5833 18.5459 11.3193 18.5242 11.1484 18.3533L9.14844 16.3533C8.95318 16.158 8.95318 15.8415 9.14844 15.6463C9.3437 15.451 9.66021 15.451 9.85547 15.6463L11.002 16.7928L11.002 9.49979L7.50195 9.49979C6.67353 9.49979 6.00195 8.82822 6.00195 7.99979C6.00195 7.17136 6.67353 6.49979 7.50195 6.49979L15.502 6.49979C16.3304 6.49979 17.002 7.17137 17.002 7.99979C17.002 8.82822 16.3304 9.49979 15.502 9.49979L12.002 9.49979L12.002 16.7928L13.1484 15.6463C13.3437 15.451 13.6602 15.451 13.8555 15.6463C14.0507 15.8415 14.0507 16.158 13.8555 16.3533L11.8555 18.3533L11.7773 18.4178ZM15.502 8.49979C15.7781 8.49979 16.002 8.27594 16.002 7.99979C16.002 7.72365 15.7781 7.49979 15.502 7.49979L7.50195 7.49979C7.22581 7.49979 7.00195 7.72365 7.00195 7.99979C7.00195 8.27593 7.22581 8.49979 7.50195 8.49979L15.502 8.49979ZM13.502 13.4998C13.2258 13.4998 13.002 13.2759 13.002 12.9998C13.002 12.7236 13.2258 12.4998 13.502 12.4998L15.502 12.4998C15.7781 12.4998 16.002 12.2759 16.002 11.9998C16.002 11.7237 15.7781 11.4998 15.502 11.4998L13.502 11.4998C13.2258 11.4998 13.002 11.2759 13.002 10.9998C13.002 10.7236 13.2258 10.4998 13.502 10.4998L15.502 10.4998C16.3304 10.4998 17.002 11.1714 17.002 11.9998C17.002 12.8282 16.3304 13.4998 15.502 13.4998L13.502 13.4998ZM7.50195 13.4998C6.67353 13.4998 6.00195 12.8282 6.00195 11.9998C6.00195 11.1714 6.67353 10.4998 7.50195 10.4998L9.50195 10.4998C9.7781 10.4998 10.002 10.7236 10.002 10.9998C10.002 11.2759 9.7781 11.4998 9.50195 11.4998L7.50195 11.4998C7.22581 11.4998 7.00195 11.7236 7.00195 11.9998C7.00195 12.2759 7.22581 12.4998 7.50195 12.4998L9.50195 12.4998C9.7781 12.4998 10.002 12.7236 10.002 12.9998C10.002 13.2759 9.7781 13.4998 9.50195 13.4998L7.50195 13.4998Z" fill="currentColor"/></svg></div><div class="nested-text">Apply to Nested</div></button> <button class="btn-layout-spacing active" data-spacing="right"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="none"><path d="M4.25 3.5C4.94036 3.5 5.5 4.05964 5.5 4.75V11.25C5.5 11.9404 4.94036 12.5 4.25 12.5H4C3.72386 12.5 3.5 12.2761 3.5 12C3.5 11.7239 3.72386 11.5 4 11.5H4.25C4.38807 11.5 4.5 11.3881 4.5 11.25V4.75C4.5 4.61193 4.38807 4.5 4.25 4.5H4C3.72386 4.5 3.5 4.27614 3.5 4C3.5 3.72386 3.72386 3.5 4 3.5H4.25ZM12 3.5C12.2761 3.5 12.4999 3.72397 12.5 4C12.4999 4.27609 12.2761 4.5 12 4.5H11.75C11.612 4.5 11.5001 4.61204 11.5 4.75V11.25C11.5 11.3881 11.6119 11.5 11.75 11.5H12C12.2761 11.5 12.4999 11.724 12.5 12C12.5 12.2761 12.2761 12.5 12 12.5H11.75C11.0596 12.5 10.5 11.9404 10.5 11.25V4.75C10.5001 4.05976 11.0597 3.5 11.75 3.5H12ZM8 5.5C8.27614 5.5 8.5 5.72386 8.5 6V10C8.5 10.2761 8.27614 10.5 8 10.5C7.72386 10.5 7.5 10.2761 7.5 10V6C7.5 5.72386 7.72386 5.5 8 5.5Z" fill="currentColor"/></svg></button><div class="layout-representative-div" style="min-width: 16px; max-width: 24px; height: 100%; background-color: var(--surface-inverted-100, rgba(128, 128, 128, 0.10)); border-radius: 2px; pointer-events: none; user-select: none; -webkit-user-select: none;"></div></div></div></div></div><div class="action-buttons-row" style="padding: 4px;"><button class="btn-secondary" id="clearVariablesBtn">Clear variables</button> <button class="btn-primary" id="applyVariablesBtn">Apply Variables</button></div></div></div><div class="section-nested" style="gap: 8px;"><div class="section-header"><div class="icon-container flipped"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="none"><path d="M0.00390625 12C0.00390625 14.2091 1.79477 16 4.00391 16H12.0039C14.213 16 16.0039 14.2091 16.0039 12V4C16.0039 1.79086 14.213 0 12.0039 0H4.00391C1.79477 0 0.00390625 1.79086 0.00390625 4V12Z" fill="var(--surface-neutral-120, rgba(255, 255, 255, 0.12))"/><path fill-rule="evenodd" clip-rule="evenodd" d="M7.76819 13.0619C7.93419 13.1715 8.15998 13.1529 8.30612 13.0068L10.0168 11.2961C10.1838 11.1291 10.1838 10.8583 10.0168 10.6913C9.84981 10.5243 9.57908 10.5243 9.41206 10.6913L8.43142 11.672V5.43393H11.4251C12.1337 5.43393 12.7082 4.8595 12.7082 4.15091C12.7082 3.44231 12.1337 2.86788 11.4251 2.86788H4.58234C3.87375 2.86788 3.29932 3.44231 3.29932 4.15091C3.29932 4.8595 3.87375 5.43393 4.58234 5.43393H7.57607V11.672L6.59542 10.6913C6.42841 10.5243 6.15768 10.5243 5.99066 10.6913C5.82365 10.8583 5.82365 11.1291 5.99066 11.2961L7.70136 13.0068L7.76819 13.0619ZM4.58234 4.57858C4.34614 4.57858 4.15467 4.38711 4.15467 4.15091C4.15467 3.91471 4.34614 3.72323 4.58234 3.72323H11.4251C11.6613 3.72323 11.8528 3.91471 11.8528 4.15091C11.8528 4.38711 11.6613 4.57858 11.4251 4.57858H4.58234Z" fill="var(--icon-neutral-inactive, rgba(255, 255, 255, 0.70))"/><path d="M6.29304 8.85533C6.52924 8.85533 6.72072 8.66386 6.72072 8.42766C6.72072 8.19146 6.52924 7.99998 6.29304 7.99998H4.58234C4.34614 7.99998 4.15467 7.80851 4.15467 7.57231C4.15467 7.33611 4.34614 7.14463 4.58234 7.14463H6.29304C6.52924 7.14463 6.72072 6.95316 6.72072 6.71696C6.72072 6.48076 6.52924 6.28928 6.29304 6.28928H4.58234C3.87375 6.28928 3.29932 6.86371 3.29932 7.57231C3.29932 8.2809 3.87375 8.85533 4.58234 8.85533H6.29304Z" fill="var(--icon-neutral-inactive, rgba(255, 255, 255, 0.70))"/><path d="M11.4251 8.85533C12.1337 8.85533 12.7082 8.2809 12.7082 7.57231C12.7082 6.86371 12.1337 6.28928 11.4251 6.28928H9.71444C9.47825 6.28928 9.28677 6.48076 9.28677 6.71696C9.28677 6.95316 9.47825 7.14463 9.71444 7.14463H11.4251C11.6613 7.14463 11.8528 7.33611 11.8528 7.57231C11.8528 7.80851 11.6613 7.99998 11.4251 7.99998H9.71444C9.47825 7.99998 9.28677 8.19146 9.28677 8.42766C9.28677 8.66386 9.47825 8.85533 9.71444 8.85533H11.4251Z" fill="var(--icon-neutral-inactive, rgba(255, 255, 255, 0.70))"/></svg></div><span class="section-label">Nested</span></div><div class="section-container" id="devNestedContainer"></div></div></div><div id="stickyFooter" class="sticky-footer" style="display: none;"><div class="sticky-footer-content"><label class="toggle-container ui-toggle-container" title="Toggle between current and new UI"><input type="checkbox" id="uiToggle"> <span class="toggle-slider"></span> <span class="toggle-label">Development UI</span></label> <button class="test-modal-button" id="testModalButton" title="Test modals">Test Modal</button></div></div><script>const helpButton = document.getElementById('helpButton');
    const helpContent = document.getElementById('helpContent');
    const applyButton = document.getElementById('applyButton');
    const clearButton = document.getElementById('clearButton');
    const message = document.getElementById('message');
    const loading = document.getElementById('loading');
    const uiToggle = document.getElementById('uiToggle');
    const currentUi = document.getElementById('currentUi');
    const newUi = document.getElementById('newUi');
    const loadingText = document.getElementById('loadingText');
    
    // Rename panel elements
    const renameAccordionHeader = document.getElementById('renameAccordionHeader');
    const renameAccordionContent = document.getElementById('renameAccordionContent');
    const accordionIcon = renameAccordionHeader.querySelector('.accordion-icon');
    const parentLayerName = document.getElementById('parentLayerName');
    const currentLayerName = document.getElementById('currentLayerName');
    const previewNameChange = document.getElementById('previewNameChange');
    const renameButtons = document.querySelectorAll('.rename-button');
    const autoAdjustButton = document.getElementById('autoAdjustButton');
    const applyAfterRename = document.getElementById('applyAfterRename');
    const renameNested = document.getElementById('renameNested');
    
    // Selected node information
    let selectedNode = null;
    let currentDirectionalExtension = null; // Track current directional extension (row./column.)
    let parentNode = null;
    let currentVariableBindings = null; // Store current variable bindings to check if variables exist
    
    // Spacing Control Variables (shared scope for button handler)
    let currentSizeIndex = 0; // Default to 'none' (index 0, displays as "0")
    const sizeClasses = ['none', 'XS', 'S', 'M', 'D', 'L', 'XL'];
    
    // Mapping between input values and variable modes for A3 â†”ï¸ Spacing collection
    const SPACING_INPUT_TO_MODE = {
      '0': 'none',
      'XS': 'x-small',
      'S': 'small',
      'M': 'medium',
      'D': 'standard',
      'L': 'large',
      'XL': 'x-large'
    };
    
    // Reverse mapping: variable mode to input value
    const SPACING_MODE_TO_INPUT = {
      'none': '0',
      'x-small': 'XS',
      'small': 'S',
      'medium': 'M',
      'standard': 'D',
      'large': 'L',
      'x-large': 'XL'
    };

    /**************************************
     * COLOR TOKEN SYSTEM - Primitive â†’ Semantic
     * Based on Figma export: color-tokens-export.json
     **************************************/
    
    // Primitive color scales - base colors used to build semantic tokens
    // Unified Design Tokens System - Atomic Design Architecture
    const DESIGN_TOKENS = {
      primitive: {
        // Color primitives (existing)
        color: {
        // Neutral scale base (black/white)
        neutral: {
          base: { light: '#000000', dark: '#ffffff' }
        },
        // Brand scale base (blue)
        brand: {
          base: { light: '#327aff', dark: '#78acfa' }
        },
        // Brand button colors (different from surface-brand)
        brandButton: {
          base: { light: '#0d99ff', dark: '#0c8ce9' },
          pressed: { light: '#007be5', dark: '#0a6dc2' }
        },
        // Inverted scale base (gray/black)
        inverted: {
          base: { light: '#808080', dark: '#000000' }
        },
        // White (used for text/buttons)
        white: '#ffffff',
        // Badge hierarchy primitives
        purpleHero: {
          text: { light: '#831568', dark: '#fce8f6' },
          stroke: '#d01b9c',
          fill: { light: 'rgba(218, 82, 184, 0.2)', dark: 'rgba(131, 21, 104, 0.3)' },
          hover: { light: 'rgba(208, 27, 156, 0.3)', dark: 'rgba(131, 21, 104, 0.4)' },
          pressed: { light: 'rgba(208, 27, 156, 0.5)', dark: 'rgba(131, 21, 104, 0.4)' }
        },
        purpleParent: {
          text: { light: '#6818b1', dark: '#f7f2fc' },
          stroke: '#7a2ed6',
          fill: { light: 'rgba(104, 24, 177, 0.2)', dark: 'rgba(104, 24, 177, 0.3)' },
          hover: { light: 'rgba(122, 46, 214, 0.25)', dark: 'rgba(122, 46, 214, 0.4)' },
          pressed: { light: 'rgba(122, 46, 214, 0.5)', dark: 'rgba(122, 46, 214, 0.4)' }
        },
        blueChild: {
          text: { light: '#075292', dark: '#eaf4fc' },
          stroke: '#0a6dc2',
          fill: { light: 'rgba(13, 67, 214, 0.2)', dark: 'rgba(13, 67, 214, 0.3)' },
          hover: { light: 'rgba(10, 109, 194, 0.3)', dark: 'rgba(10, 109, 194, 0.4)' },
          pressed: { light: 'rgba(10, 109, 194, 0.6)', dark: 'rgba(10, 109, 194, 0.4)' }
        },
        tealSubchild: {
          text: { light: '#013a6b', dark: '#ecf4fc' },
          stroke: { light: '#0f92b2', dark: '#087691' },
          fill: { light: 'rgba(1, 58, 107, 0.2)', dark: 'rgba(1, 58, 107, 0.3)' },
          hover: { light: 'rgba(15, 146, 178, 0.3)', dark: 'rgba(15, 146, 178, 0.4)' },
          pressed: { light: 'rgba(15, 146, 178, 0.6)', dark: 'rgba(15, 146, 178, 0.4)' }
          }
        },
        // Spacing primitives (4px base unit)
        spacing: {
          0: '0px',
          2: '2px',
          4: '4px',
          6: '6px',
          8: '8px',
          10: '10px',
          12: '12px',
          16: '16px',
          20: '20px',
          24: '24px',
          32: '32px',
          40: '40px',
          48: '48px',
          64: '64px'
        },
        // Typography primitives
        typography: {
          fontSize: {
            xs: '10px',
            sm: '11px',
            base: '12px',
            md: '13px',
            lg: '14px',
            xl: '16px',
            '2xl': '18px'
          },
          fontWeight: {
            normal: '400',
            medium: '450',
            semibold: '500',
            bold: '600'
          },
          lineHeight: {
            tight: '1.2',
            normal: '1.4',
            relaxed: '1.5',
            loose: '1.6'
          },
          letterSpacing: {
            none: '0',
            tight: '0.055px'
          }
        },
        // Border radius primitives
        radius: {
          none: '0px',
          xs: '2px',
          sm: '4px',
          md: '6px',
          lg: '8px',
          xl: '12px',
          '2xl': '18px',
          full: '50%'
        },
        // Transition primitives
        transition: {
          duration: {
            fast: '0.15s',
            base: '0.2s',
            slow: '0.3s'
          },
          easing: {
            ease: 'ease',
            'ease-in-out': 'ease-in-out',
            'ease-out': 'ease-out'
          }
        }
      },
      // Semantic tokens - reference primitives via CSS custom properties
      semantic: {
        light: {
          text: {
            primary: '#2c2c2c',
            secondary: 'rgba(0, 0, 0, 0.6)'
          },
          surface: {
            bg: '#ffffff',
            neutral: {
              900: '#000000',
              800: 'rgba(0, 0, 0, 0.8)',
              700: 'rgba(0, 0, 0, 0.7)',
              600: 'rgba(0, 0, 0, 0.6)',
              500: 'rgba(0, 0, 0, 0.5)',
              400: 'rgba(0, 0, 0, 0.4)',
              300: 'rgba(0, 0, 0, 0.3)',
              200: 'rgba(0, 0, 0, 0.2)',
              150: 'rgba(0, 0, 0, 0.15)',
              120: 'rgba(0, 0, 0, 0.12)',
              100: 'rgba(0, 0, 0, 0.1)',
              75: 'rgba(0, 0, 0, 0.07)',
              50: 'rgba(0, 0, 0, 0.05)',
              20: 'rgba(0, 0, 0, 0.03)'
            },
            brand: {
              900: '#327aff',
              800: 'rgba(50, 122, 255, 0.9)',
              700: 'rgba(50, 122, 255, 0.8)',
              600: 'rgba(50, 122, 255, 0.7)',
              500: 'rgba(50, 122, 255, 0.6)',
              400: 'rgba(50, 122, 255, 0.5)',
              300: 'rgba(50, 122, 255, 0.4)',
              200: 'rgba(50, 122, 255, 0.2)',
              150: 'rgba(50, 122, 255, 0.15)',
              120: 'rgba(50, 122, 255, 0.12)',
              100: 'rgba(50, 122, 255, 0.1)',
              75: 'rgba(50, 122, 255, 0.07)',
              50: 'rgba(50, 122, 255, 0.05)',
              20: 'rgba(50, 122, 255, 0.03)'
            },
            inverted: {
              900: '#808080',
              800: 'rgba(128, 128, 128, 0.8)',
              700: 'rgba(128, 128, 128, 0.7)',
              600: 'rgba(128, 128, 128, 0.6)',
              500: 'rgba(128, 128, 128, 0.5)',
              400: 'rgba(128, 128, 128, 0.4)',
              300: 'rgba(128, 128, 128, 0.3)',
              200: 'rgba(128, 128, 128, 0.2)',
              150: 'rgba(128, 128, 128, 0.15)',
              120: 'rgba(128, 128, 128, 0.12)',
              100: 'rgba(128, 128, 128, 0.1)',
              75: 'rgba(128, 128, 128, 0.07)',
              50: 'rgba(128, 128, 128, 0.05)',
              20: 'rgba(128, 128, 128, 0.03)'
            }
          },
          badge: {
            hero: {
              text: '#831568',
              icon: '#831568',
              fill: 'rgba(218, 82, 184, 0.2)',
              stroke: '#d01b9c',
              buttonHover: 'rgba(208, 27, 156, 0.3)',
              buttonPressed: 'rgba(208, 27, 156, 0.5)'
            },
            parent: {
              text: '#6818b1',
              icon: '#6818b1',
              fill: 'rgba(104, 24, 177, 0.2)',
              stroke: '#7a2ed6',
              buttonHover: 'rgba(122, 46, 214, 0.25)',
              buttonPressed: 'rgba(122, 46, 214, 0.5)'
            },
            child: {
              text: '#075292',
              icon: '#075292',
              fill: 'rgba(13, 67, 214, 0.2)',
              stroke: '#0a6dc2',
              buttonHover: 'rgba(10, 109, 194, 0.3)',
              buttonPressed: 'rgba(10, 109, 194, 0.6)'
            },
            subChild: {
              text: '#013a6b',
              icon: '#013a6b',
              fill: 'rgba(1, 58, 107, 0.2)',
              stroke: '#0f92b2',
              buttonHover: 'rgba(15, 146, 178, 0.3)',
              buttonPressed: 'rgba(15, 146, 178, 0.6)'
            },
            adjust: {
              text: '#2c2c2c', // references text-primary
              icon: '#000000', // references surface-neutral-900
              fill: 'rgba(0, 0, 0, 0)',
              stroke: 'rgba(0, 0, 0, 0.3)', // references surface-neutral-300
              buttonHover: 'rgba(0, 0, 0, 0.1)', // references surface-neutral-100
              buttonPressed: 'rgba(0, 0, 0, 0.2)' // references surface-neutral-200
            }
          },
          icon: {
            neutral: {
              active: '#2c2c2c',
              inactive: 'rgba(0, 0, 0, 0.5)' // references surface-neutral-500
            },
            brand: {
              active: '#327aff', // references surface-brand-900
              inactive: 'rgba(50, 122, 255, 0.7)' // references surface-brand-600
            }
          },
          button: {
            brand: {
              text: '#ffffff',
              fillDefault: '#0d99ff',
              fillPressed: '#007be5',
              fillDisabled: 'rgba(13, 153, 255, 0.5)'
            },
            secondaryNeutral: {
              textDefault: '#2c2c2c', // references text-primary
              fillDefault: 'rgba(0, 0, 0, 0)',
              fillPressed: 'rgba(0, 0, 0, 0.07)', // references surface-neutral-75
              fillDisabled: 'rgba(0, 0, 0, 0)',
              strokeDefault: 'rgba(0, 0, 0, 0.1)', // references surface-neutral-100
              strokePressed: 'rgba(0, 0, 0, 0)',
              strokeDisabled: 'rgba(0, 0, 0, 0)',
              disabled: 'rgba(0, 0, 0, 0.5)' // references surface-neutral-500
            },
            secondaryBrand: {
              textDefault: '#2c2c2c', // references text-primary
              fillDefault: 'rgba(50, 122, 255, 0)',
              fillPressed: 'rgba(50, 122, 255, 0.07)', // references surface-brand-75
              fillDisabled: 'rgba(50, 122, 255, 0)',
              strokeDefault: 'rgba(50, 122, 255, 0.5)', // references surface-brand-400
              strokePressed: 'rgba(50, 122, 255, 0)',
              strokeDisabled: 'rgba(50, 122, 255, 0)',
              disabled: 'rgba(0, 0, 0, 0.5)' // references surface-neutral-500
            },
            ghostNeutral: {
              textDefault: '#2c2c2c', // references text-primary
              textPressed: '#2c2c2c', // references text-primary
              textDisabled: 'rgba(0, 0, 0, 0.5)', // references surface-neutral-500
              iconDefault: '#2c2c2c', // references icon-neutral-active
              iconHover: 'rgba(0, 0, 0, 0.7)', // references surface-neutral-700
              iconPressed: '#2c2c2c', // references icon-neutral-active
              iconDisabled: 'rgba(0, 0, 0, 0.5)', // references surface-neutral-500
              fillDefault: 'rgba(0, 0, 0, 0)',
              fillHover: 'rgba(0, 0, 0, 0.2)', // references surface-neutral-200
              fillPressed: 'rgba(0, 0, 0, 0.1)', // references surface-neutral-100
              fillDisabled: 'rgba(0, 0, 0, 0)'
            }
          }
        },
        dark: {
          text: {
            primary: '#ffffff',
            secondary: 'rgba(255, 255, 255, 0.6)'
          },
          surface: {
            bg: '#2c2c2c',
            neutral: {
              900: '#ffffff',
              800: 'rgba(255, 255, 255, 0.8)',
              700: 'rgba(255, 255, 255, 0.7)',
              600: 'rgba(255, 255, 255, 0.6)',
              500: 'rgba(255, 255, 255, 0.5)',
              400: 'rgba(255, 255, 255, 0.4)',
              300: 'rgba(255, 255, 255, 0.3)',
              200: 'rgba(255, 255, 255, 0.2)',
              150: 'rgba(255, 255, 255, 0.15)',
              120: 'rgba(255, 255, 255, 0.12)',
              100: 'rgba(255, 255, 255, 0.1)',
              75: 'rgba(255, 255, 255, 0.07)',
              50: 'rgba(255, 255, 255, 0.05)',
              20: 'rgba(255, 255, 255, 0.03)'
            },
            brand: {
              900: '#78acfa',
              800: 'rgba(120, 172, 250, 0.8)',
              700: 'rgba(120, 172, 250, 0.7)',
              600: 'rgba(120, 172, 250, 0.6)',
              500: 'rgba(120, 172, 250, 0.5)',
              400: 'rgba(120, 172, 250, 0.4)',
              300: 'rgba(120, 172, 250, 0.3)',
              200: 'rgba(120, 172, 250, 0.2)',
              150: 'rgba(120, 172, 250, 0.15)',
              120: 'rgba(120, 172, 250, 0.12)',
              100: 'rgba(120, 172, 250, 0.1)',
              75: 'rgba(120, 172, 250, 0.07)',
              50: 'rgba(120, 172, 250, 0.05)',
              20: 'rgba(120, 172, 250, 0.03)'
            },
            inverted: {
              900: '#000000',
              800: 'rgba(0, 0, 0, 0.8)',
              700: 'rgba(0, 0, 0, 0.7)',
              600: 'rgba(0, 0, 0, 0.6)',
              500: 'rgba(0, 0, 0, 0.5)',
              400: 'rgba(0, 0, 0, 0.4)',
              300: 'rgba(0, 0, 0, 0.3)',
              200: 'rgba(0, 0, 0, 0.2)',
              150: 'rgba(0, 0, 0, 0.15)',
              120: 'rgba(0, 0, 0, 0.12)',
              100: 'rgba(0, 0, 0, 0.1)',
              75: 'rgba(0, 0, 0, 0.07)',
              50: 'rgba(0, 0, 0, 0.05)',
              20: 'rgba(0, 0, 0, 0.03)'
            }
          },
          badge: {
            hero: {
              text: '#fce8f6',
              icon: '#fce8f6',
              fill: 'rgba(131, 21, 104, 0.3)',
              stroke: '#d01b9c',
              buttonHover: 'rgba(131, 21, 104, 0.4)',
              buttonPressed: 'rgba(131, 21, 104, 0.4)'
            },
            parent: {
              text: '#f7f2fc',
              icon: '#f7f2fc',
              fill: 'rgba(104, 24, 177, 0.3)',
              stroke: '#7a2ed6',
              buttonHover: 'rgba(122, 46, 214, 0.4)',
              buttonPressed: 'rgba(122, 46, 214, 0.4)'
            },
            child: {
              text: '#eaf4fc',
              icon: '#eaf4fc',
              fill: 'rgba(13, 67, 214, 0.3)',
              stroke: '#0a6dc2',
              buttonHover: 'rgba(10, 109, 194, 0.4)',
              buttonPressed: 'rgba(10, 109, 194, 0.4)'
            },
            subChild: {
              text: '#ecf4fc',
              icon: '#ecf4fc',
              fill: 'rgba(1, 58, 107, 0.3)',
              stroke: '#087691',
              buttonHover: 'rgba(15, 146, 178, 0.4)',
              buttonPressed: 'rgba(15, 146, 178, 0.4)'
            },
            adjust: {
              text: '#ffffff', // references text-primary
              icon: '#ffffff', // references surface-neutral-900
              fill: 'rgba(255, 255, 255, 0)',
              stroke: 'rgba(255, 255, 255, 0.2)', // references surface-neutral-200
              buttonHover: 'rgba(255, 255, 255, 0.15)', // references surface-neutral-150
              buttonPressed: 'rgba(255, 255, 255, 0.3)' // references surface-neutral-300
            }
          },
          icon: {
            neutral: {
              active: '#ffffff',
              inactive: 'rgba(255, 255, 255, 0.7)' // references surface-neutral-700
            },
            brand: {
              active: '#78acfa', // references surface-brand-900
              inactive: 'rgba(120, 172, 250, 0.6)' // references surface-brand-600
            }
          },
          button: {
            brand: {
              text: '#ffffff',
              fillDefault: '#0c8ce9',
              fillPressed: '#0a6dc2',
              fillDisabled: 'rgba(12, 140, 233, 0.5)'
            },
            secondaryNeutral: {
              textDefault: '#ffffff', // references text-primary
              fillDefault: 'rgba(255, 255, 255, 0)',
              fillPressed: 'rgba(255, 255, 255, 0.15)', // references surface-neutral-150
              fillDisabled: 'rgba(255, 255, 255, 0)',
              strokeDefault: 'rgba(255, 255, 255, 0.4)', // references surface-neutral-400
              strokePressed: 'rgba(255, 255, 255, 0)',
              strokeDisabled: 'rgba(255, 255, 255, 0)',
              disabled: 'rgba(255, 255, 255, 0.5)' // references surface-neutral-500
            },
            secondaryBrand: {
              textDefault: '#ffffff', // references text-primary
              fillDefault: 'rgba(120, 172, 250, 0)',
              fillPressed: 'rgba(120, 172, 250, 0.2)', // references surface-brand-200
              fillDisabled: 'rgba(120, 172, 250, 0)',
              strokeDefault: 'rgba(120, 172, 250, 0.4)', // references surface-brand-400
              strokePressed: 'rgba(120, 172, 250, 0)',
              strokeDisabled: 'rgba(120, 172, 250, 0)',
              disabled: 'rgba(255, 255, 255, 0.5)' // references surface-neutral-500
            },
            ghostNeutral: {
              textDefault: '#ffffff', // references text-primary
              textPressed: '#ffffff', // references text-primary
              textDisabled: 'rgba(255, 255, 255, 0.5)', // references surface-neutral-500
              iconDefault: '#ffffff', // references icon-neutral-active
              iconHover: 'rgba(255, 255, 255, 0.7)', // references surface-neutral-700
              iconPressed: '#ffffff', // references icon-neutral-active
              iconDisabled: 'rgba(255, 255, 255, 0.5)', // references surface-neutral-500
              fillDefault: 'rgba(255, 255, 255, 0)',
              fillHover: 'rgba(255, 255, 255, 0.2)', // references surface-neutral-200
              fillPressed: 'rgba(255, 255, 255, 0.1)', // references surface-neutral-100
              fillDisabled: 'rgba(255, 255, 255, 0)'
            }
          },
          // Spacing semantic tokens
          spacing: {
            xs: '2px',      // tight spacing
            sm: '4px',      // small spacing
            md: '8px',      // medium spacing (default)
            lg: '12px',     // large spacing
            xl: '16px',     // extra large spacing
            '2xl': '20px',  // 2x extra large
            '3xl': '24px',  // 3x extra large
            '4xl': '32px'   // 4x extra large
          },
          // Typography semantic tokens
          typography: {
            bodyXs: {
              size: '10px',
              weight: '400',
              lineHeight: '1.4',
              letterSpacing: '0'
            },
            bodySm: {
              size: '12px',
              weight: '400',
              lineHeight: '1.4',
              letterSpacing: '0'
            },
            bodyMd: {
              size: '14px',
              weight: '400',
              lineHeight: '1.5',
              letterSpacing: '0'
            },
            bodyLg: {
              size: '16px',
              weight: '400',
              lineHeight: '1.5',
              letterSpacing: '0'
            },
            labelSm: {
              size: '11px',
              weight: '450',
              lineHeight: '1.4',
              letterSpacing: '0.055px'
            },
            labelMd: {
              size: '13px',
              weight: '500',
              lineHeight: '1.4',
              letterSpacing: '0'
            },
            labelLg: {
              size: '14px',
              weight: '500',
              lineHeight: '1.4',
              letterSpacing: '0'
            },
            headingSm: {
              size: '14px',
              weight: '600',
              lineHeight: '1.4',
              letterSpacing: '0'
            },
            headingMd: {
              size: '18px',
              weight: '600',
              lineHeight: '1.4',
              letterSpacing: '0'
            }
          },
          // Border radius semantic tokens
          radius: {
            none: '0px',
            xs: '2px',      // small elements
            sm: '4px',      // small components
            md: '6px',      // default components
            lg: '8px',      // large components
            xl: '12px',     // modals/cards
            full: '50%'     // circular elements
          },
          // Transition semantic tokens
          transition: {
            fast: '0.15s ease',
            base: '0.2s ease',      // default
            slow: '0.3s ease'
          }
        },
        dark: {
          // Dark mode semantic tokens (same structure as light, but only colors differ)
          text: {
            primary: '#ffffff',
            secondary: 'rgba(255, 255, 255, 0.6)'
          },
          surface: {
            bg: '#2c2c2c',
            neutral: {
              900: '#ffffff',
              800: 'rgba(255, 255, 255, 0.8)',
              700: 'rgba(255, 255, 255, 0.7)',
              600: 'rgba(255, 255, 255, 0.6)',
              500: 'rgba(255, 255, 255, 0.5)',
              400: 'rgba(255, 255, 255, 0.4)',
              300: 'rgba(255, 255, 255, 0.3)',
              200: 'rgba(255, 255, 255, 0.2)',
              150: 'rgba(255, 255, 255, 0.15)',
              120: 'rgba(255, 255, 255, 0.12)',
              100: 'rgba(255, 255, 255, 0.1)',
              75: 'rgba(255, 255, 255, 0.07)',
              50: 'rgba(255, 255, 255, 0.05)',
              20: 'rgba(255, 255, 255, 0.03)'
            },
            brand: {
              900: '#78acfa',
              800: 'rgba(120, 172, 250, 0.8)',
              700: 'rgba(120, 172, 250, 0.7)',
              600: 'rgba(120, 172, 250, 0.6)',
              500: 'rgba(120, 172, 250, 0.5)',
              400: 'rgba(120, 172, 250, 0.4)',
              300: 'rgba(120, 172, 250, 0.3)',
              200: 'rgba(120, 172, 250, 0.2)',
              150: 'rgba(120, 172, 250, 0.15)',
              120: 'rgba(120, 172, 250, 0.12)',
              100: 'rgba(120, 172, 250, 0.1)',
              75: 'rgba(120, 172, 250, 0.07)',
              50: 'rgba(120, 172, 250, 0.05)',
              20: 'rgba(120, 172, 250, 0.03)'
            },
            inverted: {
              900: '#000000',
              800: 'rgba(0, 0, 0, 0.8)',
              700: 'rgba(0, 0, 0, 0.7)',
              600: 'rgba(0, 0, 0, 0.6)',
              500: 'rgba(0, 0, 0, 0.5)',
              400: 'rgba(0, 0, 0, 0.4)',
              300: 'rgba(0, 0, 0, 0.3)',
              200: 'rgba(0, 0, 0, 0.2)',
              150: 'rgba(0, 0, 0, 0.15)',
              120: 'rgba(0, 0, 0, 0.12)',
              100: 'rgba(0, 0, 0, 0.1)',
              75: 'rgba(0, 0, 0, 0.07)',
              50: 'rgba(0, 0, 0, 0.05)',
              20: 'rgba(0, 0, 0, 0.03)'
            }
          },
          badge: {
            hero: {
              text: '#fce8f6',
              icon: '#fce8f6',
              fill: 'rgba(131, 21, 104, 0.3)',
              stroke: '#d01b9c',
              buttonHover: 'rgba(131, 21, 104, 0.4)',
              buttonPressed: 'rgba(131, 21, 104, 0.4)'
            },
            parent: {
              text: '#f7f2fc',
              icon: '#f7f2fc',
              fill: 'rgba(104, 24, 177, 0.3)',
              stroke: '#7a2ed6',
              buttonHover: 'rgba(122, 46, 214, 0.4)',
              buttonPressed: 'rgba(122, 46, 214, 0.4)'
            },
            child: {
              text: '#eaf4fc',
              icon: '#eaf4fc',
              fill: 'rgba(13, 67, 214, 0.3)',
              stroke: '#0a6dc2',
              buttonHover: 'rgba(10, 109, 194, 0.4)',
              buttonPressed: 'rgba(10, 109, 194, 0.4)'
            },
            subChild: {
              text: '#ecf4fc',
              icon: '#ecf4fc',
              fill: 'rgba(1, 58, 107, 0.3)',
              stroke: '#087691',
              buttonHover: 'rgba(15, 146, 178, 0.4)',
              buttonPressed: 'rgba(15, 146, 178, 0.4)'
            },
            adjust: {
              text: '#ffffff', // references text-primary
              icon: '#ffffff', // references surface-neutral-900
              fill: 'rgba(255, 255, 255, 0)',
              stroke: 'rgba(255, 255, 255, 0.2)', // references surface-neutral-200
              buttonHover: 'rgba(255, 255, 255, 0.15)', // references surface-neutral-150
              buttonPressed: 'rgba(255, 255, 255, 0.3)' // references surface-neutral-300
            }
          },
          icon: {
            neutral: {
              active: '#ffffff',
              inactive: 'rgba(255, 255, 255, 0.7)' // references surface-neutral-700
            },
            brand: {
              active: '#78acfa', // references surface-brand-900
              inactive: 'rgba(120, 172, 250, 0.6)' // references surface-brand-600
            }
          },
          button: {
            brand: {
              text: '#ffffff',
              fillDefault: '#0c8ce9',
              fillPressed: '#0a6dc2',
              fillDisabled: 'rgba(12, 140, 233, 0.5)'
            },
            secondaryNeutral: {
              textDefault: '#ffffff', // references text-primary
              fillDefault: 'rgba(255, 255, 255, 0)',
              fillPressed: 'rgba(255, 255, 255, 0.15)', // references surface-neutral-150
              fillDisabled: 'rgba(255, 255, 255, 0)',
              strokeDefault: 'rgba(255, 255, 255, 0.4)', // references surface-neutral-400
              strokePressed: 'rgba(255, 255, 255, 0)',
              strokeDisabled: 'rgba(255, 255, 255, 0)',
              disabled: 'rgba(255, 255, 255, 0.5)' // references surface-neutral-500
            },
            secondaryBrand: {
              textDefault: '#ffffff', // references text-primary
              fillDefault: 'rgba(120, 172, 250, 0)',
              fillPressed: 'rgba(120, 172, 250, 0.2)', // references surface-brand-200
              fillDisabled: 'rgba(120, 172, 250, 0)',
              strokeDefault: 'rgba(120, 172, 250, 0.4)', // references surface-brand-400
              strokePressed: 'rgba(120, 172, 250, 0)',
              strokeDisabled: 'rgba(120, 172, 250, 0)',
              disabled: 'rgba(255, 255, 255, 0.5)' // references surface-neutral-500
            },
            ghostNeutral: {
              textDefault: '#ffffff', // references text-primary
              textPressed: '#ffffff', // references text-primary
              textDisabled: 'rgba(255, 255, 255, 0.5)', // references surface-neutral-500
              iconDefault: '#ffffff', // references icon-neutral-active
              iconHover: 'rgba(255, 255, 255, 0.7)', // references surface-neutral-700
              iconPressed: '#ffffff', // references icon-neutral-active
              iconDisabled: 'rgba(255, 255, 255, 0.5)', // references surface-neutral-500
              fillDefault: 'rgba(255, 255, 255, 0)',
              fillHover: 'rgba(255, 255, 255, 0.2)', // references surface-neutral-200
              fillPressed: 'rgba(255, 255, 255, 0.1)', // references surface-neutral-100
              fillDisabled: 'rgba(255, 255, 255, 0)'
            }
          },
          // Spacing semantic tokens (same for light and dark)
          spacing: {
            xs: '2px',
            sm: '4px',
            md: '8px',
            lg: '12px',
            xl: '16px',
            '2xl': '20px',
            '3xl': '24px',
            '4xl': '32px'
          },
          // Typography semantic tokens (same for light and dark)
          typography: {
            bodyXs: {
              size: '10px',
              weight: '400',
              lineHeight: '1.4',
              letterSpacing: '0'
            },
            bodySm: {
              size: '12px',
              weight: '400',
              lineHeight: '1.4',
              letterSpacing: '0'
            },
            bodyMd: {
              size: '14px',
              weight: '400',
              lineHeight: '1.5',
              letterSpacing: '0'
            },
            bodyLg: {
              size: '16px',
              weight: '400',
              lineHeight: '1.5',
              letterSpacing: '0'
            },
            labelSm: {
              size: '11px',
              weight: '450',
              lineHeight: '1.4',
              letterSpacing: '0.055px'
            },
            labelMd: {
              size: '13px',
              weight: '500',
              lineHeight: '1.4',
              letterSpacing: '0'
            },
            labelLg: {
              size: '14px',
              weight: '500',
              lineHeight: '1.4',
              letterSpacing: '0'
            },
            headingSm: {
              size: '14px',
              weight: '600',
              lineHeight: '1.4',
              letterSpacing: '0'
            },
            headingMd: {
              size: '18px',
              weight: '600',
              lineHeight: '1.4',
              letterSpacing: '0'
            }
          },
          // Border radius semantic tokens (same for light and dark)
          radius: {
            none: '0px',
            xs: '2px',
            sm: '4px',
            md: '6px',
            lg: '8px',
            xl: '12px',
            full: '50%'
          },
          // Transition semantic tokens (same for light and dark)
          transition: {
            fast: '0.15s ease',
            base: '0.2s ease',
            slow: '0.3s ease'
          }
        }
      }
    };

    // Backward compatibility: COLOR_TOKENS alias
    const COLOR_TOKENS = {
      primitive: DESIGN_TOKENS.primitive.color,
      semantic: {
        light: {
          text: DESIGN_TOKENS.semantic.light.text,
          surface: DESIGN_TOKENS.semantic.light.surface,
          badge: DESIGN_TOKENS.semantic.light.badge,
          icon: DESIGN_TOKENS.semantic.light.icon,
          button: DESIGN_TOKENS.semantic.light.button
        },
        dark: {
          text: DESIGN_TOKENS.semantic.dark.text,
          surface: DESIGN_TOKENS.semantic.dark.surface,
          badge: DESIGN_TOKENS.semantic.dark.badge,
          icon: DESIGN_TOKENS.semantic.dark.icon,
          button: DESIGN_TOKENS.semantic.dark.button
        }
      }
    };

    // Helper function to recursively set CSS custom properties from token object
    function setTokenProperties(root, obj, prefix = '') {
      for (const [key, value] of Object.entries(obj)) {
        const tokenName = prefix ? `${prefix}-${key}` : key;
        
        if (typeof value === 'string') {
          // Set the semantic token
          root.style.setProperty(`--semantic-${tokenName}`, value);
        } else if (typeof value === 'object' && value !== null) {
          // Recursively process nested objects
          setTokenProperties(root, value, tokenName);
        }
      }
    }

    // Function to initialize mode-independent tokens (spacing, typography, radius, transition)
    function initializeDesignTokens() {
      // Verify DESIGN_TOKENS exists
      if (!DESIGN_TOKENS || !DESIGN_TOKENS.semantic) {
        console.error('DESIGN_TOKENS not found or invalid structure');
        return;
      }
      
      if (!DESIGN_TOKENS.semantic.light || !DESIGN_TOKENS.semantic.dark) {
        console.error('DESIGN_TOKENS.semantic missing light or dark mode');
        return;
      }
      
      // Verify primitive tokens exist
      if (!DESIGN_TOKENS.primitive) {
        console.error('DESIGN_TOKENS.primitive not found');
        return;
      }
      
      const root = document.documentElement;
      const primitive = DESIGN_TOKENS.primitive;
      
      // Set spacing tokens (from primitive)
      if (primitive.spacing && typeof primitive.spacing === 'object') {
        Object.entries(primitive.spacing).forEach(([key, value]) => {
          root.style.setProperty(`--semantic-spacing-${key}`, value);
        });
      }
      
      // Set typography tokens (from primitive)
      if (primitive.typography && typeof primitive.typography === 'object') {
        Object.entries(primitive.typography).forEach(([type, props]) => {
          if (props && typeof props === 'object') {
            // Convert camelCase to kebab-case (e.g., bodyMd -> body-md)
            const typeName = type.replace(/([A-Z])/g, '-$1').toLowerCase();
            Object.entries(props).forEach(([prop, value]) => {
              const propName = prop === 'lineHeight' ? 'line-height' : 
                              prop === 'letterSpacing' ? 'letter-spacing' : prop;
              root.style.setProperty(`--semantic-typography-${typeName}-${propName}`, value);
            });
          }
        });
      }
      
      // Set radius tokens (from primitive)
      if (primitive.radius && typeof primitive.radius === 'object') {
        Object.entries(primitive.radius).forEach(([key, value]) => {
          root.style.setProperty(`--semantic-radius-${key}`, value);
        });
      }
      
      // Set transition tokens (from primitive)
      if (primitive.transition && typeof primitive.transition === 'object') {
        Object.entries(primitive.transition).forEach(([key, value]) => {
          if (value && typeof value === 'object') {
            // Handle nested transition properties (duration, easing)
            Object.entries(value).forEach(([subKey, subValue]) => {
              root.style.setProperty(`--semantic-transition-${key}-${subKey}`, subValue);
            });
          } else {
            root.style.setProperty(`--semantic-transition-${key}`, value);
          }
        });
      }
    }

    // Function to update CSS custom properties based on color mode
    function updateColorMode() {
      // Detect color scheme with fallback
      let isDarkMode = false;
      let detectionMethod = 'unknown';
      try {
        const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
        isDarkMode = mediaQuery.matches;
        detectionMethod = `mediaQuery (matches: ${mediaQuery.matches})`;
      } catch (e) {
        // Fallback: if media query fails, default to light mode
        isDarkMode = false;
        detectionMethod = `fallback (error: ${e.message})`;
        console.warn('Color mode detection failed:', e);
      }
      
      const root = document.documentElement;
      const mode = isDarkMode ? 'dark' : 'light';
      const tokens = DESIGN_TOKENS.semantic[mode];
      
      // Validate tokens exist
      if (!tokens) {
        console.error(`Color mode tokens missing for mode: ${mode}`);
        return;
      }
      
      // Log essential color mode info
      console.log(`Color mode: ${mode} (${detectionMethod})`);
      console.log(`Tokens: bg=${tokens.surface.bg}, text=${tokens.text.primary}`);
      
      // Set data attribute for CSS targeting
      root.setAttribute('data-color-mode', mode);
      root.classList.remove('light-mode', 'dark-mode');
      root.classList.add(`${mode}-mode`);
      
      // Set semantic tokens from DESIGN_TOKENS (color tokens are mode-dependent)
      setTokenProperties(root, {
        text: tokens.text,
        surface: tokens.surface,
        badge: tokens.badge,
        icon: tokens.icon,
        button: tokens.button
      });
      
      // Set surface tokens with proper naming convention
      // Text tokens
      root.style.setProperty('--semantic-text-primary', tokens.text.primary);
      root.style.setProperty('--semantic-text-secondary', tokens.text.secondary);
      
      // Surface tokens
      root.style.setProperty('--semantic-surface-bg', tokens.surface.bg);
      
      // Update body background to use token (remove any hardcoded inline styles)
      // Only update if body exists (might not be available during initial script execution)
      if (document.body) {
        document.body.style.background = '';
        document.body.style.setProperty('background', 'var(--semantic-surface-bg)');
        
        // Verify token was applied
        const computedBg = getComputedStyle(document.body).background;
        const expectedBg = tokens.surface.bg;
        if (computedBg && !computedBg.includes(expectedBg) && !computedBg.includes('var(')) {
          console.warn(`Body background mismatch: expected ${expectedBg}, got ${computedBg}`);
        }
      }
      
      Object.entries(tokens.surface.neutral).forEach(([shade, value]) => {
        root.style.setProperty(`--semantic-surface-neutral-${shade}`, value);
      });
      Object.entries(tokens.surface.brand).forEach(([shade, value]) => {
        root.style.setProperty(`--semantic-surface-brand-${shade}`, value);
      });
      Object.entries(tokens.surface.inverted).forEach(([shade, value]) => {
        root.style.setProperty(`--semantic-surface-inverted-${shade}`, value);
      });
      
      // Badge tokens
      Object.entries(tokens.badge).forEach(([badgeType, badgeTokens]) => {
        Object.entries(badgeTokens).forEach(([prop, value]) => {
          const propName = prop === 'buttonHover' ? 'button-hover' : 
                          prop === 'buttonPressed' ? 'button-pressed' : prop;
          root.style.setProperty(`--semantic-badge-${badgeType}-${propName}`, value);
        });
      });
      
      // Icon tokens
      root.style.setProperty('--semantic-icon-neutral-active', tokens.icon.neutral.active);
      root.style.setProperty('--semantic-icon-neutral-inactive', tokens.icon.neutral.inactive);
      root.style.setProperty('--semantic-icon-brand-active', tokens.icon.brand.active);
      root.style.setProperty('--semantic-icon-brand-inactive', tokens.icon.brand.inactive);
      
      // Button tokens
      root.style.setProperty('--semantic-button-brand-text', tokens.button.brand.text);
      root.style.setProperty('--semantic-button-brand-fill-default', tokens.button.brand.fillDefault);
      root.style.setProperty('--semantic-button-brand-fill-pressed', tokens.button.brand.fillPressed);
      root.style.setProperty('--semantic-button-brand-fill-disabled', tokens.button.brand.fillDisabled);
      
      // Secondary neutral button tokens
      Object.entries(tokens.button.secondaryNeutral).forEach(([prop, value]) => {
        const propName = prop.replace(/([A-Z])/g, '-$1').toLowerCase();
        root.style.setProperty(`--semantic-button-secondary-neutral-${propName}`, value);
      });
      
      // Secondary brand button tokens
      Object.entries(tokens.button.secondaryBrand).forEach(([prop, value]) => {
        const propName = prop.replace(/([A-Z])/g, '-$1').toLowerCase();
        root.style.setProperty(`--semantic-button-secondary-brand-${propName}`, value);
      });
      
      // Ghost neutral button tokens
      Object.entries(tokens.button.ghostNeutral).forEach(([prop, value]) => {
        const propName = prop.replace(/([A-Z])/g, '-$1').toLowerCase();
        root.style.setProperty(`--semantic-button-ghost-neutral-${propName}`, value);
      });
      
      // Backward-compatible aliases for old token names
      // Text tokens
      root.style.setProperty('--text-text-primary', tokens.text.primary);
      root.style.setProperty('--text-text-secondary', tokens.text.secondary);
      
      // Surface tokens
      root.style.setProperty('--surface-bg-bg', tokens.surface.bg);
      root.style.setProperty('--surface-neutral-100', tokens.surface.neutral['100']);
      root.style.setProperty('--surface-neutral-200', tokens.surface.neutral['200']);
      root.style.setProperty('--surface-neutral-300', tokens.surface.neutral['300']);
      root.style.setProperty('--surface-neutral-120', tokens.surface.neutral['120']);
      root.style.setProperty('--surface-neutral-75', tokens.surface.neutral['75']);
      root.style.setProperty('--surface-neutral-150', tokens.surface.neutral['150']);
      root.style.setProperty('--surface-brand-200', tokens.surface.brand['200']);
      root.style.setProperty('--surface-brand-300', tokens.surface.brand['300']);
      root.style.setProperty('--surface-brand-500', tokens.surface.brand['500']);
      root.style.setProperty('--surface-inverted-100', tokens.surface.inverted['100']);
      root.style.setProperty('--surface-inverted-200', tokens.surface.inverted['200']);
      
      // Badge tokens (old naming with redundant prefixes)
      root.style.setProperty('--badge-hero-hero-text', tokens.badge.hero.text);
      root.style.setProperty('--badge-hero-hero-icon', tokens.badge.hero.icon);
      root.style.setProperty('--badge-hero-hero-fill', tokens.badge.hero.fill);
      root.style.setProperty('--badge-hero-hero-stroke', tokens.badge.hero.stroke);
      root.style.setProperty('--badge-hero-hero-button-hover', tokens.badge.hero.buttonHover);
      root.style.setProperty('--badge-hero-hero-button-pressed', tokens.badge.hero.buttonPressed);
      
      root.style.setProperty('--badge-parent-parent-text', tokens.badge.parent.text);
      root.style.setProperty('--badge-parent-parent-icon', tokens.badge.parent.icon);
      root.style.setProperty('--badge-parent-parent-fill', tokens.badge.parent.fill);
      root.style.setProperty('--badge-parent-parent-stroke', tokens.badge.parent.stroke);
      root.style.setProperty('--badge-parent-parent-button-hover', tokens.badge.parent.buttonHover);
      root.style.setProperty('--badge-parent-parent-button-pressed', tokens.badge.parent.buttonPressed);
      
      root.style.setProperty('--badge-child-child-text', tokens.badge.child.text);
      root.style.setProperty('--badge-child-child-icon', tokens.badge.child.icon);
      root.style.setProperty('--badge-child-child-fill', tokens.badge.child.fill);
      root.style.setProperty('--badge-child-child-stroke', tokens.badge.child.stroke);
      root.style.setProperty('--badge-child-child-button-hover', tokens.badge.child.buttonHover);
      root.style.setProperty('--badge-child-child-button-pressed', tokens.badge.child.buttonPressed);
      
      root.style.setProperty('--badge-sub-child-subChild-text', tokens.badge.subChild.text);
      root.style.setProperty('--badge-sub-child-subChild-icon', tokens.badge.subChild.icon);
      root.style.setProperty('--badge-sub-child-subChild-fill', tokens.badge.subChild.fill);
      root.style.setProperty('--badge-sub-child-subChild-stroke', tokens.badge.subChild.stroke);
      root.style.setProperty('--badge-sub-child-subChild-button-hover', tokens.badge.subChild.buttonHover);
      root.style.setProperty('--badge-sub-child-subChild-button-pressed', tokens.badge.subChild.buttonPressed);
      
      // Icon tokens
      root.style.setProperty('--icon-neutral-active', tokens.icon.neutral.active);
      root.style.setProperty('--icon-neutral-inactive', tokens.icon.neutral.inactive);
      root.style.setProperty('--icon-brand-active', tokens.icon.brand.active);
      root.style.setProperty('--icon-brand-inactive', tokens.icon.brand.inactive);
      
      // Button tokens
      root.style.setProperty('--button-brand-text', tokens.button.brand.text);
      root.style.setProperty('--button-brand-fill-default', tokens.button.brand.fillDefault);
      root.style.setProperty('--button-brand-fill-hover', tokens.button.brand.fillPressed); // hover uses pressed value
      root.style.setProperty('--button-brand-fill-pressed', tokens.button.brand.fillPressed);
      root.style.setProperty('--button-brand-fill-disabled', tokens.button.brand.fillDisabled);
      
      // Secondary button tokens (old redundant naming)
      root.style.setProperty('--button-secondary-neutral-button-secondary-neutral-text-default', tokens.button.secondaryNeutral.textDefault);
      root.style.setProperty('--button-secondary-neutral-button-secondary-neutral-fill-default', tokens.button.secondaryNeutral.fillDefault);
      root.style.setProperty('--button-secondary-neutral-button-secondary-neutral-stroke-default', tokens.button.secondaryNeutral.strokeDefault);
      root.style.setProperty('--button-secondary-neutral-button-secondary-neutral-fill-hover', tokens.button.secondaryNeutral.fillPressed); // hover uses pressed
      root.style.setProperty('--button-secondary-neutral-button-secondary-neutral-stroke-hover', tokens.button.secondaryNeutral.strokePressed);
      root.style.setProperty('--button-secondary-neutral-button-secondary-neutral-fill-pressed', tokens.button.secondaryNeutral.fillPressed);
      root.style.setProperty('--button-secondary-neutral-button-secondary-neutral-stroke-pressed', tokens.button.secondaryNeutral.strokePressed);
      root.style.setProperty('--button-secondary-neutral-button-secondary-neutral-fill-disabled', tokens.button.secondaryNeutral.fillDisabled);
      root.style.setProperty('--button-secondary-neutral-button-secondary-neutral-stroke-disabled', tokens.button.secondaryNeutral.strokeDisabled);
      root.style.setProperty('--button-secondary-neutral-button-secondary-neutral-disabled', tokens.button.secondaryNeutral.disabled);
      
      root.style.setProperty('--button-secondary-brand-button-secondary-brand-text-default', tokens.button.secondaryBrand.textDefault);
      root.style.setProperty('--button-secondary-brand-button-secondary-brand-fill-default', tokens.button.secondaryBrand.fillDefault);
      root.style.setProperty('--button-secondary-brand-button-secondary-brand-stroke-default', tokens.button.secondaryBrand.strokeDefault);
      root.style.setProperty('--button-secondary-brand-button-secondary-brand-fill-hover', tokens.button.secondaryBrand.fillPressed);
      root.style.setProperty('--button-secondary-brand-button-secondary-brand-stroke-hover', tokens.button.secondaryBrand.strokePressed);
      root.style.setProperty('--button-secondary-brand-button-secondary-brand-fill-pressed', tokens.button.secondaryBrand.fillPressed);
      root.style.setProperty('--button-secondary-brand-button-secondary-brand-stroke-pressed', tokens.button.secondaryBrand.strokePressed);
      root.style.setProperty('--button-secondary-brand-button-secondary-brand-fill-active', tokens.button.secondaryBrand.fillPressed);
      root.style.setProperty('--button-secondary-brand-button-secondary-brand-stroke-active', tokens.button.secondaryBrand.strokeDefault);
      root.style.setProperty('--button-secondary-brand-button-secondary-brand-fill-disabled', tokens.button.secondaryBrand.fillDisabled);
      root.style.setProperty('--button-secondary-brand-button-secondary-brand-stroke-disabled', tokens.button.secondaryBrand.strokeDisabled);
      root.style.setProperty('--button-secondary-brand-button-secondary-brand-disabled', tokens.button.secondaryBrand.disabled);
    }

    // Function to toggle between UI versions (deprecated - dev UI is now always shown)
    function toggleUi(useNewUi) {
      currentUi.style.display = useNewUi ? 'none' : 'block';
      newUi.style.display = useNewUi ? 'flex' : 'none';
      
      // Update toggle state (if toggle exists)
      if (uiToggle) {
        uiToggle.checked = useNewUi;
      }
      
      // Update body background color based on UI (use semantic token)
      document.body.style.background = '';
      document.body.style.setProperty('background', 'var(--semantic-surface-bg)');
      
      // Store the preference to remember it between plugin sessions
      localStorage.setItem('useNewUi', useNewUi.toString());
      
      // Adjust the plugin height based on UI type
      if (useNewUi) {
        // Development UI needs more height
        parent.postMessage({
          pluginMessage: {
            type: 'resize-height',
            height: 520
          }
        }, '*');
      } else {
        // Return to original height
        parent.postMessage({
          pluginMessage: {
            type: 'resize-height',
            height: 480
          }
        }, '*');
      }
      
      // Notify the plugin code of the UI change
      parent.postMessage({ 
        pluginMessage: { 
          type: 'ui-toggle-change',
          useNewUi: useNewUi
        } 
      }, '*');
    }
    
    // Toggle switch is now hidden - dev UI is always shown
    // uiToggle event listener removed
    
    // Test modal button handler
    const testModalButton = document.getElementById('testModalButton');
    if (testModalButton) {
      testModalButton.addEventListener('click', () => {
        // Create sample test data for the hierarchy skip modal
        const testSkippedNodes = [
          {
            id: 'test-node-1',
            path: 'parent.Container > subChild.Item',
            currentPrefix: 'subChild.',
            suggestedPrefix: 'child.'
          },
          {
            id: 'test-node-2',
            path: 'hero.Section > subChild.Card',
            currentPrefix: 'subChild.',
            suggestedPrefix: 'child.'
          },
          {
            id: 'test-node-3',
            path: 'parent.Wrapper > child.List > subChild.Item > subChild.Nested',
            currentPrefix: 'subChild.',
            suggestedPrefix: 'subChild.'
          }
        ];
        
        // Show the hierarchy skip modal with test data
        showHierarchySkipModal(testSkippedNodes);
      });
    }
    
    // Initialize color mode immediately (before DOMContentLoaded)
    // This ensures tokens are set as early as possible
    console.log('Initializing color mode detection...');
    if (document.readyState === 'loading') {
      // DOM hasn't finished loading yet, wait for it
      document.addEventListener('DOMContentLoaded', () => {
        console.log('DOMContentLoaded: Initializing design tokens and color mode');
        initializeDesignTokens();
        updateColorMode();
      });
    } else {
      // DOM is already loaded
      console.log('DOM ready: Initializing design tokens and color mode');
      initializeDesignTokens();
      updateColorMode();
    }
    
    // Listen for color mode changes (set up immediately, not in DOMContentLoaded)
    const colorSchemeQuery = window.matchMedia('(prefers-color-scheme: dark)');
    if (colorSchemeQuery.addEventListener) {
      colorSchemeQuery.addEventListener('change', (e) => {
        console.log(`Color mode changed: ${e.matches ? 'dark' : 'light'}`);
        updateColorMode();
      });
    } else {
      // Fallback for older browsers
      colorSchemeQuery.addListener((e) => {
        console.log(`Color mode changed (legacy): ${e.matches ? 'dark' : 'light'}`);
        updateColorMode();
      });
    }
    console.log(`Color mode listener attached (current: ${colorSchemeQuery.matches ? 'dark' : 'light'})`);
    
    // Load saved UI preference
    document.addEventListener('DOMContentLoaded', () => {
      // Verify tokens are initialized
      const bgToken = document.documentElement.style.getPropertyValue('--semantic-surface-bg');
      if (!bgToken) {
        console.warn('Surface bg token missing, re-initializing...');
        initializeDesignTokens();
        updateColorMode();
      } else {
        console.log(`Surface bg token verified: ${bgToken}`);
      }
      
      // Ensure body background is set (body should exist by now)
      if (document.body) {
        document.body.style.background = '';
        document.body.style.setProperty('background', 'var(--semantic-surface-bg)');
      }
      
      // Add layout button toggle functionality
      const cornerButtons = document.querySelectorAll('.btn-layout-corner-radius');
      const paddingButtons = document.querySelectorAll('.btn-layout-padding');
      const nestedButton = document.querySelector('.btn-layout-nested');
      const layoutContainer = document.querySelector('.layout-selection-container');
      
      // Helper function to check if any layout buttons (corners, padding, spacing) are active
      // and automatically toggle off nested button if none are active
      const checkAndUpdateNestedButton = () => {
        if (!nestedButton || !layoutContainer) return;
        
        // Check if any layout buttons are active
        const cornerButtons = layoutContainer.querySelectorAll('.btn-layout-corner-radius');
        const paddingButtons = layoutContainer.querySelectorAll('.btn-layout-padding');
        const spacingButtons = layoutContainer.querySelectorAll('.btn-layout-spacing');
        
        const hasActiveCorners = Array.from(cornerButtons).some(btn => btn.classList.contains('active'));
        const hasActivePadding = Array.from(paddingButtons).some(btn => btn.classList.contains('active'));
        const hasActiveSpacing = Array.from(spacingButtons).some(btn => btn.classList.contains('active'));
        
        const hasAnyLayoutButtonsActive = hasActiveCorners || hasActivePadding || hasActiveSpacing;
        
        // If no layout buttons are active, automatically toggle off nested button
        if (!hasAnyLayoutButtonsActive && nestedButton.classList.contains('active')) {
          nestedButton.classList.remove('active');
          nestedButton.classList.add('inactive');
        }
      };
      
      // Function to toggle all layout buttons (select/deselect all)
      // This must be defined before the button event listeners
      const toggleAllLayoutButtons = () => {
        if (!layoutContainer) return;
        
        // Get all layout buttons
        const allCornerButtons = layoutContainer.querySelectorAll('.btn-layout-corner-radius');
        const allPaddingButtons = layoutContainer.querySelectorAll('.btn-layout-padding');
        const allSpacingButtons = layoutContainer.querySelectorAll('.btn-layout-spacing');
        const allButtons = [...allCornerButtons, ...allPaddingButtons, ...allSpacingButtons];
        
        if (allButtons.length === 0) return;
        
        // Check if all buttons are currently active
        const allActive = Array.from(allButtons).every(btn => btn.classList.contains('active'));
        
        // Toggle all buttons - deselect if all active, select if any inactive
        allButtons.forEach(button => {
          if (allActive) {
            // Deselect all buttons
            button.classList.remove('active');
            button.classList.add('inactive');
          } else {
            // Select all buttons
            button.classList.remove('inactive');
            button.classList.add('active');
          }
        });
        
        // Also toggle nested button
        if (nestedButton) {
          if (allActive) {
            nestedButton.classList.remove('active');
            nestedButton.classList.add('inactive');
          } else {
            nestedButton.classList.remove('inactive');
            nestedButton.classList.add('active');
          }
        }
        
        // Check and update nested button state based on other layout buttons
        checkAndUpdateNestedButton();
        
        // Update button text after toggling to reflect new state
        updateApplyVariablesButtonText();
      };
      
      // Update tooltip text based on platform (Mac uses Cmd, others use Ctrl)
      const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
      const modifierKey = isMac ? 'âŒ˜' : 'Ctrl';
      const shiftKey = isMac ? 'â‡§' : 'Shift';
      paddingButtons.forEach(button => {
        const tooltip = button.querySelector('.padding-tooltip');
        if (tooltip) {
          tooltip.textContent = `${modifierKey}+Click to select individually, ${modifierKey}+${shiftKey}+Click section to select/deselect all`;
        }
      });
      cornerButtons.forEach(button => {
        const tooltip = button.querySelector('.padding-tooltip');
        if (tooltip) {
          tooltip.textContent = `${modifierKey}+Click to select individually, ${modifierKey}+${shiftKey}+Click section to select/deselect all`;
        }
      });
      
      // Add tooltip delay functionality (800ms delay before showing)
      const tooltipDelay = 800;
      const allLayoutButtons = document.querySelectorAll('.btn-layout-padding, .btn-layout-corner-radius');
      allLayoutButtons.forEach(button => {
        let tooltipTimeout;
        const tooltip = button.querySelector('.padding-tooltip');
        
        if (tooltip) {
          button.addEventListener('mouseenter', () => {
            tooltipTimeout = setTimeout(() => {
              tooltip.style.opacity = '1';
            }, tooltipDelay);
          });
          
          button.addEventListener('mouseleave', () => {
            clearTimeout(tooltipTimeout);
            tooltip.style.opacity = '0';
          });
        }
      });
      
      // Corner radius buttons - toggle all together, or individually with Ctrl/Cmd+Click
      cornerButtons.forEach(button => {
        button.addEventListener('click', (e) => {
          const isCtrlOrCmd = e.ctrlKey || e.metaKey;
          const isShift = e.shiftKey;
          const isActive = button.classList.contains('active');
          
          // If Cmd+Shift is pressed, toggle all buttons instead
          if (isCtrlOrCmd && isShift) {
            e.preventDefault();
            e.stopPropagation();
            toggleAllLayoutButtons();
            return;
          }
          
          if (isCtrlOrCmd) {
            // Individual toggle when Ctrl/Cmd is held
            if (isActive) {
              button.classList.remove('active');
              button.classList.add('inactive');
            } else {
              button.classList.remove('inactive');
              button.classList.add('active');
            }
          } else {
            // Toggle all corner buttons together
            cornerButtons.forEach(btn => {
              if (isActive) {
                btn.classList.remove('active');
                btn.classList.add('inactive');
              } else {
                btn.classList.remove('inactive');
                btn.classList.add('active');
              }
            });
          }
          
          // Check and update nested button state based on other layout buttons
          checkAndUpdateNestedButton();
          
          // Update button text after toggling
          updateApplyVariablesButtonText();
        });
      });
      
      // Padding buttons - toggle symmetrically (left/right together, top/bottom together)
      // Ctrl/Cmd+Click allows individual side selection
      paddingButtons.forEach(button => {
        button.addEventListener('click', (e) => {
          const padding = button.getAttribute('data-padding');
          const isCtrlOrCmd = e.ctrlKey || e.metaKey;
          const isShift = e.shiftKey;
          const isActive = button.classList.contains('active');
          
          // If Cmd+Shift is pressed, toggle all buttons instead
          if (isCtrlOrCmd && isShift) {
            e.preventDefault();
            e.stopPropagation();
            toggleAllLayoutButtons();
            return;
          }
          
          if (isCtrlOrCmd) {
            // Individual toggle when Ctrl/Cmd is held
            if (isActive) {
              button.classList.remove('active');
              button.classList.add('inactive');
            } else {
              button.classList.remove('inactive');
              button.classList.add('active');
            }
          } else {
            // Symmetric toggle for pairs
            if (padding === 'left' || padding === 'right') {
              // Toggle left and right together
              const leftButton = document.querySelector('.btn-layout-padding[data-padding="left"]');
              const rightButton = document.querySelector('.btn-layout-padding[data-padding="right"]');
              
              if (isActive) {
                leftButton.classList.remove('active');
                leftButton.classList.add('inactive');
                rightButton.classList.remove('active');
                rightButton.classList.add('inactive');
              } else {
                leftButton.classList.remove('inactive');
                leftButton.classList.add('active');
                rightButton.classList.remove('inactive');
                rightButton.classList.add('active');
              }
            } else if (padding === 'top' || padding === 'bottom') {
              // Toggle top and bottom together
              const topButton = document.querySelector('.btn-layout-padding[data-padding="top"]');
              const bottomButton = document.querySelector('.btn-layout-padding[data-padding="bottom"]');
              
              if (isActive) {
                topButton.classList.remove('active');
                topButton.classList.add('inactive');
                bottomButton.classList.remove('active');
                bottomButton.classList.add('inactive');
              } else {
                topButton.classList.remove('inactive');
                topButton.classList.add('active');
                bottomButton.classList.remove('inactive');
                bottomButton.classList.add('active');
              }
            }
          }
          
          // Check and update nested button state based on other layout buttons
          checkAndUpdateNestedButton();
          
          // Update button text after toggling
          updateApplyVariablesButtonText();
        });
      });
      
      // Nested button - toggle individually
      if (nestedButton) {
        nestedButton.addEventListener('click', () => {
          // Toggle between active and inactive states
          if (nestedButton.classList.contains('active')) {
            nestedButton.classList.remove('active');
            nestedButton.classList.add('inactive');
          } else {
            nestedButton.classList.remove('inactive');
            nestedButton.classList.add('active');
          }
          
          // Update button text after toggling (though nested button doesn't affect the logic)
          updateApplyVariablesButtonText();
        });
      }
      
      // Spacing buttons - toggle together (both left and right together)
      // Ctrl/Cmd+Click allows individual side selection
      const spacingButtons = document.querySelectorAll('.btn-layout-spacing');
      spacingButtons.forEach(button => {
        button.addEventListener('click', (e) => {
          const spacing = button.getAttribute('data-spacing');
          const isCtrlOrCmd = e.ctrlKey || e.metaKey;
          const isShift = e.shiftKey;
          const isActive = button.classList.contains('active');
          
          // If Cmd+Shift is pressed, toggle all buttons instead
          if (isCtrlOrCmd && isShift) {
            e.preventDefault();
            e.stopPropagation();
            toggleAllLayoutButtons();
            return;
          }
          
          if (isCtrlOrCmd) {
            // Individual toggle when Ctrl/Cmd is held
            if (isActive) {
              button.classList.remove('active');
              button.classList.add('inactive');
            } else {
              button.classList.remove('inactive');
              button.classList.add('active');
            }
          } else {
            // Toggle both spacing buttons together
            const leftButton = document.querySelector('.btn-layout-spacing[data-spacing="left"]');
            const rightButton = document.querySelector('.btn-layout-spacing[data-spacing="right"]');
            
            if (isActive) {
              if (leftButton) {
                leftButton.classList.remove('active');
                leftButton.classList.add('inactive');
              }
              if (rightButton) {
                rightButton.classList.remove('active');
                rightButton.classList.add('inactive');
              }
            } else {
              if (leftButton) {
                leftButton.classList.remove('inactive');
                leftButton.classList.add('active');
              }
              if (rightButton) {
                rightButton.classList.remove('inactive');
                rightButton.classList.add('active');
              }
            }
          }
          
          // Check and update nested button state based on other layout buttons
          checkAndUpdateNestedButton();
          
          // Update button text after toggling
          updateApplyVariablesButtonText();
        });
      });
      
      // Add Cmd+Shift+Click handler on layout-selection-wrapper to select/deselect all
      const layoutWrapper = document.querySelector('.layout-selection-wrapper');
      
      // Handler function for wrapper/container clicks
      const handleSelectDeselectAll = (e) => {
        // Use Command (metaKey) on Mac, Control (ctrlKey) on Windows/Linux
        const isCmdOrCtrl = e.metaKey || e.ctrlKey;
        const isShift = e.shiftKey;
        
        // Only handle if both Command/Ctrl and Shift are pressed
        if (!isCmdOrCtrl || !isShift) {
          return;
        }
        
        // Check if click is on a button - if so, let the button handler deal with it
        const clickedElement = e.target;
        const isButton = clickedElement.closest('.btn-layout-corner-radius, .btn-layout-padding, .btn-layout-nested');
        
        // Only handle if clicking on wrapper/container background, not on buttons
        if (isButton) {
          return;
        }
        
        e.preventDefault();
        e.stopPropagation();
        
        toggleAllLayoutButtons();
      };
      
      // Add event listener to wrapper
      if (layoutWrapper) {
        layoutWrapper.addEventListener('click', handleSelectDeselectAll);
      }
      
      // Also add to container as fallback
      if (layoutContainer) {
        layoutContainer.addEventListener('click', handleSelectDeselectAll);
      }
      
      // Dev UI is now the default/main UI - always show it
      // Ensure dev UI is visible and set dark background
      currentUi.style.display = 'none';
      newUi.style.display = 'flex';
      // Update body background to use semantic token
      document.body.style.background = '';
      document.body.style.setProperty('background', 'var(--semantic-surface-bg)');
      
      // Set initial height for dev UI
      parent.postMessage({
        pluginMessage: {
          type: 'resize-height',
          height: 520
        }
      }, '*');
    });
    
    // Toggle help content visibility
    helpButton.addEventListener('click', () => {
      const isVisible = helpContent.style.display !== 'none';
      helpContent.style.display = isVisible ? 'none' : 'block';
      helpButton.classList.toggle('active', !isVisible);
    });
    
    // Toggle accordion visibility
    renameAccordionHeader.addEventListener('click', () => {
      const isVisible = renameAccordionContent.style.display !== 'none';
      renameAccordionContent.style.display = isVisible ? 'none' : 'block';
      accordionIcon.classList.toggle('open', !isVisible);
    });
    
    // Function to get base name without prefix
    function getBaseName(name) {
      let baseName = name;
      
      // Remove any existing prefix
      for (const existingPrefix of ['parent.', 'child.', 'subChild.', 'hero.']) {
        if (name.startsWith(existingPrefix)) {
          baseName = name.substring(existingPrefix.length);
          break;
        }
      }
      
      return baseName;
    }
    
    // Handle rename button hover for preview
    renameButtons.forEach(button => {
      button.addEventListener('mouseenter', () => {
        if (!selectedNode) return;
        
        const prefix = button.getAttribute('data-prefix');
        const baseName = getBaseName(selectedNode.name);
        const previewName = `${prefix}.${baseName}`;
        
        previewNameChange.textContent = `Will rename to: ${previewName}`;
        previewNameChange.style.display = 'block';
      });
      
      button.addEventListener('mouseleave', () => {
        previewNameChange.textContent = '';
        previewNameChange.style.display = 'none';
      });
    });
    
    // Handle rename button clicks
    renameButtons.forEach(button => {
      button.addEventListener('click', () => {
        const prefix = button.getAttribute('data-prefix');
        if (!selectedNode) {
          showMessage('No layer selected. Select a layer in Figma first.', 'error');
          return;
        }
        
        // Get the base name (without prefix)
        const baseName = getBaseName(selectedNode.name);
        
        // Create the new name with the selected prefix
        const newName = `${prefix}.${baseName}`;
        
        // Send rename message to plugin
        parent.postMessage({ 
          pluginMessage: { 
            type: 'rename-node',
            nodeId: selectedNode.id,
            newName: newName,
            applyAfter: applyAfterRename.checked,
            renameNested: renameNested.checked
          } 
        }, '*');
        
        // Show loading
        showLoading(true, 'Renaming layer');
      });
    });
    
    // Handle auto adjust button click
    autoAdjustButton.addEventListener('click', () => {
      if (!selectedNode) {
        showMessage('No layer selected. Select a layer in Figma first.', 'error');
        return;
      }
      
      // Send auto adjust message to plugin
      parent.postMessage({
        pluginMessage: {
          type: 'auto-adjust',
          nodeId: selectedNode.id,
          applyAfter: true, // Always apply variables after auto adjust
          renameNested: true // Always rename nested layers in auto adjust
        }
      }, '*');
      
      // Show loading
      showLoading(true, 'Auto adjusting hierarchy');
    });

    function showMessage(text, type) {
      message.textContent = text;
      message.className = `message ${type}`;
      message.style.display = 'block';
      
      // Auto-hide success messages after 3 seconds
      if (type === 'success') {
        setTimeout(() => {
          message.style.display = 'none';
        }, 3000);
      }
    }

    function showLoading(show, action = 'Processing') {
      loadingText.textContent = `${action}...`;
      loading.style.display = show ? 'flex' : 'none';
      applyButton.disabled = show;
      clearButton.disabled = show;
    }

    applyButton.addEventListener('click', () => {
      showLoading(true, 'Applying variables');
      message.style.display = 'none';
      
      // Collect layout button states (including nested button)
      const filters = collectLayoutButtonStates();
      
      // Send message to plugin code with filters (no spacing mode handling)
      parent.postMessage({ 
        pluginMessage: { 
          type: 'apply-variables',
          corners: filters.corners,
          padding: filters.padding,
          applyToNested: filters.applyToNested,
          applyToSpacing: filters.applyToSpacing
        } 
      }, '*');
    });

    clearButton.addEventListener('click', () => {
      showLoading(true, 'Clearing variables');
      message.style.display = 'none';
      
      // Collect layout button states
      const filters = collectLayoutButtonStates();
      
      // Send message to plugin code with filters
      parent.postMessage({ 
        pluginMessage: { 
          type: 'clear-variables',
          corners: filters.corners,
          padding: filters.padding,
          applyToNested: filters.applyToNested,
          applyToSpacing: filters.applyToSpacing
        } 
      }, '*');
    });

    // Helper function to update layout button states based on variable bindings
    function updateLayoutButtonStates(bindings) {
      // Update corner radius buttons
      const cornerButtons = document.querySelectorAll('.btn-layout-corner-radius');
      cornerButtons.forEach(button => {
        const corner = button.getAttribute('data-corner');
        let isBound = false;
        
        if (corner === 'top-left') {
          isBound = bindings.corners.topLeft;
        } else if (corner === 'top-right') {
          isBound = bindings.corners.topRight;
        } else if (corner === 'bottom-left') {
          isBound = bindings.corners.bottomLeft;
        } else if (corner === 'bottom-right') {
          isBound = bindings.corners.bottomRight;
        }
        
        // Set active/inactive based on binding state
        if (isBound) {
          button.classList.add('active');
          button.classList.remove('inactive');
        } else {
          button.classList.remove('active');
          button.classList.add('inactive');
        }
      });
      
      // Update padding buttons
      const paddingButtons = document.querySelectorAll('.btn-layout-padding');
      paddingButtons.forEach(button => {
        const padding = button.getAttribute('data-padding');
        let isBound = false;
        
        if (padding === 'top') {
          isBound = bindings.padding.top;
        } else if (padding === 'bottom') {
          isBound = bindings.padding.bottom;
        } else if (padding === 'left') {
          isBound = bindings.padding.left;
        } else if (padding === 'right') {
          isBound = bindings.padding.right;
        }
        
        // Set active/inactive based on binding state
        if (isBound) {
          button.classList.add('active');
          button.classList.remove('inactive');
        } else {
          button.classList.remove('active');
          button.classList.add('inactive');
        }
      });
    }
    
    // Helper function to reset all layout button states to inactive
    function resetLayoutButtonStates() {
      const layoutButtons = document.querySelectorAll('.btn-layout-corner-radius, .btn-layout-padding');
      layoutButtons.forEach(button => {
        button.classList.remove('active');
        button.classList.add('inactive');
      });
    }

    // Helper function to check if any variables are set
    function hasVariablesSet(bindings) {
      if (!bindings) return false;
      
      // Check if any corners are set
      const hasCorners = bindings.corners && (
        bindings.corners.topLeft ||
        bindings.corners.topRight ||
        bindings.corners.bottomLeft ||
        bindings.corners.bottomRight
      );
      
      // Check if any padding is set
      const hasPadding = bindings.padding && (
        bindings.padding.top ||
        bindings.padding.bottom ||
        bindings.padding.left ||
        bindings.padding.right
      );
      
      // Check if spacing is set
      const hasSpacing = bindings.spacing === true;
      
      return hasCorners || hasPadding || hasSpacing;
    }

    // Helper function to update clear variables button state
    function updateClearVariablesButtonState() {
      const clearVariablesBtn = document.getElementById('clearVariablesBtn');
      if (!clearVariablesBtn) return;
      
      // Use getUIMode() to determine current mode (consistent with updateUIState)
      const currentMode = getUIMode();
      const isSetupMode = currentMode === 'setup';
      const isAdjustMode = currentMode === 'adjust';
      
      // Disable if no variables are set and we're in setup or adjust mode
      // In setup mode, Clear Variables should always be disabled (no variables to clear)
      // In adjust mode, disable if no variables are set
      const shouldDisable = (isSetupMode || (isAdjustMode && !hasVariablesSet(currentVariableBindings)));
      
      if (shouldDisable) {
        clearVariablesBtn.disabled = true;
        clearVariablesBtn.style.opacity = '0.4';
        clearVariablesBtn.style.cursor = 'not-allowed';
      } else {
        clearVariablesBtn.disabled = false;
        clearVariablesBtn.style.opacity = '1';
        clearVariablesBtn.style.cursor = 'pointer';
      }
    }

    // Helper function to collect layout button states for filtering
    function collectLayoutButtonStates() {
      const filters = {
        corners: {},
        padding: {},
        applyToNested: false,
        applyToSpacing: false
      };

      // Collect corner radius button states
      const cornerButtons = document.querySelectorAll('.btn-layout-corner-radius');
      cornerButtons.forEach(button => {
        const corner = button.getAttribute('data-corner');
        const isActive = button.classList.contains('active');
        
        if (corner === 'top-left') {
          filters.corners.topLeft = isActive;
        } else if (corner === 'top-right') {
          filters.corners.topRight = isActive;
        } else if (corner === 'bottom-left') {
          filters.corners.bottomLeft = isActive;
        } else if (corner === 'bottom-right') {
          filters.corners.bottomRight = isActive;
        }
      });

      // Collect padding button states
      const paddingButtons = document.querySelectorAll('.btn-layout-padding');
      paddingButtons.forEach(button => {
        const padding = button.getAttribute('data-padding');
        const isActive = button.classList.contains('active');
        
        if (padding === 'top') {
          filters.padding.top = isActive;
        } else if (padding === 'bottom') {
          filters.padding.bottom = isActive;
        } else if (padding === 'left') {
          filters.padding.left = isActive;
        } else if (padding === 'right') {
          filters.padding.right = isActive;
        }
      });

      // Collect nested control button state
      const nestedButton = document.querySelector('.btn-layout-nested');
      if (nestedButton) {
        const isActive = nestedButton.classList.contains('active');
        filters.applyToNested = isActive;
      }

      // Collect spacing control button state (check if either left or right spacing button is active)
      const spacingButtons = document.querySelectorAll('.btn-layout-spacing');
      let hasActiveSpacing = false;
      spacingButtons.forEach(button => {
        if (button.classList.contains('active')) {
          hasActiveSpacing = true;
        }
      });
      filters.applyToSpacing = hasActiveSpacing;

      return filters;
    }

    // Function to update Apply Variables button text based on state
    function updateApplyVariablesButtonText() {
      const applyVariablesBtn = document.getElementById('applyVariablesBtn');
      if (!applyVariablesBtn) return;
      
      // Use getUIMode() to determine current mode (consistent with updateUIState)
      const currentMode = getUIMode();
      const isSetupMode = currentMode === 'setup';
      const hasSelectedPrefix = !!dropdownState.selectedPrefix;
      
      // Check if any layout buttons are active (corners, padding, spacing, or nested)
      const cornerButtons = document.querySelectorAll('.btn-layout-corner-radius');
      const paddingButtons = document.querySelectorAll('.btn-layout-padding');
      const spacingButtons = document.querySelectorAll('.btn-layout-spacing');
      const nestedButton = document.querySelector('.btn-layout-nested');
      
      const hasActiveCorners = Array.from(cornerButtons).some(btn => btn.classList.contains('active'));
      const hasActivePadding = Array.from(paddingButtons).some(btn => btn.classList.contains('active'));
      const hasActiveSpacing = Array.from(spacingButtons).some(btn => btn.classList.contains('active'));
      const hasActiveNested = nestedButton && nestedButton.classList.contains('active');
      
      const hasActiveLayoutButtons = hasActiveCorners || hasActivePadding || hasActiveSpacing || hasActiveNested;
      
      // Update button text: "Apply Prefix" if in setup mode, prefix selected, but no layout buttons active
      // Otherwise, show "Apply Variables" (including when spacing buttons are active)
      if (isSetupMode && hasSelectedPrefix && !hasActiveLayoutButtons) {
        applyVariablesBtn.textContent = 'Apply Prefix';
      } else {
        applyVariablesBtn.textContent = 'Apply Variables';
      }
    }
    
    // Centralized function to update all button states
    function updateAllButtonStates(debugContext = '') {
      const applyVariablesBtn = document.getElementById('applyVariablesBtn');
      const clearVariablesBtn = document.getElementById('clearVariablesBtn');
      const dropdown = document.getElementById('devActiveDropdown');
      
      // Gather all state information
      // Use getUIMode() to determine current mode (consistent with updateUIState)
      const currentMode = getUIMode();
      const isSpacingMode = currentMode === 'spacing';
      const hasVariables = hasVariablesSet(currentVariableBindings);
      const isDropdownVisible = dropdown ? dropdown.classList.contains('show') : false;
      const isSetupMode = currentMode === 'setup';
      const isAdjustMode = currentMode === 'adjust';
      
      // Calculate Apply Variables button state
      let applyShouldDisable = false;
      let applyReason = '';
      
      if (isSpacingMode && hasVariables) {
        applyShouldDisable = true;
        applyReason = 'spacing mode with variables bound';
      } else if (isDropdownVisible && !isSetupMode) {
        applyShouldDisable = true;
        applyReason = 'dropdown visible in adjust mode';
      }
      
      // Calculate Clear Variables button state
      let clearShouldDisable = false;
      let clearReason = '';
      
      if (isDropdownVisible && !isSetupMode) {
        clearShouldDisable = true;
        clearReason = 'dropdown visible in adjust mode';
      } else if ((isSetupMode || isAdjustMode) && !hasVariables) {
        clearShouldDisable = true;
        clearReason = `${isSetupMode ? 'setup' : 'adjust'} mode with no variables`;
      }
      
      // Apply states to DOM
      if (applyVariablesBtn) {
        applyVariablesBtn.disabled = applyShouldDisable;
        applyVariablesBtn.style.opacity = applyShouldDisable ? '0.4' : '1';
        applyVariablesBtn.style.cursor = applyShouldDisable ? 'not-allowed' : 'pointer';
        
        // Update button text
        updateApplyVariablesButtonText();
      }
      
      if (clearVariablesBtn) {
        clearVariablesBtn.disabled = clearShouldDisable;
        clearVariablesBtn.style.opacity = clearShouldDisable ? '0.4' : '1';
        clearVariablesBtn.style.cursor = clearShouldDisable ? 'not-allowed' : 'pointer';
      }
    }
    
    // Legacy function wrappers for backward compatibility during migration
    function updateApplyVariablesButtonState() {
      updateAllButtonStates('(via updateApplyVariablesButtonState)');
    }
    
    function updateClearVariablesButtonState() {
      updateAllButtonStates('(via updateClearVariablesButtonState)');
    }

    // New UI button handlers
    const applyVariablesBtn = document.getElementById('applyVariablesBtn');
    const clearVariablesBtn = document.getElementById('clearVariablesBtn');

    if (applyVariablesBtn) {
      applyVariablesBtn.addEventListener('click', () => {
        if (!selectedNode) {
          showMessage('No layer selected. Select a layer in Figma first.', 'error');
          return;
        }
        
        // Determine mode based on bound variables (consistent with getUIMode)
        const hasVariables = hasVariablesSet(currentVariableBindings);
        const isSpacingMode = currentDirectionalExtension === 'row.' || currentDirectionalExtension === 'column.';
        const isSetupMode = !hasVariables && !isSpacingMode;
        
        if (isSetupMode) {
          // Setup mode: requires a prefix to be selected
          if (!dropdownState.selectedPrefix) {
            showMessage('Please select a prefix level first.', 'error');
            return;
          }
          
          // Get base name without prefix
          let baseName = selectedNode.name;
          
          // Remove any existing prefix if present
          for (const existingPrefix of ['parent.', 'child.', 'subChild.', 'hero.']) {
            if (baseName.startsWith(existingPrefix)) {
              baseName = baseName.substring(existingPrefix.length);
              break;
            }
          }
          
          // Map prefix type to prefix string
          const prefixMap = {
            'hero': 'hero.',
            'parent': 'parent.',
            'child': 'child.',
            'subchild': 'subChild.',
            'auto': null // Auto doesn't add a prefix
          };
          
          const selectedPrefixValue = prefixMap[dropdownState.selectedPrefix];
          
          // Collect layout button states (filters and applyToNested)
          const filters = collectLayoutButtonStates();
          
          if (dropdownState.selectedPrefix === 'auto') {
            // Auto-adjust mode: send auto-adjust message with applyAfter and filters
            showLoading(true, 'Auto adjusting and applying variables');
            parent.postMessage({
              pluginMessage: {
                type: 'auto-adjust',
                nodeId: selectedNode.id,
                applyAfter: true,
                renameNested: filters.applyToNested, // Rename nested when applyToNested is true
                applyToNested: filters.applyToNested,
                applyToSpacing: filters.applyToSpacing,
                corners: filters.corners,
                padding: filters.padding
              }
            }, '*');
            
            // Reset dropdown state
            dropdownState.selectedPrefix = null;
            dropdownState.mode = null;
            
            // Update UI state - closes dropdown and enables layout
            updateUIState('(after auto-adjust in setup mode)');
          } else if (selectedPrefixValue) {
            // Prefix rename mode: send rename-node message with applyAfter and filters
            const newName = `${selectedPrefixValue}${baseName}`;
            
            showLoading(true, 'Setting up layer and applying variables');
            parent.postMessage({
              pluginMessage: {
                type: 'rename-node',
                nodeId: selectedNode.id,
                newName: newName,
                applyAfter: true,
                renameNested: filters.applyToNested, // Rename nested when applyToNested is true
                applyToNested: filters.applyToNested,
                applyToSpacing: filters.applyToSpacing,
                corners: filters.corners,
                padding: filters.padding
              }
            }, '*');
            
            // Reset dropdown state
            dropdownState.selectedPrefix = null;
            dropdownState.mode = null;
            
            // Update UI state - closes dropdown and enables layout
            updateUIState('(after prefix rename in setup mode)');
          } else {
            showMessage('Please select a prefix first.', 'error');
          }
        } else {
          // Adjust mode (variables are bound) or spacing mode: just apply variables
          // Collect layout button states
          const filters = collectLayoutButtonStates();
          
          // Show loading state
          showLoading(true, 'Applying variables');
          if (message) {
            message.style.display = 'none';
          }
          
          // Send message to plugin code with filters
          parent.postMessage({ 
            pluginMessage: { 
              type: 'apply-variables',
              corners: filters.corners,
              padding: filters.padding,
              applyToNested: filters.applyToNested,
              applyToSpacing: filters.applyToSpacing
            } 
          }, '*');
        }
      });
    }

    if (clearVariablesBtn) {
      clearVariablesBtn.addEventListener('click', () => {
        // Show loading state
        showLoading(true, 'Clearing variables');
        if (message) {
          message.style.display = 'none';
        }
        
        // Collect layout button states
        const filters = collectLayoutButtonStates();
        
        // Send message to plugin code with filters
        parent.postMessage({ 
          pluginMessage: { 
            type: 'clear-variables',
            corners: filters.corners,
            padding: filters.padding,
            applyToNested: filters.applyToNested,
            applyToSpacing: filters.applyToSpacing
          } 
        }, '*');
      });
    }

    // Add escape key handler to close the plugin
    document.addEventListener('keydown', (event) => {
      if (event.key === 'Escape') {
        parent.postMessage({ 
          pluginMessage: { 
            type: 'cancel' 
          } 
        }, '*');
      }
    });

    // Hierarchy Skip Modal elements
    const hierarchySkipModal = document.getElementById('hierarchySkipModal');
    const skipNodesList = document.getElementById('skipNodesList');
    const skipApplyButton = document.getElementById('skipApplyButton');
    const skipCancelButton = document.getElementById('skipCancelButton');
    
    // Store skipped nodes data
    let skippedNodesData = [];
    let selectedNodeIds = [];
    
    // Function to show the hierarchy skip modal
    function showHierarchySkipModal(skippedNodes) {
      // Store the data for later use
      skippedNodesData = skippedNodes;
      selectedNodeIds = []; // Reset selected nodes
      
      // Clear the list
      skipNodesList.innerHTML = '';
      
      // Create list items for each skipped node
      skippedNodes.forEach(node => {
        const item = document.createElement('div');
        item.className = 'skip-node-item';
        item.dataset.nodeId = node.id;
        
        // Create checkbox
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.className = 'skip-node-checkbox';
        checkbox.checked = true; // Default to checked
        selectedNodeIds.push(node.id); // Add to selected by default
        
        // Create info container
        const info = document.createElement('div');
        info.className = 'skip-node-info';
        
        // Create path display
        const path = document.createElement('div');
        path.className = 'skip-node-path';
        path.textContent = node.path;
        
        // Create change display with hierarchy tags
        const change = document.createElement('div');
        change.className = 'skip-node-change';
        
        // Helper function to get tag class from prefix
        function getTagClassFromPrefix(prefix) {
          const prefixMap = {
            'hero.': 'hero',
            'parent.': 'parent',
            'child.': 'child',
            'subChild.': 'subchild'
          };
          return prefixMap[prefix] || 'parent';
        }
        
        // Create from prefix tag
        const fromTagClass = getTagClassFromPrefix(node.currentPrefix);
        const fromPrefix = document.createElement('span');
        fromPrefix.className = `tag ${fromTagClass}`;
        fromPrefix.textContent = node.currentPrefix;
        
        // Create arrow
        const arrow = document.createElement('span');
        arrow.className = 'skip-node-arrow';
        arrow.textContent = 'â†’';
        
        // Create to prefix tag
        const toTagClass = getTagClassFromPrefix(node.suggestedPrefix);
        const toPrefix = document.createElement('span');
        toPrefix.className = `tag ${toTagClass}`;
        toPrefix.textContent = node.suggestedPrefix;
        
        // Assemble the elements
        change.appendChild(fromPrefix);
        change.appendChild(arrow);
        change.appendChild(toPrefix);
        
        info.appendChild(path);
        info.appendChild(change);
        
        item.appendChild(checkbox);
        item.appendChild(info);
        
        // Add click handler to toggle selection
        item.addEventListener('click', (e) => {
          // Don't toggle if clicking directly on the checkbox
          if (e.target !== checkbox) {
            checkbox.checked = !checkbox.checked;
            toggleNodeSelection(node.id, checkbox.checked);
          }
        });
        
        // Add change handler for checkbox
        checkbox.addEventListener('change', () => {
          toggleNodeSelection(node.id, checkbox.checked);
        });
        
        skipNodesList.appendChild(item);
      });
      
      // Show the modal with animation
      hierarchySkipModal.style.display = 'flex';
      // Trigger animation after display is set
      setTimeout(() => {
        hierarchySkipModal.classList.add('show');
      }, 10);
    }
    
    // Function to hide the hierarchy skip modal
    function hideHierarchySkipModal() {
      hierarchySkipModal.classList.remove('show');
      // Hide after animation completes
      setTimeout(() => {
        hierarchySkipModal.style.display = 'none';
      }, 200);
    }
    
    // Function to toggle node selection
    function toggleNodeSelection(nodeId, isSelected) {
      const item = document.querySelector(`.skip-node-item[data-node-id="${nodeId}"]`);
      
      if (isSelected) {
        item.classList.add('selected');
        if (!selectedNodeIds.includes(nodeId)) {
          selectedNodeIds.push(nodeId);
        }
      } else {
        item.classList.remove('selected');
        selectedNodeIds = selectedNodeIds.filter(id => id !== nodeId);
      }
    }
    
    // Skip Apply button handler
    skipApplyButton.addEventListener('click', () => {
      // Send the selected node IDs back to the plugin
      parent.postMessage({
        pluginMessage: {
          type: 'hierarchy-skip-response',
          nodesToRename: selectedNodeIds
        }
      }, '*');
      
      hideHierarchySkipModal();
    });
    
    // Skip Cancel button handler
    skipCancelButton.addEventListener('click', () => {
      hideHierarchySkipModal();
    });
    
    // Function to update layer name display with tag component
    function updateLayerNameDisplay(layerName, isReference = false) {
      // Clear the current display
      currentLayerName.innerHTML = '';
      
      // Define prefix mapping to tag class
      const prefixMap = {
        'hero.': 'hero',
        'parent.': 'parent',
        'child.': 'child',
        'subChild.': 'subchild'
      };
      
      // Check if the layer name has a recognized prefix
      let hasPrefix = false;
      for (const [prefix, tagClass] of Object.entries(prefixMap)) {
        if (layerName.startsWith(prefix)) {
          // Create tag element for prefix
          const tagSpan = document.createElement('span');
          tagSpan.className = isReference ? `tag reference ${tagClass}` : `tag ${tagClass}`;
          tagSpan.textContent = prefix;
          
          // Create text node for the rest of the name
          const nameSpan = document.createElement('span');
          nameSpan.textContent = layerName.substring(prefix.length);
          nameSpan.style.marginLeft = '6px';
          
          // Add both to the container
          currentLayerName.appendChild(tagSpan);
          currentLayerName.appendChild(nameSpan);
          
          hasPrefix = true;
          break;
        }
      }
      
      // If no recognized prefix, just display the name
      if (!hasPrefix) {
        currentLayerName.textContent = layerName;
      }
    }
    
    // Function to set dropdown section widths dynamically
    function setDropdownSectionWidths() {
      // Widths are now set in CSS as 100%, so this function can be simplified
      // or removed if no dynamic width calculation is needed
      // Keeping it for potential future use
    }

    // Helper function to get applicable prefixes based on parent
    // Returns { prefixes: array, autoEnabled: boolean }
    function getApplicablePrefixes(parentNode) {
      if (!parentNode) {
        // No parent - show all options but auto will be disabled
        return { prefixes: ['hero', 'parent', 'child', 'subchild', 'auto'], autoEnabled: false };
      }
      
      // Determine applicable prefixes based on parent prefix
      const parentName = parentNode.name || '';
      if (parentName.startsWith('parent.')) {
        return { prefixes: ['child', 'subChild', 'auto'], autoEnabled: true };
      } else if (parentName.startsWith('hero.')) {
        return { prefixes: ['child', 'subChild', 'auto'], autoEnabled: true };
      } else if (parentName.startsWith('child.')) {
        return { prefixes: ['subChild', 'auto'], autoEnabled: true };
      } else if (parentName.startsWith('subChild.')) {
        return { prefixes: ['auto'], autoEnabled: true };
      }
      
      // If parent has no recognized prefix, show all options but auto will be disabled
      return { prefixes: ['hero', 'parent', 'child', 'subchild', 'auto'], autoEnabled: false };
    }

    // Function to populate the dropdown with content
    function populateDropdown(dropdown, currentPrefix, isSetupMode = false) {
      // Find the tags section
      const tagsSection = dropdown.querySelector('.dropdown-tags-section');
      if (!tagsSection) return;
      
      // Clear existing content in tags section
      tagsSection.innerHTML = '';
      
      let prefixesToShow = [];
      let autoEnabled = true;
      
      if (isSetupMode) {
        // Setup mode: determine prefixes based on parent
        const result = getApplicablePrefixes(parentNode);
        prefixesToShow = result.prefixes;
        autoEnabled = result.autoEnabled;
        
        // In setup mode, reorder to put auto first (left side), then divider, then other prefixes
        const autoIndex = prefixesToShow.indexOf('auto');
        if (autoIndex !== -1) {
          // Remove auto from current position
          prefixesToShow.splice(autoIndex, 1);
          // Put auto at the beginning
          prefixesToShow.unshift('auto');
        }
      } else {
        // Adjust mode: show all prefixes except current
        const allPrefixes = ['hero', 'parent', 'child', 'subchild'];
        prefixesToShow = allPrefixes.filter(p => p !== currentPrefix);
        // Add auto option at the beginning (left side)
        prefixesToShow.unshift('auto');
      }
      
      // Container for auto button (left side in setup mode)
      const autoContainer = document.createElement('div');
      autoContainer.className = 'dropdown-auto-container';
      autoContainer.style.display = 'flex';
      autoContainer.style.alignItems = 'center';
      autoContainer.style.minWidth = '0'; // Allow flex shrinking
      autoContainer.style.maxWidth = '100%'; // Prevent exceeding container width
      autoContainer.style.boxSizing = 'border-box';
      // Make auto container fill available width when auto is enabled in setup mode
      if (isSetupMode && prefixesToShow.includes('auto') && autoEnabled) {
        autoContainer.style.flexGrow = '1';
        autoContainer.style.flexShrink = '1';
      }
      // In adjust mode, auto container should not take full width
      if (!isSetupMode) {
        autoContainer.style.flexShrink = '0';
      }
      
      // Tag wrapper container (right side in setup mode, right side in adjust mode after auto)
      // This has border-left which serves as the divider
      const tagWrapper = document.createElement('div');
      tagWrapper.className = 'dropdown-tag-wrapper';
      tagWrapper.style.display = 'flex';
      tagWrapper.style.alignItems = 'center';
      tagWrapper.style.gap = '4px';
      // In setup mode, tag wrapper should only take space it needs (not 100%)
      // In adjust mode, it should flex to fill remaining space after auto
      if (!isSetupMode) {
        tagWrapper.style.flexGrow = '1';
        tagWrapper.style.flexShrink = '1';
      } else {
        tagWrapper.style.flexShrink = '0'; // Don't shrink in setup mode
      }
      
      // Create prefix tags
      prefixesToShow.forEach((prefixType, index) => {
        const prefixTag = document.createElement('div');
        const isAuto = prefixType === 'auto';
        const prefixText = isAuto ? 'Auto' : `${prefixType}.`;
        
        // Normalize prefix type for class names (subChild -> subchild)
        const normalizedType = prefixType === 'subChild' ? 'subchild' : prefixType;
        prefixTag.className = `dropdown-prefix-tag ${normalizedType}`;
        prefixTag.textContent = prefixText;
        
        // Check if auto should be disabled in setup mode
        if (isSetupMode && isAuto && !autoEnabled) {
          prefixTag.classList.add('disabled');
          prefixTag.style.opacity = '0.4';
          prefixTag.style.cursor = 'not-allowed';
          prefixTag.style.pointerEvents = 'none';
        }
        
        // Make auto tag fill available space in container (only when enabled)
        if (isAuto && autoEnabled) {
          prefixTag.style.flexGrow = '1';
          prefixTag.style.flexShrink = '1';
          prefixTag.style.minWidth = '0'; // Allow flex shrinking
          prefixTag.style.maxWidth = '100%'; // Prevent exceeding container width
          prefixTag.style.boxSizing = 'border-box';
        }
        
        // Add click handler (only if not disabled)
        if (!(isSetupMode && isAuto && !autoEnabled)) {
          prefixTag.addEventListener('click', (e) => {
            e.stopPropagation();
            
            if (isSetupMode) {
              // Setup mode: single-select behavior
              // Deselect all other tags
              const allTags = tagsSection.querySelectorAll('.dropdown-prefix-tag');
              allTags.forEach(tag => {
                tag.classList.remove('selected');
              });
              
              // Select this tag
              prefixTag.classList.add('selected');
              
              // Store selection
              dropdownState.selectedPrefix = normalizedType;
              dropdownState.mode = isAuto ? 'auto-adjust' : 'setup';
              
              // Enable layout controls after selection (even though dropdown is still visible)
              const layoutContainer = document.querySelector('.layout-selection-container');
              // Check if we're in setup mode using getUIMode() for consistency
              const currentMode = getUIMode();
              if (layoutContainer && currentMode === 'setup') {
                // Re-apply active state to all layout buttons
                const cornerButtons = layoutContainer.querySelectorAll('.btn-layout-corner-radius');
                cornerButtons.forEach(button => {
                  button.classList.add('active');
                  button.classList.remove('inactive');
                });
                
                const paddingButtons = layoutContainer.querySelectorAll('.btn-layout-padding');
                paddingButtons.forEach(button => {
                  button.classList.add('active');
                  button.classList.remove('inactive');
                });
                
                const nestedButton = layoutContainer.querySelector('.btn-layout-nested');
                if (nestedButton) {
                  nestedButton.classList.add('active');
                  nestedButton.classList.remove('inactive');
                }
              }
              
              // Update UI state - enables layout even though dropdown is visible (user selected prefix)
              updateUIState('(after prefix selection in setup mode)', { forceLayoutEnabled: true });
            } else {
              // Adjust mode: navigate to options section
              if (isAuto) {
                dropdownState.mode = 'auto-adjust';
                dropdownState.selectedPrefix = null;
              } else {
                dropdownState.mode = 'prefix-rename';
                dropdownState.selectedPrefix = normalizedType;
              }
              showOptionButtons();
              
              // Update button states after prefix selection
              updateAllButtonStates('(after prefix selection in adjust mode)');
            }
          });
        }
        
        // Append to appropriate container
        if (isAuto) {
          // Auto goes in autoContainer (left side) in both setup and adjust mode
          autoContainer.appendChild(prefixTag);
        } else {
          // Other prefixes go in tagWrapper (right side)
          tagWrapper.appendChild(prefixTag);
        }
      });
      
      // Append elements to tags section
      if (prefixesToShow.includes('auto')) {
        // Add auto container first (left side), then tag wrapper (right side) if there are other prefixes
        tagsSection.appendChild(autoContainer);
        if (prefixesToShow.length > 1) {
          tagsSection.appendChild(tagWrapper);
        }
      } else {
        // No auto option, just add tag wrapper
        tagsSection.appendChild(tagWrapper);
      }
      
      // Set dropdown section widths dynamically
      setDropdownSectionWidths();
    }

    // Function to show option buttons
    function showOptionButtons() {
      const tagsSection = document.getElementById('devActiveTagsSection');
      const optionsSection = document.getElementById('devActiveOptionsSection');
      
      if (tagsSection && optionsSection) {
        // Slide tags section to the left (out of view)
        tagsSection.style.left = '-100%';
        
        // Slide options section to left: 0 (into view)
        optionsSection.style.left = '0';
      }
    }

    // Function to hide option buttons
    function hideOptionButtons() {
      const tagsSection = document.getElementById('devActiveTagsSection');
      const optionsSection = document.getElementById('devActiveOptionsSection');
      
      if (tagsSection && optionsSection) {
        // Slide tags section back to left: 0 (into view)
        tagsSection.style.left = '0';
        
        // Slide options section to the right (out of view)
        optionsSection.style.left = '100%';
      }
    }

    // Toggle button state tracking
    let toggleStates = {
      renameNested: false,
      applyAfter: false
    };

    // Dropdown state tracking
    let dropdownState = {
      mode: null, // 'auto-adjust', 'prefix-rename', or 'setup'
      selectedPrefix: null, // e.g., 'hero', 'parent', 'child', 'subchild', 'auto'
      setupMode: false // true when frame has no prefix and is in setup mode
    };

    // Determine current UI mode based on state
    // Primary indicator: bound variables (simpler and more reliable than prefix/state flags)
    function getUIMode() {
      if (!selectedNode) return 'none';
      
      // Check for spacing mode (row/column directional extension)
      if (currentDirectionalExtension === 'row.' || currentDirectionalExtension === 'column.') {
        return 'spacing';
      }
      
      // Primary mode detection: use bound variables
      // If variables are bound â†’ adjust mode (can adjust/clear)
      // If no variables are bound â†’ setup mode (need to set up)
      const hasVariables = hasVariablesSet(currentVariableBindings);
      
      if (hasVariables) {
        return 'adjust';
      } else {
        return 'setup';
      }
    }

    // Centralized function to update all UI component states
    function updateUIState(debugContext = '', options = {}) {
      const {
        forceDropdownVisible = false,
        forceDropdownHidden = false,
        forceLayoutEnabled = false,
        forceLayoutDisabled = false
      } = options;

      const dropdown = document.getElementById('devActiveDropdown');
      const layoutContainer = document.querySelector('.layout-selection-container');
      const spacingControlContainer = document.getElementById('spacingControlContainer');
      const layoutSelectionContainer = document.getElementById('layoutSelectionContainer');
      const variableModeControlSection = document.getElementById('variableModeControlSection');
      
      // Determine current UI mode
      const currentMode = getUIMode();
      
      // Calculate desired states based on mode
      let shouldShowDropdown = false;
      let shouldEnableLayout = false;
      let shouldShowSpacingControl = false;
      let shouldShowLayoutControl = false;
      let shouldShowOptionButtons = false;
      
      // Calculate spacing/layout control visibility based on mode (independent of dropdown state)
      if (currentMode === 'spacing') {
        shouldShowSpacingControl = true;
        shouldShowLayoutControl = false;
      } else if (currentMode === 'setup' || currentMode === 'adjust') {
        shouldShowSpacingControl = false;
        shouldShowLayoutControl = true;
      } else {
        // 'none' mode
        shouldShowSpacingControl = false;
        shouldShowLayoutControl = false;
      }
      
      // Show variable mode control section only in adjust mode
      if (variableModeControlSection) {
        variableModeControlSection.style.display = currentMode === 'adjust' ? 'block' : 'none';
        
        // If showing in adjust mode, get variable modes for the selected frame and load available modes
        if (currentMode === 'adjust' && selectedNode) {
          getVariableModesForSelection();
          // Load available modes for all collections when entering adjust mode
          loadAllAvailableModes();
        }
      }
      
      // Override with forced values if provided
      if (forceDropdownVisible) shouldShowDropdown = true;
      if (forceDropdownHidden) shouldShowDropdown = false;
      if (forceLayoutEnabled) shouldEnableLayout = true;
      if (forceLayoutDisabled) shouldEnableLayout = false;
      
      // Calculate dropdown and layout states based on mode if not forced
      if (!forceDropdownVisible && !forceDropdownHidden) {
        if (currentMode === 'setup') {
          shouldShowDropdown = true;
          if (!forceLayoutEnabled && !forceLayoutDisabled) {
            shouldEnableLayout = false;
          }
        } else if (currentMode === 'adjust') {
          // In adjust mode, dropdown visibility is controlled by user interaction
          // Check current state - if dropdown is visible, keep it visible
          shouldShowDropdown = dropdown ? dropdown.classList.contains('show') : false;
          if (!forceLayoutEnabled && !forceLayoutDisabled) {
            shouldEnableLayout = !shouldShowDropdown; // Disable layout when dropdown is open
          }
        } else if (currentMode === 'spacing') {
          shouldShowDropdown = false;
          if (!forceLayoutEnabled && !forceLayoutDisabled) {
            shouldEnableLayout = true;
          }
        } else {
          // 'none' mode
          shouldShowDropdown = false;
          if (!forceLayoutEnabled && !forceLayoutDisabled) {
            shouldEnableLayout = false;
          }
        }
      }
      
      // Option buttons visibility: only show in adjust mode when dropdown is visible and a prefix is selected
      // In setup mode, option buttons should NOT be shown (user selects prefix and applies variables directly)
      shouldShowOptionButtons = shouldShowDropdown && currentMode === 'adjust' && dropdownState.mode !== null;
      
      // Apply dropdown visibility and populate if needed
      if (dropdown) {
        const wasVisible = dropdown.classList.contains('show');
        const tagsSection = dropdown.querySelector('.dropdown-tags-section');
        const isEmpty = tagsSection ? tagsSection.innerHTML.trim() === '' : true;
        
        if (shouldShowDropdown) {
          // If dropdown is being shown and wasn't visible before, populate it
          // Also populate if it's empty (in case it was cleared)
          if (!wasVisible || isEmpty) {
            if (currentMode === 'setup') {
              // Setup mode: populate with setup mode content
              populateDropdown(dropdown, null, true);
              setupOptionButtonListeners();
            } else if (currentMode === 'adjust') {
              // Adjust mode: populate with adjust mode content
              // Extract current prefix from selectedNode name
              let currentPrefix = null;
              if (selectedNode) {
                const prefixMap = {
                  'hero.': 'hero',
                  'parent.': 'parent',
                  'child.': 'child',
                  'subChild.': 'subchild'
                };
                for (const [prefix, tagClass] of Object.entries(prefixMap)) {
                  if (selectedNode.name.startsWith(prefix)) {
                    currentPrefix = tagClass;
                    break;
                  }
                }
              }
              populateDropdown(dropdown, currentPrefix, false);
              setupOptionButtonListeners();
            }
          }
          dropdown.classList.add('show');
          // Hide any visible plus buttons when dropdown is shown
          const visibleAddButtons = document.querySelectorAll('.directional-add-btn.show');
          visibleAddButtons.forEach(btn => btn.classList.remove('show'));
        } else {
          dropdown.classList.remove('show');
        }
      }
      
      // Apply layout container state
      if (layoutContainer) {
        if (shouldEnableLayout) {
          layoutContainer.classList.remove('disabled');
        } else {
          layoutContainer.classList.add('disabled');
        }
      }
      
      // Apply variable mode control section state (disabled when dropdown is visible, same as layout)
      if (variableModeControlSection) {
        if (shouldEnableLayout) {
          variableModeControlSection.classList.remove('disabled');
        } else {
          variableModeControlSection.classList.add('disabled');
        }
      }
      
      // Apply spacing/layout control visibility
      if (spacingControlContainer) {
        spacingControlContainer.style.display = shouldShowSpacingControl ? 'flex' : 'none';
        if (shouldShowSpacingControl) {
          // Update dynamic widths when showing spacing control
          updateSpacingControlWidths();
        }
      }
      
      if (layoutSelectionContainer) {
        layoutSelectionContainer.style.display = shouldShowLayoutControl ? 'flex' : 'none';
      }
      
      // Apply option buttons visibility
      if (shouldShowOptionButtons) {
        showOptionButtons();
      } else {
        hideOptionButtons();
      }
      
      // Update button states after UI state is updated
      updateAllButtonStates(`(via updateUIState${debugContext ? `: ${debugContext}` : ''})`);
    }

    // Add event listeners for option buttons
    function setupOptionButtonListeners() {
      const optionsSection = document.getElementById('devActiveOptionsSection');
      if (optionsSection) {
        const buttons = optionsSection.querySelectorAll('.dropdown-option-btn, .dropdown-chevron-btn');
        buttons.forEach(button => {
          // Remove existing listeners to avoid duplicates
          const newButton = button.cloneNode(true);
          button.parentNode.replaceChild(newButton, button);
          
          newButton.addEventListener('click', (e) => {
            e.stopPropagation();
            const action = newButton.getAttribute('data-action');
            
            switch(action) {
              case 'back':
                hideOptionButtons();
                break;
              case 'fix-nested':
                // Toggle selected state
                toggleStates.renameNested = !toggleStates.renameNested;
                if (toggleStates.renameNested) {
                  newButton.classList.add('selected');
                } else {
                  newButton.classList.remove('selected');
                }
                break;
              case 'fix-variables':
                // Toggle selected state
                toggleStates.applyAfter = !toggleStates.applyAfter;
                if (toggleStates.applyAfter) {
                  newButton.classList.add('selected');
                } else {
                  newButton.classList.remove('selected');
                }
                break;
              case 'apply':
                // Read stored mode and toggle states
                const mode = dropdownState.mode;
                const renameNested = toggleStates.renameNested;
                const applyAfter = toggleStates.applyAfter;
                
                if (!selectedNode) {
                  showMessage('No layer selected. Select a layer in Figma first.', 'error');
                  return;
                }
                
                if (mode === 'auto-adjust') {
                  // Send auto-adjust message
                  showLoading(true, 'Auto adjusting hierarchy');
                  parent.postMessage({
                    pluginMessage: {
                      type: 'auto-adjust',
                      nodeId: selectedNode.id,
                      applyAfter: applyAfter,
                      renameNested: renameNested
                    }
                  }, '*');
                  // Reset toggle states
                  toggleStates.renameNested = false;
                  toggleStates.applyAfter = false;
                  // Reset toggle button visuals
                  const fixNestedBtn = optionsSection.querySelector('[data-action="fix-nested"]');
                  const fixVariablesBtn = optionsSection.querySelector('[data-action="fix-variables"]');
                  if (fixNestedBtn) fixNestedBtn.classList.remove('selected');
                  if (fixVariablesBtn) fixVariablesBtn.classList.remove('selected');
                  // Update UI state - closes dropdown and enables layout
                  updateUIState('(after dropdown close in auto-adjust)');
                } else if (mode === 'prefix-rename') {
                  // Send rename-node message
                  const selectedPrefix = dropdownState.selectedPrefix;
                  
                  if (!selectedPrefix) {
                    showMessage('No prefix selected.', 'error');
                    return;
                  }
                  
                  // Get base name without prefix
                  let baseName = selectedNode.name;
                  
                  for (const existingPrefix of ['parent.', 'child.', 'subChild.', 'hero.']) {
                    if (baseName.startsWith(existingPrefix)) {
                      baseName = baseName.substring(existingPrefix.length);
                      break;
                    }
                  }
                  
                  // Map prefix type to prefix string
                  const prefixMap = {
                    'hero': 'hero.',
                    'parent': 'parent.',
                    'child': 'child.',
                    'subchild': 'subChild.'
                  };
                  const newName = `${prefixMap[selectedPrefix]}${baseName}`;
                  
                  showLoading(true, 'Renaming layer');
                  parent.postMessage({
                    pluginMessage: {
                      type: 'rename-node',
                      nodeId: selectedNode.id,
                      newName: newName,
                      applyAfter: applyAfter,
                      renameNested: renameNested
                    }
                  }, '*');
                  // Reset toggle states
                  toggleStates.renameNested = false;
                  toggleStates.applyAfter = false;
                  // Reset toggle button visuals
                  const fixNestedBtn = optionsSection.querySelector('[data-action="fix-nested"]');
                  const fixVariablesBtn = optionsSection.querySelector('[data-action="fix-variables"]');
                  if (fixNestedBtn) fixNestedBtn.classList.remove('selected');
                  if (fixVariablesBtn) fixVariablesBtn.classList.remove('selected');
                  // Update UI state - closes dropdown and enables layout
                  updateUIState('(after dropdown close in auto-adjust)');
                } else {
                  showMessage('Please select Auto or a prefix first.', 'error');
                }
                break;
            }
          });
        });
      }
    }

    // Function to create an "Adjust" action tag
    function createAdjustActionTag() {
      const tagSpan = document.createElement('span');
      tagSpan.className = 'tag action adjust';
      
      // Create prefix container
      const prefixSpan = document.createElement('span');
      prefixSpan.className = 'tag-prefix';
      prefixSpan.textContent = 'Adjust';
      
      // Create chevron container
      const chevronSpan = document.createElement('span');
      chevronSpan.className = 'tag-chevron';
      chevronSpan.innerHTML = `
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="none">
          <path d="M4 6L8 10L12 6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
      `;
      
      tagSpan.appendChild(prefixSpan);
      tagSpan.appendChild(chevronSpan);
      
      return tagSpan;
    }

    // Function to create a structure item element with tag and layer name
    function createStructureItem(layerName, useReferenceTag = false, nestingLevel = 1, isActionTag = false, childrenData = null, isNestedSection = false, nodeId = null, hasPaddingOrCornerRadius = false, layoutDirection = null) {
      
      // Create wrapper for the entire item (includes nested children)
      const itemWrapper = document.createElement('div');
      itemWrapper.className = 'structure-item-wrapper';
      itemWrapper.style.cssText = 'width: 100%; max-width: 100%; min-height: min-content; display: flex; flex-direction: column; box-sizing: border-box;';
      
      const itemDiv = document.createElement('div');
      itemDiv.className = isActionTag ? 'structure-item action-item' : 'structure-item';
      
      // Set nesting level for tree structure
      if (nestingLevel > 1) {
        itemDiv.setAttribute('data-level', nestingLevel);
      }
      
      // Define prefix mapping to tag class
      const prefixMap = {
        'hero.': 'hero',
        'parent.': 'parent',
        'child.': 'child',
        'subChild.': 'subchild'
      };
      
      // Helper function to extract directional extension (row. or column.) that comes immediately after the prefix
      function getDirectionalExtension(name, prefix) {
        // Remove the prefix to check what comes after it
        const nameAfterPrefix = name.substring(prefix.length);
        
        // Check if the name after prefix starts with row. or column.
        if (nameAfterPrefix.startsWith('row.')) {
          return 'row.';
        }
        if (nameAfterPrefix.startsWith('column.')) {
          return 'column.';
        }
        return null;
      }
      
      // Helper function to get base name without prefix and directional extension
      function getBaseName(name, prefix, directionalExt) {
        let nameWithoutPrefix = name.substring(prefix.length);
        if (directionalExt && nameWithoutPrefix.startsWith(directionalExt)) {
          nameWithoutPrefix = nameWithoutPrefix.substring(directionalExt.length);
        }
        return nameWithoutPrefix;
      }
      
      // Check if the layer name has a recognized prefix
      let hasPrefix = false;
      for (const [prefix, tagClass] of Object.entries(prefixMap)) {
        if (layerName.startsWith(prefix)) {
          
          // Extract directional extension if present (must come immediately after prefix)
          const directionalExt = getDirectionalExtension(layerName, prefix);
          const baseName = getBaseName(layerName, prefix, directionalExt);
          
             if (isActionTag) {
               // Create action tag with dropdown
               const tagSpan = document.createElement('span');
               tagSpan.className = useReferenceTag ? `tag reference action ${tagClass}` : `tag action ${tagClass}`;

               // Create prefix container
               const prefixSpan = document.createElement('span');
               prefixSpan.className = 'tag-prefix';
               prefixSpan.textContent = prefix;

               // Create chevron container
               const chevronSpan = document.createElement('span');
               chevronSpan.className = 'tag-chevron';
               chevronSpan.innerHTML = `
                 <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="none">
                   <path d="M4 6L8 10L12 6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                 </svg>
               `;

               tagSpan.appendChild(prefixSpan);
               tagSpan.appendChild(chevronSpan);

               // Add hierarchy tag to the item
               itemDiv.appendChild(tagSpan);

               // Add plus icon button for adding directional prefix (only if padding AND corner radius are both 0/not bound, and no directional extension exists)
               // Position it between the hierarchy tag and layer name
               // Note: hasPrefix check removed - button shows even without prefix (user can add prefix first via dropdown)
               if (!directionalExt && !hasPaddingOrCornerRadius && nodeId) {
                 const addBtn = document.createElement('button');
                 addBtn.className = 'directional-add-btn';
                 addBtn.setAttribute('aria-label', 'Add directional prefix');
                 // Determine text based on layout direction (default to 'row' if not available)
                 const directionText = layoutDirection === 'column' ? 'Column.' : 'Row.';
                 addBtn.innerHTML = `
                   <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 12 12" fill="none">
                     <path d="M6 3V9M3 6H9" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                   </svg>
                   <span class="directional-add-text">${directionText}</span>
                 `;
                 addBtn.addEventListener('click', (e) => {
                   e.stopPropagation();
                   if (nodeId) {
                     parent.postMessage({
                       pluginMessage: {
                         type: 'add-directional-prefix',
                         nodeId: nodeId
                       }
                     }, '*');
                   }
                 });
                 itemDiv.appendChild(addBtn);
                 
                 // Add hover handlers with 400ms delay
                 let hoverTimeout = null;
                 itemDiv.addEventListener('mouseenter', () => {
                   // Check if dropdown is active - if so, don't show the plus button
                   const dropdown = document.getElementById('devActiveDropdown');
                   if (dropdown && dropdown.classList.contains('show')) {
                     return;
                   }
                   hoverTimeout = setTimeout(() => {
                     addBtn.classList.add('show');
                   }, 400);
                 });
                 itemDiv.addEventListener('mouseleave', () => {
                   if (hoverTimeout) {
                     clearTimeout(hoverTimeout);
                     hoverTimeout = null;
                   }
                   addBtn.classList.remove('show');
                 });
               }

               // Add directional extension tag if present (after hierarchy tag)
               if (directionalExt) {
                 const directionalTag = document.createElement('span');
                 directionalTag.className = useReferenceTag ? 'tag reference directional' : 'tag directional';
                 directionalTag.textContent = directionalExt;
                 
                 // Add X icon button for removing directional prefix
                 const removeBtn = document.createElement('button');
                 removeBtn.className = 'directional-remove-btn';
                 removeBtn.setAttribute('aria-label', 'Remove directional prefix');
                 removeBtn.innerHTML = `
                   <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 12 12" fill="none">
                     <path d="M9 3L3 9M3 3L9 9" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                   </svg>
                 `;
                 removeBtn.addEventListener('click', (e) => {
                   e.stopPropagation();
                   if (nodeId) {
                     parent.postMessage({
                       pluginMessage: {
                         type: 'remove-directional-prefix',
                         nodeId: nodeId
                       }
                     }, '*');
                   }
                 });
                 directionalTag.appendChild(removeBtn);
                 
                 itemDiv.appendChild(directionalTag);
               }

               // Create layer name element
               const nameSpan = document.createElement('span');
               nameSpan.className = 'layer-name';
               nameSpan.textContent = baseName;

               // Add layer name to the item
               itemDiv.appendChild(nameSpan);

               // Add click handler to toggle dropdown
               tagSpan.addEventListener('click', (e) => {
                 e.stopPropagation();
                 // Find the dropdown container
                 const dropdown = document.getElementById('devActiveDropdown');
                 if (dropdown) {
                  const isCurrentlyVisible = dropdown.classList.contains('show');
                  
                  if (!isCurrentlyVisible) {
                    // Show dropdown and populate it
                    populateDropdown(dropdown, tagClass);
                    // Setup option button listeners
                    setupOptionButtonListeners();
                    // Update UI state - shows dropdown and disables layout
                    updateUIState('(dropdown show via action tag click)', { forceDropdownVisible: true });
                    // Change tag to adjust class and text
                    tagSpan.className = useReferenceTag ? `tag reference action adjust` : `tag action adjust`;
                    const prefixSpan = tagSpan.querySelector('.tag-prefix');
                    if (prefixSpan) {
                      prefixSpan.textContent = 'Adjust';
                    }
                  } else {
                    // Update UI state - hides dropdown and enables layout
                    updateUIState('(dropdown hide via action tag click)', { forceDropdownHidden: true, forceLayoutEnabled: true });
                    // Change tag back to original class and text
                    tagSpan.className = useReferenceTag ? `tag reference action ${tagClass}` : `tag action ${tagClass}`;
                    const prefixSpan = tagSpan.querySelector('.tag-prefix');
                    if (prefixSpan) {
                      prefixSpan.textContent = prefix;
                    }
                  }
                 }
               });
          } else {
            // Create regular tag element
            const tagSpan = document.createElement('span');
            tagSpan.className = useReferenceTag ? `tag reference ${tagClass}` : `tag ${tagClass}`;
            tagSpan.textContent = prefix;
            
            // Add both to the item
            itemDiv.appendChild(tagSpan);
            
            // Add plus icon button for adding directional prefix (only if padding AND corner radius are both 0/not bound, and no directional extension exists)
            // Position it between the hierarchy tag and layer name
            // Note: hasPrefix check removed - button shows even without prefix (user can add prefix first via dropdown)
            if (!directionalExt && !hasPaddingOrCornerRadius && nodeId) {
              const addBtn = document.createElement('button');
              addBtn.className = 'directional-add-btn';
              addBtn.setAttribute('aria-label', 'Add directional prefix');
              // Determine text based on layout direction (default to 'row' if not available)
              const directionText = layoutDirection === 'column' ? 'Column.' : 'Row.';
              addBtn.innerHTML = `
                <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 12 12" fill="none">
                  <path d="M6 3V9M3 6H9" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
                <span class="directional-add-text">${directionText}</span>
              `;
              addBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                if (nodeId) {
                  parent.postMessage({
                    pluginMessage: {
                      type: 'add-directional-prefix',
                      nodeId: nodeId
                    }
                  }, '*');
                }
              });
              itemDiv.appendChild(addBtn);
              
              // Add hover handlers with 400ms delay
              let hoverTimeout = null;
              itemDiv.addEventListener('mouseenter', () => {
                // Check if dropdown is active - if so, don't show the plus button
                const dropdown = document.getElementById('devActiveDropdown');
                if (dropdown && dropdown.classList.contains('show')) {
                  return;
                }
                hoverTimeout = setTimeout(() => {
                  addBtn.classList.add('show');
                }, 400);
              });
              itemDiv.addEventListener('mouseleave', () => {
                if (hoverTimeout) {
                  clearTimeout(hoverTimeout);
                  hoverTimeout = null;
                }
                addBtn.classList.remove('show');
              });
            }
            
            // Add directional extension tag if present
            if (directionalExt) {
              const directionalTag = document.createElement('span');
              directionalTag.className = useReferenceTag ? 'tag reference directional' : 'tag directional';
              directionalTag.textContent = directionalExt;
              
              // Add X icon button for removing directional prefix
              const removeBtn = document.createElement('button');
              removeBtn.className = 'directional-remove-btn';
              removeBtn.setAttribute('aria-label', 'Remove directional prefix');
              removeBtn.innerHTML = `
                <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 12 12" fill="none">
                  <path d="M9 3L3 9M3 3L9 9" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
              `;
              removeBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                if (nodeId) {
                  parent.postMessage({
                    pluginMessage: {
                      type: 'remove-directional-prefix',
                      nodeId: nodeId
                    }
                  }, '*');
                }
              });
              directionalTag.appendChild(removeBtn);
              
              itemDiv.appendChild(directionalTag);
            }
            
            // Create layer name element
            const nameSpan = document.createElement('span');
            nameSpan.className = 'layer-name';
            nameSpan.textContent = baseName;
            
            // Add layer name to the item
            itemDiv.appendChild(nameSpan);
            
            // Add nested count and collapse control only for top-level items (level 1) in nested section
            if (isNestedSection && nestingLevel === 1 && childrenData && (childrenData.hasChildren || (childrenData.children && childrenData.children.length > 0))) {
              // Add nested count
              const countSpan = document.createElement('span');
              countSpan.className = 'structure-item-nested-count';
              const count = childrenData.nestedCount || (childrenData.children ? childrenData.children.length : 0);
              countSpan.textContent = count > 0 ? `${count}` : '';
              itemDiv.appendChild(countSpan);
              
              // Add collapse control (chevron) after the count - only for top-level items
              const collapseBtn = document.createElement('div');
              collapseBtn.className = 'structure-item-collapse';
              collapseBtn.innerHTML = `
                <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 12 12" fill="none">
                  <path d="M3 4.5L6 7.5L9 4.5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
              `;
              itemDiv.appendChild(collapseBtn);
              
              // Add collapsed class by default to wrapper
              itemWrapper.classList.add('collapsed');
              
              // Add click handler to toggle collapse on wrapper - independent control
              collapseBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                // Only toggle this specific wrapper's state, don't affect children
                const isCurrentlyCollapsed = itemWrapper.classList.contains('collapsed');
                if (isCurrentlyCollapsed) {
                  itemWrapper.classList.remove('collapsed');
                  itemWrapper.classList.add('expanded');
                } else {
                  itemWrapper.classList.remove('expanded');
                  itemWrapper.classList.add('collapsed');
                }
              });
            }
          }
          
          hasPrefix = true;
          break;
        }
      }
      
      // If no recognized prefix, handle setup mode or just display the name
      if (!hasPrefix) {
        
        if (isActionTag) {
          // Create "Set up" action tag with dropdown
          const tagSpan = document.createElement('span');
          tagSpan.className = useReferenceTag ? `tag reference action setup` : `tag action setup`;

          // Create prefix container
          const prefixSpan = document.createElement('span');
          prefixSpan.className = 'tag-prefix';
          prefixSpan.textContent = 'Set up';

          // Don't create chevron in setup mode - dropdown stays open
          tagSpan.appendChild(prefixSpan);

          // Create layer name element
          const nameSpan = document.createElement('span');
          nameSpan.className = 'layer-name';
          nameSpan.textContent = layerName;

          // Add both to the item
          itemDiv.appendChild(tagSpan);
          itemDiv.appendChild(nameSpan);

          // In setup mode, dropdown stays open - no click handler to toggle
          // Dropdown is auto-shown and remains open until prefix is selected and applied
        } else {
          // Create regular name display for non-action tags
          const nameSpan = document.createElement('span');
          nameSpan.className = 'layer-name';
          nameSpan.textContent = layerName;
          itemDiv.appendChild(nameSpan);
        }
      }
      
      // Add itemDiv to wrapper first (parent row)
      itemWrapper.appendChild(itemDiv);
      
      // Add nested children container to wrapper after itemDiv (children below parent)
      // Only add collapse/expand functionality for top-level items (level 1)
      if (isNestedSection && childrenData && (childrenData.hasChildren || (childrenData.children && childrenData.children.length > 0))) {
        // Create nested children container
        const nestedChildrenContainer = document.createElement('div');
        nestedChildrenContainer.className = 'structure-item-nested-children';
        
        // Populate nested children if they exist
        if (childrenData.children && childrenData.children.length > 0) {
          childrenData.children.forEach((nestedChild) => {
            // Only include nested children that have prefixes (filter out items without prefixes)
            const hasPrefix = nestedChild.name.startsWith('child.') || nestedChild.name.startsWith('subChild.') || 
                             nestedChild.name.startsWith('parent.') || nestedChild.name.startsWith('hero.');
            
            if (!hasPrefix) {
              return; // Skip items without prefixes
            }
            
            // Create nested child item - no collapse controls for nested children (nestingLevel > 1)
            const nestedItem = createStructureItem(
              nestedChild.name, 
              useReferenceTag, 
              nestedChild.level || nestingLevel + 1, 
              false, 
              nestedChild, 
              isNestedSection,
              nestedChild.id || null,
              false // hasPaddingBindings - nested items don't have this info
            );
            
            // Nested children are always shown when parent is expanded (no collapse controls for nested children)
            // Force expanded state so nested children are visible
            nestedItem.classList.remove('collapsed');
            nestedItem.classList.add('expanded');
            
            // Ensure nested children container is visible for nested items
            const nestedChildrenContainerInItem = nestedItem.querySelector('.structure-item-nested-children');
            if (nestedChildrenContainerInItem) {
              nestedChildrenContainerInItem.style.display = 'block';
            }
            
            nestedChildrenContainer.appendChild(nestedItem);
          });
        }
        
        // Only append nested children container if it has children (after filtering)
        if (nestedChildrenContainer.children.length > 0) {
          // Append nested children container after itemDiv (below parent)
          itemWrapper.appendChild(nestedChildrenContainer);
        }
      }
      
      return itemWrapper;
    }
    
    // Function to update parent layer name display with reference tag
    function updateParentLayerDisplay(parentName) {
      // Clear the current display
      parentLayerName.innerHTML = '';
      
      // Add "Inside: " prefix
      const insideText = document.createElement('span');
      insideText.textContent = 'Inside: ';
      insideText.style.color = '#888';
      parentLayerName.appendChild(insideText);
      
      // Define prefix mapping to tag class
      const prefixMap = {
        'hero.': 'hero',
        'parent.': 'parent',
        'child.': 'child',
        'subChild.': 'subchild'
      };
      
      // Check if parent has a recognized prefix
      let hasPrefix = false;
      for (const [prefix, tagClass] of Object.entries(prefixMap)) {
        if (parentName.startsWith(prefix)) {
          // Create reference tag for parent prefix
          const tagSpan = document.createElement('span');
          tagSpan.className = `tag reference ${tagClass}`;
          tagSpan.textContent = prefix;
          
          // Create text node for the rest of parent name
          const nameSpan = document.createElement('span');
          nameSpan.textContent = parentName.substring(prefix.length);
          nameSpan.style.marginLeft = '4px';
          
          // Add both to parent display
          parentLayerName.appendChild(tagSpan);
          parentLayerName.appendChild(nameSpan);
          
          hasPrefix = true;
          break;
        }
      }
      
      // If no recognized prefix, just display parent name
      if (!hasPrefix) {
        const nameSpan = document.createElement('span');
        nameSpan.textContent = parentName;
        parentLayerName.appendChild(nameSpan);
      }
      
      parentLayerName.style.display = 'block';
    }
    
    // Function to update development UI sections with current selection
    function updateDevelopmentUI(selectedNode, parentNode, childNodes, directionalExtension, layoutDirection = null) {
      const devInsideItem = document.getElementById('devInsideItem');
      const devActiveItem = document.getElementById('devActiveItem');
      const devNestedContainer = document.getElementById('devNestedContainer');
      
      // Clear all sections
      devInsideItem.innerHTML = '';
      devActiveItem.innerHTML = '';
      devNestedContainer.innerHTML = '';
      
      // Request current variable mode from A3 â†”ï¸ Spacing collection if in spacing mode
      if (selectedNode && (directionalExtension === 'row.' || directionalExtension === 'column.')) {
        parent.postMessage({
          pluginMessage: {
            type: 'get-spacing-variable-mode',
            nodeId: selectedNode.id
          }
        }, '*');
      }
      
      if (!selectedNode) {
        // No selection - clear everything and update UI state
        updateUIState('(no selection in updateDevelopmentUI)', { forceDropdownHidden: true, forceLayoutDisabled: true });
        return;
      }
      
      // Reset dropdown state (will be determined by bound variables now)
      dropdownState.setupMode = false;
      dropdownState.selectedPrefix = null;
      dropdownState.mode = null;
      
      // Check if padding variables are bound
      const hasPadding = currentVariableBindings && currentVariableBindings.padding && (
        currentVariableBindings.padding.top ||
        currentVariableBindings.padding.bottom ||
        currentVariableBindings.padding.left ||
        currentVariableBindings.padding.right
      );
      
      // Check if corner radius variables are bound
      const hasCornerRadius = currentVariableBindings && currentVariableBindings.corners && (
        currentVariableBindings.corners.topLeft ||
        currentVariableBindings.corners.topRight ||
        currentVariableBindings.corners.bottomLeft ||
        currentVariableBindings.corners.bottomRight
      );
      
      // Show plus button when padding AND corner radius are both 0 (no variables bound)
      // Pass false (hasPaddingOrCornerRadius = false) when we CAN add directional prefix
      const hasPaddingOrCornerRadius = hasPadding || hasCornerRadius;
      
      // Update active section with selected layer (use action tags for active selection)
      const activeItem = createStructureItem(selectedNode.name, false, 1, true, null, false, selectedNode.id, hasPaddingOrCornerRadius, layoutDirection);
      devActiveItem.appendChild(activeItem);
      
      // Determine mode based on bound variables (simplified logic)
      const hasVariables = hasVariablesSet(currentVariableBindings);
      
      if (!hasVariables) {
        // Setup mode: no variables bound - show dropdown with setup options
        // Small delay to ensure DOM is ready
        setTimeout(() => {
          // Update UI state - this will detect setup mode and show dropdown
          updateUIState('(setup mode in updateDevelopmentUI)');
          
          // Auto-select all layout buttons in setup mode
          // Select all corner radius buttons
          const cornerButtons = document.querySelectorAll('.btn-layout-corner-radius');
          cornerButtons.forEach(button => {
            button.classList.add('active');
            button.classList.remove('inactive');
          });
          
          // Select all padding buttons
          const paddingButtons = document.querySelectorAll('.btn-layout-padding');
          paddingButtons.forEach(button => {
            button.classList.add('active');
            button.classList.remove('inactive');
          });
          
          // Select nested button
          const nestedButton = document.querySelector('.btn-layout-nested');
          if (nestedButton) {
            nestedButton.classList.add('active');
            nestedButton.classList.remove('inactive');
          }
          
          // Update button text after auto-selecting buttons
          updateApplyVariablesButtonText();
        }, 10);
      } else {
        // Adjust mode: variables are bound - hide dropdown, enable layout
        updateUIState('(adjust mode in updateDevelopmentUI)', { forceDropdownHidden: true, forceLayoutEnabled: true });
      }
      
      // Update inside section with parent layer (if exists)
      if (parentNode) {
        const insideItem = createStructureItem(parentNode.name, true, 1, false, null, false, parentNode.id, false);
        devInsideItem.appendChild(insideItem);
      } else {
        // Show empty state when no parent level structures are available
        devInsideItem.innerHTML = '';
        const emptyState = document.createElement('div');
        emptyState.className = 'structure-item-empty';
        emptyState.style.cssText = 'color: var(--text-neutral-secondary, rgba(255, 255, 255, 0.60)); font-size: 12px; padding: 0 4px;';
        emptyState.textContent = 'No parent level structures available';
        devInsideItem.appendChild(emptyState);
      }
      
      // Update nested section with child layers (if any)
      if (childNodes && childNodes.length > 0) {
        childNodes.forEach((child, index) => {
          // Use the level from the backend data if available, otherwise calculate it
          let nestingLevel = child.level || 1;
          
          // If level is not provided, fall back to prefix-based calculation
          if (!child.level) {
            // If the selected layer has a prefix, calculate relative nesting
            if (selectedNode.name.startsWith('parent.')) {
              // Selected is parent, so children are child level
              if (child.name.startsWith('child.')) {
                nestingLevel = 1; // Direct children of parent
              } else if (child.name.startsWith('subChild.')) {
                nestingLevel = 2; // Grandchildren of parent
              }
            } else if (selectedNode.name.startsWith('child.')) {
              // Selected is child, so children are subChild level
              if (child.name.startsWith('subChild.')) {
                nestingLevel = 1; // Direct children of child
              }
            } else if (selectedNode.name.startsWith('hero.')) {
              // Hero is special - its children are typically child level
              if (child.name.startsWith('child.')) {
                nestingLevel = 1; // Direct children of hero
              } else if (child.name.startsWith('subChild.')) {
                nestingLevel = 2; // Grandchildren of hero
              }
            }
          }
          
          // Pass childrenData and isNestedSection flag for collapse functionality
          // Check if child has padding variables bound (we don't have this info for nested items, so default to false)
          const nestedItem = createStructureItem(
            child.name, 
            true, 
            nestingLevel, 
            false, 
            child, // childrenData
            true,   // isNestedSection
            child.id || null, // nodeId from childrenData
            false   // hasPaddingBindings - nested items don't have this info, default to false
          );
          devNestedContainer.appendChild(nestedItem);
        });
      }
    }
    
    // Variable mode control state
    let currentVariableModeType = 'preset'; // 'preset' or 'manual'
    let openDropdown = null; // Track which dropdown is open
    
    // Cache for available variable modes per collection
    const availableModesCache = {
      'A1 ðŸ“ Layout': null,
      'A2 ðŸ“¦ Padding': null,
      'A3 â†”ï¸ Spacing': null,
      'A4 â•­ Corner Radius': null
    };
    
    // Cache for last selected preset mode (for A1 Layout)
    let lastPresetMode = 'preset'; // Default to 'preset', will be updated when user selects a mode

    // Helper functions to check if properties are bound to variables
    function hasPaddingBound() {
      return currentVariableBindings && currentVariableBindings.padding && (
        currentVariableBindings.padding.top ||
        currentVariableBindings.padding.bottom ||
        currentVariableBindings.padding.left ||
        currentVariableBindings.padding.right
      );
    }
    
    function hasCornerRadiusBound() {
      return currentVariableBindings && currentVariableBindings.corners && (
        currentVariableBindings.corners.topLeft ||
        currentVariableBindings.corners.topRight ||
        currentVariableBindings.corners.bottomLeft ||
        currentVariableBindings.corners.bottomRight
      );
    }
    
    function hasSpacingBound() {
      return currentVariableBindings && currentVariableBindings.spacing === true;
    }
    
    function hasLayoutBound() {
      // Layout is bound if any layout-related variables are bound (padding, corners, or spacing)
      return hasPaddingBound() || hasCornerRadiusBound() || hasSpacingBound();
    }
    
    // Function to update disabled states of variable mode inputs based on current bindings
    // This can be called independently when bindings change without needing to re-fetch modes
    function updateVariableModeInputsDisabledState() {
      // Check which properties are bound
      const hasLayout = hasLayoutBound();
      const hasPadding = hasPaddingBound();
      const hasSpacing = hasSpacingBound();
      const hasCornerRadius = hasCornerRadiusBound();
      
      // Update preset mode input (A1 Layout)
      const presetInput = document.querySelector('.preset-inputs .variable-mode-input[data-collection="A1 ðŸ“ Layout"]');
      if (presetInput) {
        if (hasLayout) {
          presetInput.classList.remove('disabled');
          presetInput.style.opacity = '1';
          presetInput.style.cursor = 'pointer';
          presetInput.style.pointerEvents = 'auto';
        } else {
          presetInput.classList.add('disabled');
          presetInput.style.opacity = '0.5';
          presetInput.style.cursor = 'not-allowed';
          presetInput.style.pointerEvents = 'none';
        }
      }
      
      // Disable slider container if layout isn't bound
      const sliderContainer = document.getElementById('variableModeSliderContainer');
      if (sliderContainer) {
        if (hasLayout) {
          sliderContainer.style.opacity = '1';
          sliderContainer.style.pointerEvents = 'auto';
          sliderContainer.style.cursor = 'pointer';
        } else {
          sliderContainer.style.opacity = '0.5';
          sliderContainer.style.pointerEvents = 'none';
          sliderContainer.style.cursor = 'not-allowed';
        }
      }
      
      // Update manual mode inputs
      const paddingInput = document.querySelector('.manual-inputs .variable-mode-input[data-collection="A2 ðŸ“¦ Padding"]');
      if (paddingInput) {
        if (hasPadding) {
          paddingInput.classList.remove('disabled');
          paddingInput.style.opacity = '1';
          paddingInput.style.cursor = 'pointer';
          paddingInput.style.pointerEvents = 'auto';
        } else {
          paddingInput.classList.add('disabled');
          paddingInput.style.opacity = '0.5';
          paddingInput.style.cursor = 'not-allowed';
          paddingInput.style.pointerEvents = 'none';
        }
      }
      
      const cornerRadiusInput = document.querySelector('.manual-inputs .variable-mode-input[data-collection="A4 â•­ Corner Radius"]');
      if (cornerRadiusInput) {
        if (hasCornerRadius) {
          cornerRadiusInput.classList.remove('disabled');
          cornerRadiusInput.style.opacity = '1';
          cornerRadiusInput.style.cursor = 'pointer';
          cornerRadiusInput.style.pointerEvents = 'auto';
        } else {
          cornerRadiusInput.classList.add('disabled');
          cornerRadiusInput.style.opacity = '0.5';
          cornerRadiusInput.style.cursor = 'not-allowed';
          cornerRadiusInput.style.pointerEvents = 'none';
        }
      }
      
      const spacingInput = document.querySelector('.manual-inputs .variable-mode-input[data-collection="A3 â†”ï¸ Spacing"]');
      if (spacingInput) {
        if (hasSpacing) {
          spacingInput.classList.remove('disabled');
          spacingInput.style.opacity = '1';
          spacingInput.style.cursor = 'pointer';
          spacingInput.style.pointerEvents = 'auto';
        } else {
          spacingInput.classList.add('disabled');
          spacingInput.style.opacity = '0.5';
          spacingInput.style.cursor = 'not-allowed';
          spacingInput.style.pointerEvents = 'none';
        }
      }
      
      // Disable manual slider containers if their properties aren't bound
      const paddingSliderRow = document.querySelector('.manual-input-slider-row[data-collection="A2 ðŸ“¦ Padding"]');
      if (paddingSliderRow) {
        const paddingSlider = paddingSliderRow.querySelector('.variable-mode-slider-container');
        if (paddingSlider) {
          if (hasPadding) {
            paddingSlider.style.opacity = '1';
            paddingSlider.style.pointerEvents = 'auto';
            paddingSlider.style.cursor = 'pointer';
          } else {
            paddingSlider.style.opacity = '0.5';
            paddingSlider.style.pointerEvents = 'none';
            paddingSlider.style.cursor = 'not-allowed';
          }
        }
      }
      
      const cornerRadiusSliderRow = document.querySelector('.manual-input-slider-row[data-collection="A4 â•­ Corner Radius"]');
      if (cornerRadiusSliderRow) {
        const cornerRadiusSlider = cornerRadiusSliderRow.querySelector('.variable-mode-slider-container');
        if (cornerRadiusSlider) {
          if (hasCornerRadius) {
            cornerRadiusSlider.style.opacity = '1';
            cornerRadiusSlider.style.pointerEvents = 'auto';
            cornerRadiusSlider.style.cursor = 'pointer';
          } else {
            cornerRadiusSlider.style.opacity = '0.5';
            cornerRadiusSlider.style.pointerEvents = 'none';
            cornerRadiusSlider.style.cursor = 'not-allowed';
          }
        }
      }
      
      const spacingSliderRow = document.querySelector('.manual-input-slider-row[data-collection="A3 â†”ï¸ Spacing"]');
      if (spacingSliderRow) {
        const spacingSlider = spacingSliderRow.querySelector('.variable-mode-slider-container');
        if (spacingSlider) {
          if (hasSpacing) {
            spacingSlider.style.opacity = '1';
            spacingSlider.style.pointerEvents = 'auto';
            spacingSlider.style.cursor = 'pointer';
          } else {
            spacingSlider.style.opacity = '0.5';
            spacingSlider.style.pointerEvents = 'none';
            spacingSlider.style.cursor = 'not-allowed';
          }
        }
      }
    }
    
    // Function to update variable mode inputs with current modes
    function updateVariableModeInputs(modes) {
      const { layout, padding, spacing, cornerRadius } = modes;
      
      // Update preset mode input (A1 Layout)
      const presetInput = document.querySelector('.preset-inputs .variable-mode-input[data-collection="A1 ðŸ“ Layout"]');
      if (presetInput) {
        const textEl = presetInput.querySelector('.variable-mode-input-text');
        if (textEl) {
          textEl.textContent = normalizeModeNameForDisplay(layout);
        }
      }
      
      // Update slider position if in preset mode and mode is not manual
      if (currentVariableModeType === 'preset' && layout) {
        const normalizedLayout = layout.toLowerCase().trim();
        if (normalizedLayout !== 'manual') {
          updateSliderPosition(layout);
        }
      }
      
      // Update manual mode inputs
      const paddingInput = document.querySelector('.manual-inputs .variable-mode-input[data-collection="A2 ðŸ“¦ Padding"]');
      if (paddingInput) {
        const textEl = paddingInput.querySelector('.variable-mode-input-text');
        if (textEl) {
          textEl.textContent = normalizeModeNameForDisplay(padding);
        }
      }
      
      const cornerRadiusInput = document.querySelector('.manual-inputs .variable-mode-input[data-collection="A4 â•­ Corner Radius"]');
      if (cornerRadiusInput) {
        const textEl = cornerRadiusInput.querySelector('.variable-mode-input-text');
        if (textEl) {
          textEl.textContent = normalizeModeNameForDisplay(cornerRadius);
        }
      }
      
      const spacingInput = document.querySelector('.manual-inputs .variable-mode-input[data-collection="A3 â†”ï¸ Spacing"]');
      if (spacingInput) {
        const textEl = spacingInput.querySelector('.variable-mode-input-text');
        if (textEl) {
          textEl.textContent = normalizeModeNameForDisplay(spacing);
        }
        // Update manual slider position if slider is visible
        if (activeManualSlider === 'A3 â†”ï¸ Spacing' && spacing) {
          updateManualSliderPosition('A3 â†”ï¸ Spacing', spacing);
        }
      }
      
      // Update manual slider positions for other collections
      if (activeManualSlider === 'A2 ðŸ“¦ Padding' && padding) {
        updateManualSliderPosition('A2 ðŸ“¦ Padding', padding);
      }
      if (activeManualSlider === 'A4 â•­ Corner Radius' && cornerRadius) {
        updateManualSliderPosition('A4 â•­ Corner Radius', cornerRadius);
      }
      
      // Update disabled states based on current bindings
      updateVariableModeInputsDisabledState();
    }

    // Slider state
    let sliderIsDragging = false;
    let sliderDetents = []; // Array of mode names in order

    // Position order map for A1 Layout preset modes
    // Modes are ordered according to this sequence if present
    const MODE_POSITION_ORDER = [
      { keywords: ['x-small', 'xs'], position: 1 },
      { keywords: ['small', 's'], position: 2 },
      { keywords: ['medium', 'm'], position: 3 },
      { keywords: ['standard', 'default', 'standard (default)'], position: 4 },
      { keywords: ['large', 'l'], position: 5 },
      { keywords: ['x-large', 'xl'], position: 6 }
    ];

    // Function to get position for a mode based on the position map
    function getModePosition(mode) {
      const normalized = mode.toLowerCase().trim();
      
      for (const entry of MODE_POSITION_ORDER) {
        if (entry.keywords.some(keyword => normalized === keyword)) {
          return entry.position;
        }
      }
      
      // Modes not in the map get a high position (sorted to end)
      return 999;
    }

    // Function to filter and reorder modes for A1 Layout preset mode
    // Filters out "manual" and reorders according to MODE_POSITION_ORDER
    function processModesForPreset(availableModes) {
      if (!availableModes || availableModes.length === 0) {
        return [];
      }

      // Filter out "manual" (case-insensitive)
      const filteredModes = availableModes.filter(mode => {
        const normalized = mode.toLowerCase().trim();
        return normalized !== 'manual';
      });

      // Sort modes according to position map
      const sortedModes = [...filteredModes].sort((a, b) => {
        const posA = getModePosition(a);
        const posB = getModePosition(b);
        
        // If positions are equal, maintain original order
        if (posA === posB) {
          return 0;
        }
        
        return posA - posB;
      });

      return sortedModes;
    }

    // Function to create detent markers based on slider detents
    function createDetentMarkers() {
      const markersContainer = document.getElementById('variableModeSliderDetentMarkers');
      if (!markersContainer || sliderDetents.length === 0) {
        return;
      }

      // Clear existing markers
      markersContainer.innerHTML = '';

      // Create markers based on number of detents
      // We need one marker for each detent position
      for (let i = 0; i < sliderDetents.length; i++) {
        const marker = document.createElement('div');
        marker.className = 'variable-mode-slider-detent-marker';
        marker.setAttribute('data-index', i.toString());
        markersContainer.appendChild(marker);
      }
    }

    // Function to initialize slider with detents based on available modes
    function initializeSlider() {
      const availableModes = availableModesCache['A1 ðŸ“ Layout'];
      if (!availableModes || availableModes.length === 0) {
        return;
      }

      // Process modes: filter out manual and reorder for default positioning
      sliderDetents = processModesForPreset(availableModes);
      
      if (sliderDetents.length === 0) {
        return;
      }
      
      // Create detent markers
      createDetentMarkers();
      
      // Update slider position based on current mode
      if (lastPresetMode && lastPresetMode !== 'preset') {
        updateSliderPosition(lastPresetMode);
      } else {
        // Default to first mode (or default if available)
        const defaultMode = sliderDetents.find(m => {
          const n = m.toLowerCase().trim();
          return n === 'default' || n === 'standard' || n === 'standard (default)';
        });
        updateSliderPosition(defaultMode || sliderDetents[0]);
      }
    }

    // Function to update slider handle position based on current mode
    function updateSliderPosition(modeName) {
      const handle = document.getElementById('variableModeSliderHandle');
      const track = document.querySelector('.variable-mode-slider-track');
      if (!handle || !track || sliderDetents.length === 0) {
        return;
      }

      // Find the index of the current mode
      const modeIndex = sliderDetents.findIndex(mode => {
        const normalizedMode = mode.toLowerCase().trim();
        const normalizedCurrent = modeName.toLowerCase().trim();
        return normalizedMode === normalizedCurrent || 
               (normalizedMode === 'standard' && (normalizedCurrent === 'default' || normalizedCurrent === 'standard (default)')) ||
               ((normalizedMode === 'default' || normalizedMode === 'standard (default)') && normalizedCurrent === 'standard');
      });

      if (modeIndex === -1) {
        // Mode not found, default to first position
        handle.style.left = '0%';
        return;
      }

      // Calculate position percentage
      // For 1 mode: position at 0%
      // For 2 modes: positions at 0% and 100%
      // For 3+ modes: evenly distributed
      let positionPercent = 0;
      if (sliderDetents.length === 1) {
        positionPercent = 0;
      } else if (sliderDetents.length === 2) {
        positionPercent = modeIndex * 100;
      } else {
        positionPercent = (modeIndex / (sliderDetents.length - 1)) * 100;
      }

      handle.style.left = `${positionPercent}%`;
    }

    // Function to get mode from slider position
    function getModeFromSliderPosition(positionPercent) {
      if (sliderDetents.length === 0) {
        return null;
      }

      if (sliderDetents.length === 1) {
        return sliderDetents[0];
      }

      // Find the closest detent
      let closestIndex = 0;
      let minDistance = Infinity;

      for (let i = 0; i < sliderDetents.length; i++) {
        let detentPercent = 0;
        if (sliderDetents.length === 2) {
          detentPercent = i * 100;
        } else {
          detentPercent = (i / (sliderDetents.length - 1)) * 100;
        }

        const distance = Math.abs(positionPercent - detentPercent);
        if (distance < minDistance) {
          minDistance = distance;
          closestIndex = i;
        }
      }

      return sliderDetents[closestIndex];
    }

    // Function to set slider min-width based on longest option string
    function updateInputMinWidth() {
      const input = document.querySelector('.preset-inputs .variable-mode-input[data-collection="A1 ðŸ“ Layout"]');
      if (!input) return;

      const availableModes = availableModesCache['A1 ðŸ“ Layout'];
      if (!availableModes || availableModes.length === 0) {
        return;
      }

      // Process modes: filter out manual and reorder (same as slider)
      const processedModes = processModesForPreset(availableModes);
      if (processedModes.length === 0) {
        return;
      }

      // Find the longest mode name (after normalization for display)
      let longestLength = 0;
      let longestText = '';
      processedModes.forEach(mode => {
        const displayText = normalizeModeNameForDisplay(mode);
        if (displayText.length > longestLength) {
          longestLength = displayText.length;
          longestText = displayText;
        }
      });

      // Create a temporary element to measure width
      const tempEl = document.createElement('span');
      tempEl.style.visibility = 'hidden';
      tempEl.style.position = 'absolute';
      tempEl.style.fontFamily = 'var(--body-medium-fontfamily, "Inter", sans-serif)';
      tempEl.style.fontSize = '11px';
      tempEl.style.whiteSpace = 'nowrap';
      tempEl.textContent = longestText;
      document.body.appendChild(tempEl);
      
      const textWidth = tempEl.offsetWidth;
      document.body.removeChild(tempEl);

      // Set min-width: add padding (20px left + 4px right + 16px chevron + some buffer)
      const minWidth = textWidth + 40;
      input.style.minWidth = `${minWidth}px`;
    }

    // Manual input slider state
    let activeManualSlider = null; // Collection name of active slider
    let manualHoverTimers = {}; // Hover timers per input
    let manualDismissTimers = {}; // Dismissal timers per slider

    // Function to process modes for manual inputs (filter out manual)
    function processModesForManual(availableModes) {
      if (!availableModes || availableModes.length === 0) {
        return [];
      }
      // Filter out "manual" (case-insensitive)
      return availableModes.filter(mode => {
        const normalized = mode.toLowerCase().trim();
        return normalized !== 'manual';
      });
    }

    // Function to show manual input slider
    function showManualSlider(collectionName) {
      const manualInputs = document.getElementById('manualModeInputs');
      if (!manualInputs) return;

      // Hide any active slider first
      if (activeManualSlider && activeManualSlider !== collectionName) {
        hideManualSlider(activeManualSlider);
      }

      // Show the requested slider
      const sliderRow = manualInputs.querySelector(`.manual-input-slider-row[data-collection="${collectionName}"]`);
      const input = manualInputs.querySelector(`.variable-mode-input[data-collection="${collectionName}"]`);
      const iconWrapper = input?.querySelector('.variable-mode-input-icon-wrapper');

      if (sliderRow && input && iconWrapper) {
        // Set display first, then trigger animation
        sliderRow.style.display = 'flex';
        // Use requestAnimationFrame to ensure display is set before adding visible class
        requestAnimationFrame(() => {
          sliderRow.classList.add('visible');
        });
        
        input.classList.add('slider-active');
        iconWrapper.classList.add('active');
        manualInputs.classList.add('has-active-slider');
        activeManualSlider = collectionName;

        // Initialize slider if not already initialized
        initializeManualSlider(collectionName);

        // Show detent markers container
        const markersContainer = sliderRow.querySelector('.variable-mode-slider-detent-markers');
        if (markersContainer) {
          markersContainer.style.display = 'flex';
        }
      }
    }

    // Function to hide manual input slider
    function hideManualSlider(collectionName) {
      const manualInputs = document.getElementById('manualModeInputs');
      if (!manualInputs) return;

      const sliderRow = manualInputs.querySelector(`.manual-input-slider-row[data-collection="${collectionName}"]`);
      const input = manualInputs.querySelector(`.variable-mode-input[data-collection="${collectionName}"]`);
      const iconWrapper = input?.querySelector('.variable-mode-input-icon-wrapper');

      if (sliderRow && input && iconWrapper) {
        // Remove visible class to trigger hide animation
        sliderRow.classList.remove('visible');
        
        // Wait for animation to complete before hiding
        setTimeout(() => {
          sliderRow.style.display = 'none';
        }, 300); // Match transition duration
        
        input.classList.remove('slider-active');
        iconWrapper.classList.remove('active');
        
        // Hide detent markers container
        const markersContainer = sliderRow.querySelector('.variable-mode-slider-detent-markers');
        if (markersContainer) {
          markersContainer.style.display = 'none';
        }
        
        // Clear dismissal timer
        if (manualDismissTimers[collectionName]) {
          clearTimeout(manualDismissTimers[collectionName]);
          delete manualDismissTimers[collectionName];
        }
      }

      // Check if any slider is still active
      const activeSliders = manualInputs.querySelectorAll('.manual-input-slider-row.visible');
      if (activeSliders.length === 0) {
        manualInputs.classList.remove('has-active-slider');
        activeManualSlider = null;
      }
    }

    // Function to create detent markers for manual slider
    function createManualDetentMarkers(collectionName, detents) {
      const sliderRow = document.querySelector(`.manual-input-slider-row[data-collection="${collectionName}"]`);
      if (!sliderRow) return;

      const markersContainer = sliderRow.querySelector('.variable-mode-slider-detent-markers');
      if (!markersContainer) return;

      // Clear existing markers
      markersContainer.innerHTML = '';

      // Create markers based on number of detents
      for (let i = 0; i < detents.length; i++) {
        const marker = document.createElement('div');
        marker.className = 'variable-mode-slider-detent-marker';
        marker.setAttribute('data-index', i.toString());
        markersContainer.appendChild(marker);
      }
    }

    // Function to initialize a manual slider
    function initializeManualSlider(collectionName) {
      const sliderRow = document.querySelector(`.manual-input-slider-row[data-collection="${collectionName}"]`);
      if (!sliderRow) return;

      const availableModes = availableModesCache[collectionName];
      if (!availableModes || availableModes.length === 0) {
        return;
      }

      // Process modes: filter out manual
      const processedModes = processModesForManual(availableModes);
      if (processedModes.length === 0) {
        return;
      }

      // Create detent markers
      createManualDetentMarkers(collectionName, processedModes);

      // Get current mode and update slider position
      const input = document.querySelector(`.manual-inputs .variable-mode-input[data-collection="${collectionName}"]`);
      if (input) {
        const textEl = input.querySelector('.variable-mode-input-text');
        const currentModeText = textEl ? textEl.textContent.trim() : null;
        
        if (currentModeText) {
          // Find the backend mode name from display text
          const currentMode = processedModes.find(mode => {
            const displayText = normalizeModeNameForDisplay(mode);
            return displayText === currentModeText;
          });
          
          if (currentMode) {
            updateManualSliderPosition(collectionName, currentMode);
          }
        }
      }
    }

    // Function to update manual slider position
    function updateManualSliderPosition(collectionName, modeName) {
      const sliderRow = document.querySelector(`.manual-input-slider-row[data-collection="${collectionName}"]`);
      if (!sliderRow) return;

      const handle = sliderRow.querySelector('.manual-slider-handle');
      const markersContainer = sliderRow.querySelector('.variable-mode-slider-detent-markers');
      if (!handle || !markersContainer) return;

      const availableModes = availableModesCache[collectionName];
      if (!availableModes) return;

      const processedModes = processModesForManual(availableModes);
      if (processedModes.length === 0) return;

      // Find the index of the current mode
      const modeIndex = processedModes.findIndex(mode => {
        const normalizedMode = mode.toLowerCase().trim();
        const normalizedCurrent = modeName.toLowerCase().trim();
        return normalizedMode === normalizedCurrent || 
               (normalizedMode === 'standard' && (normalizedCurrent === 'default' || normalizedCurrent === 'standard (default)')) ||
               ((normalizedMode === 'default' || normalizedMode === 'standard (default)') && normalizedCurrent === 'standard');
      });

      if (modeIndex === -1) {
        handle.style.left = '0%';
        return;
      }

      // Calculate position percentage
      let positionPercent = 0;
      if (processedModes.length === 1) {
        positionPercent = 0;
      } else if (processedModes.length === 2) {
        positionPercent = modeIndex * 100;
      } else {
        positionPercent = (modeIndex / (processedModes.length - 1)) * 100;
      }

      handle.style.left = `${positionPercent}%`;
    }

    // Function to get mode from manual slider position
    function getModeFromManualSliderPosition(collectionName, positionPercent) {
      const availableModes = availableModesCache[collectionName];
      if (!availableModes) return null;

      const processedModes = processModesForManual(availableModes);
      if (processedModes.length === 0) return null;

      if (processedModes.length === 1) {
        return processedModes[0];
      }

      // Find the closest detent
      let closestIndex = 0;
      let minDistance = Infinity;

      for (let i = 0; i < processedModes.length; i++) {
        let detentPercent = 0;
        if (processedModes.length === 2) {
          detentPercent = i * 100;
        } else {
          detentPercent = (i / (processedModes.length - 1)) * 100;
        }

        const distance = Math.abs(positionPercent - detentPercent);
        if (distance < minDistance) {
          minDistance = distance;
          closestIndex = i;
        }
      }

      return processedModes[closestIndex];
    }

    // Function to initialize manual input sliders
    function initManualInputSliders() {
      const manualInputs = document.getElementById('manualModeInputs');
      if (!manualInputs) return;

      const inputs = manualInputs.querySelectorAll('.variable-mode-input');
      
      inputs.forEach(input => {
        const collectionName = input.getAttribute('data-collection');
        if (!collectionName) return;

        const iconWrapper = input.querySelector('.variable-mode-input-icon-wrapper');
        if (!iconWrapper) return;

        // Click handler for icon wrapper (toggle slider)
        iconWrapper.addEventListener('click', (e) => {
          e.stopPropagation();
          
          // Clear any pending hover timer
          if (manualHoverTimers[collectionName]) {
            clearTimeout(manualHoverTimers[collectionName]);
            delete manualHoverTimers[collectionName];
          }
          
          // Check if slider is currently visible (has visible class)
          const sliderRow = manualInputs.querySelector(`.manual-input-slider-row[data-collection="${collectionName}"]`);
          const isVisible = sliderRow && sliderRow.classList.contains('visible');
          
          if (isVisible) {
            // Hide slider if it's currently visible
            hideManualSlider(collectionName);
          } else {
            // Show slider (this confirms/persists visibility if hover was active)
            showManualSlider(collectionName);
            
            // Clear any dismissal timer since user explicitly clicked
            if (manualDismissTimers[collectionName]) {
              clearTimeout(manualDismissTimers[collectionName]);
              delete manualDismissTimers[collectionName];
            }
          }
        });

        // Hover handler (show after 600ms)
        let hoverTimer;
        input.addEventListener('mouseenter', () => {
          // Clear any existing timer
          if (manualHoverTimers[collectionName]) {
            clearTimeout(manualHoverTimers[collectionName]);
          }

          // Clear dismissal timer if exists
          if (manualDismissTimers[collectionName]) {
            clearTimeout(manualDismissTimers[collectionName]);
            delete manualDismissTimers[collectionName];
          }

          // Set hover timer
          hoverTimer = setTimeout(() => {
            if (activeManualSlider !== collectionName) {
              showManualSlider(collectionName);
            }
            manualHoverTimers[collectionName] = null;
          }, 600);
          manualHoverTimers[collectionName] = hoverTimer;
        });

        // Mouse leave handler (dismissal delay)
        input.addEventListener('mouseleave', () => {
          // Clear hover timer
          if (manualHoverTimers[collectionName]) {
            clearTimeout(manualHoverTimers[collectionName]);
            delete manualHoverTimers[collectionName];
          }

          // Only hide if slider is active and cursor is not moving to slider
          if (activeManualSlider === collectionName) {
            // Set dismissal delay (allow cursor to reach slider)
            if (manualDismissTimers[collectionName]) {
              clearTimeout(manualDismissTimers[collectionName]);
            }

            manualDismissTimers[collectionName] = setTimeout(() => {
              // Check if mouse is still over input or slider
              const sliderRow = manualInputs.querySelector(`.manual-input-slider-row[data-collection="${collectionName}"]`);
              const isOverInput = input.matches(':hover');
              const isOverSlider = sliderRow && sliderRow.matches(':hover');
              
              if (!isOverInput && !isOverSlider) {
                hideManualSlider(collectionName);
              }
            }, 300); // 300ms delay for cursor travel
          }
        });

        // Also handle mouse leave on slider row
        const sliderRow = manualInputs.querySelector(`.manual-input-slider-row[data-collection="${collectionName}"]`);
        if (sliderRow) {
          sliderRow.addEventListener('mouseleave', () => {
            if (activeManualSlider === collectionName) {
              if (manualDismissTimers[collectionName]) {
                clearTimeout(manualDismissTimers[collectionName]);
              }

              manualDismissTimers[collectionName] = setTimeout(() => {
                const isOverInput = input.matches(':hover');
                const isOverSlider = sliderRow.matches(':hover');
                
                if (!isOverInput && !isOverSlider) {
                  hideManualSlider(collectionName);
                }
              }, 300);
            }
          });

          sliderRow.addEventListener('mouseenter', () => {
            // Cancel dismissal when entering slider
            if (manualDismissTimers[collectionName]) {
              clearTimeout(manualDismissTimers[collectionName]);
              delete manualDismissTimers[collectionName];
            }
          });
        }
      });

      // Initialize sliders for manual inputs
      initManualSliderHandlers();
    }

    // Function to initialize manual slider drag handlers
    function initManualSliderHandlers() {
      const manualInputs = document.getElementById('manualModeInputs');
      if (!manualInputs) return;

      const sliderRows = manualInputs.querySelectorAll('.manual-input-slider-row');
      
      sliderRows.forEach(sliderRow => {
        const collectionName = sliderRow.getAttribute('data-collection');
        if (!collectionName) return;

        const handle = sliderRow.querySelector('.manual-slider-handle');
        const track = sliderRow.querySelector('.variable-mode-slider-track');
        const container = sliderRow.querySelector('.manual-slider');
        if (!handle || !track || !container) return;

        let isDragging = false;

        // Mouse down on handle
        handle.addEventListener('mousedown', (e) => {
          e.preventDefault();
          e.stopPropagation();
          isDragging = true;
          container.classList.add('dragging');
          handle.style.cursor = 'grabbing';
          handle.style.transition = 'none';
        });

        // Mouse down on track (jump to position)
        track.addEventListener('mousedown', (e) => {
          if (e.target === handle || handle.contains(e.target)) {
            return;
          }
          
          e.preventDefault();
          e.stopPropagation();
          
          const trackRect = track.getBoundingClientRect();
          const clickX = e.clientX - trackRect.left;
          const positionPercent = Math.max(0, Math.min(100, (clickX / trackRect.width) * 100));
          
          handle.style.left = `${positionPercent}%`;
          handle.style.transition = 'none';
          
          const selectedMode = getModeFromManualSliderPosition(collectionName, positionPercent);
          if (selectedMode) {
            updateVariableMode(collectionName, selectedMode);
            updateManualSliderPosition(collectionName, selectedMode);
          }
        });

        // Mouse move (dragging)
        document.addEventListener('mousemove', (e) => {
          if (!isDragging) return;
          
          const trackRect = track.getBoundingClientRect();
          const mouseX = e.clientX - trackRect.left;
          const positionPercent = Math.max(0, Math.min(100, (mouseX / trackRect.width) * 100));
          
          handle.style.left = `${positionPercent}%`;
        });

        // Mouse up (release)
        document.addEventListener('mouseup', (e) => {
          if (!isDragging) return;
          
          isDragging = false;
          container.classList.remove('dragging');
          handle.style.cursor = 'grab';
          handle.style.transition = 'background 0.2s ease';
          
          const handleLeft = parseFloat(handle.style.left);
          const selectedMode = getModeFromManualSliderPosition(collectionName, handleLeft);
          
          if (selectedMode) {
            updateVariableMode(collectionName, selectedMode);
            updateManualSliderPosition(collectionName, selectedMode);
          }
        });
      });
    }

    // Function to initialize slider drag handlers
    function initSliderHandlers() {
      const handle = document.getElementById('variableModeSliderHandle');
      const track = document.querySelector('.variable-mode-slider-track');
      const container = document.getElementById('variableModeSliderContainer');
      if (!handle || !track || !container) {
        return;
      }

      // Mouse down on handle
      handle.addEventListener('mousedown', (e) => {
        e.preventDefault();
        e.stopPropagation();
        sliderIsDragging = true;
        handle.classList.add('dragging');
        container.classList.add('dragging');
        handle.style.cursor = 'grabbing';
        handle.style.transition = 'none';
      });

      // Mouse down on track (jump to position)
      track.addEventListener('mousedown', (e) => {
        // Don't handle if clicking directly on handle (handle has its own handler)
        if (e.target === handle || handle.contains(e.target)) {
          return;
        }
        
        e.preventDefault();
        e.stopPropagation();
        
        const trackRect = track.getBoundingClientRect();
        const clickX = e.clientX - trackRect.left;
        const positionPercent = Math.max(0, Math.min(100, (clickX / trackRect.width) * 100));
        
        // Update handle position
        handle.style.left = `${positionPercent}%`;
        handle.style.transition = 'none';
        
        // Get mode from position and update
        const selectedMode = getModeFromSliderPosition(positionPercent);
        if (selectedMode) {
          updateVariableMode('A1 ðŸ“ Layout', selectedMode);
          lastPresetMode = selectedMode;
          
          // Snap handle to detent position
          updateSliderPosition(selectedMode);
        }
      });

      // Mouse move (dragging)
      document.addEventListener('mousemove', (e) => {
        if (!sliderIsDragging) return;
        
        const trackRect = track.getBoundingClientRect();
        const mouseX = e.clientX - trackRect.left;
        const positionPercent = Math.max(0, Math.min(100, (mouseX / trackRect.width) * 100));
        
        handle.style.left = `${positionPercent}%`;
      });

      // Mouse up (release)
      document.addEventListener('mouseup', (e) => {
        if (!sliderIsDragging) return;
        
        sliderIsDragging = false;
        handle.classList.remove('dragging');
        if (container) {
          container.classList.remove('dragging');
        }
        handle.style.cursor = 'grab';
        handle.style.transition = 'background 0.2s ease';
        
        // Snap to nearest detent and update mode
        const handleLeft = parseFloat(handle.style.left);
        const selectedMode = getModeFromSliderPosition(handleLeft);
        
        if (selectedMode) {
          updateVariableMode('A1 ðŸ“ Layout', selectedMode);
          lastPresetMode = selectedMode;
          
          // Update handle position to snap to detent
          updateSliderPosition(selectedMode);
        }
      });
    }

    // Function to get variable modes for selected frame
    function getVariableModesForSelection() {
      if (!selectedNode) return;
      
      parent.postMessage({
        pluginMessage: {
          type: 'get-layout-variable-modes',
          nodeId: selectedNode.id
        }
      }, '*');
    }

    // Function to update variable mode
    function updateVariableMode(collectionName, modeName) {
      if (!selectedNode) return;
      
      parent.postMessage({
        pluginMessage: {
          type: 'update-layout-variable-mode',
          collectionName: collectionName,
          mode: modeName
        }
      }, '*');
    }

    // Alias mapping for long mode names to compact display names
    // Uses single or double letter abbreviations to prevent truncation in dropdowns
    const MODE_NAME_ALIASES = {
      'standard (default)': 'D',
      'standard': 'D',
      'default': 'D',
      'x-small': 'XS',
      'x-small (compact)': 'XS',
      'small': 'S',
      'small (compact)': 'S',
      'medium': 'M',
      'medium (default)': 'M',
      'large': 'L',
      'large (expanded)': 'L',
      'x-large': 'XL',
      'x-large (expanded)': 'XL',
      'manual': 'Manual',
      'preset': 'Preset',
      'parent (default)': 'Parent',
      'parent': 'Parent',
      'child': 'Child',
      'sub-child': 'Sub-Child',
      'hero': 'Hero'
    };
    
    // Function to get display alias for a mode name
    function getModeDisplayAlias(backendModeName) {
      if (!backendModeName) return 'D'; // Default to 'D' for compact display
      const normalized = backendModeName.toLowerCase().trim();
      
      // Check if there's an alias
      if (MODE_NAME_ALIASES[normalized]) {
        return MODE_NAME_ALIASES[normalized];
      }
      
      // No alias found, use normalized display name
      return normalizeModeNameForDisplay(backendModeName);
    }
    
    // Function to normalize mode names for display in UI
    // Consolidates "standard", "standard (default)", and "default" to display as "Default"
    function normalizeModeNameForDisplay(backendModeName) {
      if (!backendModeName) return 'Default';
      const normalized = backendModeName.toLowerCase().trim();
      // Map default/standard variants to "Default" for display
      if (normalized === 'default' || normalized === 'standard' || normalized === 'standard (default)') {
        return 'Default';
      }
      // Capitalize first letter for other modes
      return backendModeName.charAt(0).toUpperCase() + backendModeName.slice(1);
    }

    // Function to map UI mode names to backend mode names
    // Consolidates "Default", "Standard", and "Standard (Default)" into "standard"
    function mapModeNameForBackend(uiModeName) {
      const normalized = uiModeName.toLowerCase().trim();
      // Map default/standard variants to "standard" for backend
      if (normalized === 'default' || normalized === 'standard' || normalized === 'standard (default)') {
        return 'standard';
      }
      // Return as-is for other modes
      return uiModeName;
    }

    // Function to create check icon SVG
    function createCheckIcon() {
      const icon = document.createElement('div');
      icon.className = 'check-icon';
      icon.innerHTML = `
        <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M13.3333 4L6 11.3333L2.66667 8" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
      `;
      return icon;
    }

    // Function to load available modes for a collection
    function loadAvailableModesForCollection(collectionName) {
      parent.postMessage({
        pluginMessage: {
          type: 'get-available-variable-modes',
          collectionName: collectionName
        }
      }, '*');
    }
    
    // Function to load available modes for all collections (only if not already cached)
    function loadAllAvailableModes() {
      const collections = ['A1 ðŸ“ Layout', 'A2 ðŸ“¦ Padding', 'A3 â†”ï¸ Spacing', 'A4 â•­ Corner Radius'];
      collections.forEach(collectionName => {
        // Only load if not already cached (null means not loaded yet, empty array means loaded but empty)
        if (availableModesCache[collectionName] === null) {
          loadAvailableModesForCollection(collectionName);
        }
      });
    }
    
    // Function to show dropdown for a variable mode input
    function showVariableModeDropdown(inputElement, collectionName) {
      // Close any open dropdowns first
      closeAllDropdowns();
      
      // Get current mode value from the input text
      const currentModeText = inputElement.querySelector('.variable-mode-input-text');
      const currentMode = currentModeText ? currentModeText.textContent.trim() : null;
      
      // Get available modes from cache, or use empty array if not cached yet
      let availableModes = availableModesCache[collectionName];
      
      // If modes are not cached, request them and show loading state
      if (availableModes === null) {
        // Request modes for this collection
        loadAvailableModesForCollection(collectionName);
        
        // Create dropdown with loading state
        const dropdown = document.createElement('div');
        dropdown.className = 'variable-mode-dropdown';
        const loadingOption = document.createElement('div');
        loadingOption.className = 'variable-mode-option';
        loadingOption.style.padding = '12px';
        loadingOption.style.textAlign = 'center';
        loadingOption.style.color = 'var(--text-text-secondary, #666)';
        loadingOption.textContent = 'Loading modes...';
        dropdown.appendChild(loadingOption);
        inputElement.appendChild(dropdown);
        openDropdown = dropdown;
        return; // Exit early, dropdown will be updated when modes are received
      }
      
      // If we have cached modes, use them
      if (!availableModes || availableModes.length === 0) {
        // Fallback to common modes if cache is empty
        availableModes = ['Default', 'Manual', 'Preset', 'Small', 'Medium', 'Large', 'X-Small', 'X-Large'];
      }
      
      // For A1 Layout in preset mode, filter out manual and reorder modes
      if (collectionName === 'A1 ðŸ“ Layout' && currentVariableModeType === 'preset') {
        availableModes = processModesForPreset(availableModes);
      }
      
      // Create dropdown
      const dropdown = document.createElement('div');
      dropdown.className = 'variable-mode-dropdown';
      
      // Store option data for batch processing
      const optionData = [];
      
      // Add options with full names initially
      availableModes.forEach(mode => {
        const option = document.createElement('div');
        option.className = 'variable-mode-option';
        
        // Check if this is the currently selected option
        const isSelected = normalizeModeNameForDisplay(currentMode) === normalizeModeNameForDisplay(mode);
        if (isSelected) {
          option.classList.add('selected');
        }
        
        // Create text span with full name initially
        const textSpan = document.createElement('span');
        const fullDisplayName = normalizeModeNameForDisplay(mode);
        const compactAlias = getModeDisplayAlias(mode);
        
        textSpan.textContent = fullDisplayName;
        option.appendChild(textSpan);
        
        // Store option data for batch processing
        optionData.push({
          textSpan: textSpan,
          mode: mode,
          fullDisplayName: fullDisplayName,
          compactAlias: compactAlias
        });
        
        // Add check icon
        const checkIcon = createCheckIcon();
        option.appendChild(checkIcon);
        
        option.addEventListener('click', (e) => {
          e.stopPropagation();
          // Use the actual backend mode name (not the normalized display name)
          updateVariableMode(collectionName, mode);
          
          // Cache the mode if it's A1 Layout and we're in preset mode
          if (collectionName === 'A1 ðŸ“ Layout' && currentVariableModeType === 'preset') {
            lastPresetMode = mode;
            // Update slider position
            updateSliderPosition(mode);
          }
          
          closeAllDropdowns();
        });
        dropdown.appendChild(option);
      });
      
      // After all options are rendered, check if ANY would truncate
      // If any truncates, apply compact aliases to ALL for consistency
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          // Check if any option would truncate
          let anyWouldTruncate = false;
          optionData.forEach(data => {
            const spanWidth = data.textSpan.scrollWidth;
            const spanClientWidth = data.textSpan.clientWidth;
            if (spanWidth > spanClientWidth) {
              anyWouldTruncate = true;
            }
          });
          
          // Apply decision uniformly to all options
          optionData.forEach(data => {
            if (anyWouldTruncate && data.compactAlias !== data.fullDisplayName) {
              // Use compact alias for all if any would truncate
              data.textSpan.textContent = data.compactAlias;
              data.textSpan.title = data.mode; // Show full name on hover
            } else {
              // Keep full names for all
              // Add tooltip only if display name differs from backend name
              if (data.fullDisplayName !== data.mode) {
                data.textSpan.title = data.mode;
              }
            }
          });
        });
      });
      
      inputElement.appendChild(dropdown);
      openDropdown = dropdown;
      
      // Add class to indicate dropdown is open (for chevron rotation)
      inputElement.classList.add('has-open-dropdown');
      
      // Adjust padding based on scrollbar presence
      adjustDropdownPadding(dropdown);
      
      // Add scroll event listener to show scrollbar while scrolling
      let scrollTimeout;
      dropdown.addEventListener('scroll', () => {
        dropdown.classList.add('scrolling');
        clearTimeout(scrollTimeout);
        scrollTimeout = setTimeout(() => {
          dropdown.classList.remove('scrolling');
        }, 150);
      });
      
      // Close dropdown when clicking outside
      setTimeout(() => {
        document.addEventListener('click', function closeDropdownOnClick(e) {
          if (!inputElement.contains(e.target)) {
            closeAllDropdowns();
            document.removeEventListener('click', closeDropdownOnClick);
          }
        });
      }, 0);
    }

    // Function to close all dropdowns
    function closeAllDropdowns() {
      if (openDropdown) {
        // Remove has-open-dropdown class from the input element
        const inputElement = openDropdown.parentElement;
        if (inputElement && inputElement.classList.contains('variable-mode-input')) {
          inputElement.classList.remove('has-open-dropdown');
        }
        openDropdown.remove();
        openDropdown = null;
      }
      
      // Also close spacing dropdown if open
      if (currentSpacingDropdown && document.body.contains(currentSpacingDropdown)) {
        document.body.removeChild(currentSpacingDropdown);
        currentSpacingDropdown = null;
      }
    }
    
    // Helper function to adjust dropdown padding based on scrollbar presence
    function adjustDropdownPadding(dropdown) {
      // Use requestAnimationFrame to ensure DOM is fully rendered
      requestAnimationFrame(() => {
        const hasScrollbar = dropdown.scrollHeight > dropdown.clientHeight;
        if (!hasScrollbar) {
          // No scrollbar present, add right padding to match visual appearance
          dropdown.style.paddingRight = '8px';
        } else {
          // Scrollbar present, keep 0px right padding (already set in CSS)
          dropdown.style.paddingRight = '0px';
        }
      });
    }

    // Initialize variable mode control handlers
    function initVariableModeControls() {
      // Initialize segmented control - set preset as active by default
      const presetSegment = document.querySelector('.variable-mode-segment[data-mode="preset"]');
      const manualSegment = document.querySelector('.variable-mode-segment[data-mode="manual"]');
      const presetInputs = document.getElementById('presetModeInputs');
      const manualInputs = document.getElementById('manualModeInputs');
      
      if (presetSegment) {
        presetSegment.classList.add('active');
        currentVariableModeType = 'preset';
      }
      if (manualSegment) {
        manualSegment.classList.remove('active');
      }
      if (presetInputs) {
        presetInputs.style.display = 'flex';
      }
      if (manualInputs) {
        manualInputs.style.display = 'none';
      }
      
      // Segmented control handlers
      const segments = document.querySelectorAll('.variable-mode-segment');
      segments.forEach(segment => {
        segment.addEventListener('click', (e) => {
          const mode = e.target.getAttribute('data-mode');
          if (mode) {
            currentVariableModeType = mode;
            
            // Update active state
            segments.forEach(s => s.classList.remove('active'));
            e.target.classList.add('active');
            
            // Show/hide appropriate inputs
            const presetInputs = document.getElementById('presetModeInputs');
            const manualInputs = document.getElementById('manualModeInputs');
            
            if (mode === 'preset') {
              if (presetInputs) presetInputs.style.display = 'flex';
              if (manualInputs) manualInputs.style.display = 'none';
              
              // Initialize slider if modes are available
              const availableModes = availableModesCache['A1 ðŸ“ Layout'];
              if (availableModes && availableModes.length > 0) {
                initializeSlider();
                updateInputMinWidth();
              }
              
              // If switching to preset, restore the last cached preset mode (or default to 'preset')
              if (selectedNode) {
                updateVariableMode('A1 ðŸ“ Layout', lastPresetMode);
              }
            } else {
              // Manual mode
              if (presetInputs) presetInputs.style.display = 'none';
              if (manualInputs) manualInputs.style.display = 'flex';
              
              // Hide any active manual sliders when switching to manual mode
              if (activeManualSlider) {
                hideManualSlider(activeManualSlider);
              }
              
              // If switching to manual, set A1 Layout to manual mode
              if (selectedNode) {
                updateVariableMode('A1 ðŸ“ Layout', 'manual');
              }
            }
          }
        });
      });
      
      // Variable mode input handlers
      const inputs = document.querySelectorAll('.variable-mode-input');
      inputs.forEach(input => {
        input.addEventListener('click', (e) => {
          // Don't trigger dropdown if clicking on icon wrapper
          if (e.target.closest('.variable-mode-input-icon-wrapper')) {
            return;
          }
          
          // Check if clicking on chevron
          const isChevronClick = e.target.closest('.variable-mode-input-chevron');
          
          e.stopPropagation();
          const collectionName = input.getAttribute('data-collection');
          
          if (collectionName) {
            // If clicking chevron and dropdown is already open for this input, close it
            if (isChevronClick && input.classList.contains('has-open-dropdown')) {
              closeAllDropdowns();
            } else {
              // Otherwise, show/open the dropdown
              showVariableModeDropdown(input, collectionName);
            }
          }
        });
      });
      
      // Initialize slider handlers
      initSliderHandlers();
      
      // Initialize manual input sliders
      initManualInputSliders();
      
      // Initialize slider if modes are already loaded and we're in preset mode
      if (currentVariableModeType === 'preset') {
        const availableModes = availableModesCache['A1 ðŸ“ Layout'];
        if (availableModes && availableModes.length > 0) {
          initializeSlider();
          updateInputMinWidth();
        }
      }
    }

    // Call init when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initVariableModeControls);
    } else {
      initVariableModeControls();
    }

    // Listen for messages from the plugin
    window.onmessage = (event) => {
      const msg = event.data.pluginMessage;
      
      if (!msg) return;
      
      showLoading(false);
      
      if (msg.type === 'success') {
        showMessage(msg.message, 'success');
      } else if (msg.type === 'error') {
        showMessage(msg.message, 'error');
      } else if (msg.type === 'spacing-variable-mode') {
        // Update spacing control with current variable mode
        const spacingControlContainer = document.getElementById('spacingControlContainer');
        if (spacingControlContainer && msg.mode) {
          const inputValue = SPACING_MODE_TO_INPUT[msg.mode];
          if (inputValue) {
            const sizeIndex = sizeClasses.indexOf(inputValue === '0' ? 'none' : inputValue);
            if (sizeIndex !== -1) {
              currentSizeIndex = sizeIndex;
              const variableModeText = spacingControlContainer.querySelector('.spacing-variable-mode-text');
              if (variableModeText) {
                variableModeText.textContent = currentSizeIndex === 0 ? '0' : sizeClasses[currentSizeIndex] || 'S';
              }
              updateDetentMarkers(currentSizeIndex);
            }
          }
        }
      } else if (msg.type === 'layout-variable-modes') {
        // Update segmented control to reflect current A1 Layout mode FIRST
        // This ensures currentVariableModeType is set correctly before updateVariableModeInputs
        if (msg.modes.layout) {
          const layoutMode = msg.modes.layout.toLowerCase().trim();
          const isManual = layoutMode === 'manual';
          
          // Update segmented control state
          const presetSegment = document.querySelector('.variable-mode-segment[data-mode="preset"]');
          const manualSegment = document.querySelector('.variable-mode-segment[data-mode="manual"]');
          const presetInputs = document.getElementById('presetModeInputs');
          const manualInputs = document.getElementById('manualModeInputs');
          
          if (presetSegment && manualSegment) {
            // Update active state
            if (isManual) {
              presetSegment.classList.remove('active');
              manualSegment.classList.add('active');
              currentVariableModeType = 'manual';
              
              // Show/hide appropriate inputs
              if (presetInputs) presetInputs.style.display = 'none';
              if (manualInputs) manualInputs.style.display = 'flex';
            } else {
              presetSegment.classList.add('active');
              manualSegment.classList.remove('active');
              currentVariableModeType = 'preset';
              
              // Show/hide appropriate inputs
              if (presetInputs) presetInputs.style.display = 'flex';
              if (manualInputs) manualInputs.style.display = 'none';
              
              // Initialize slider if modes are available
              const availableModes = availableModesCache['A1 ðŸ“ Layout'];
              if (availableModes && availableModes.length > 0) {
                initializeSlider();
                updateInputMinWidth();
              }
            }
          }
        }
        
        // Update variable mode inputs with current modes (after segmented control is updated)
        updateVariableModeInputs(msg.modes);
        
        // Sync the preset mode cache:
        // - If we're in preset mode, always update the cache with current mode
        // - If we're not in preset mode but cache is still default, initialize it with current mode
        if (msg.modes.layout) {
          if (currentVariableModeType === 'preset') {
            // Always sync when in preset mode
            lastPresetMode = msg.modes.layout;
          } else if (lastPresetMode === 'preset') {
            // If cache is still default and we're not in preset mode, 
            // initialize cache with current mode (in case user switches to preset later)
            // Only do this if the current mode is not 'manual' (which would be from manual mode)
            if (msg.modes.layout.toLowerCase() !== 'manual') {
              lastPresetMode = msg.modes.layout;
            }
          }
        }
      } else if (msg.type === 'available-variable-modes') {
        // Cache available modes for the collection
        availableModesCache[msg.collectionName] = msg.modes;
        
        // If this is A1 Layout collection and we're in preset mode, initialize slider
        if (msg.collectionName === 'A1 ðŸ“ Layout' && currentVariableModeType === 'preset') {
          initializeSlider();
          updateInputMinWidth();
        }
        
        // If this is a manual input collection and slider is active, reinitialize it
        const manualCollections = ['A2 ðŸ“¦ Padding', 'A3 â†”ï¸ Spacing', 'A4 â•­ Corner Radius'];
        if (manualCollections.includes(msg.collectionName) && activeManualSlider === msg.collectionName) {
          initializeManualSlider(msg.collectionName);
        }
        
        // If a dropdown is open for this collection, refresh it
        if (openDropdown) {
          const inputElement = openDropdown.parentElement;
          if (inputElement && inputElement.classList.contains('variable-mode-input')) {
            const collectionName = inputElement.getAttribute('data-collection');
            if (collectionName === msg.collectionName) {
              // Close current dropdown and reopen with new modes
              closeAllDropdowns();
              // Small delay to ensure dropdown is closed before reopening
              setTimeout(() => {
                showVariableModeDropdown(inputElement, collectionName);
              }, 10);
            }
          }
        }
      } else if (msg.type === 'selection-change') {
        // ====================================================================
        // CENTRALIZED POST-ACTION UPDATE HANDLER
        // ====================================================================
        // This handler is called after ANY action that modifies the selection:
        // - apply-variables: Backend calls notifySelectionChange() after applying
        // - clear-variables: Backend calls notifySelectionChange() after clearing
        // - rename-node: Backend calls notifySelectionChange() after renaming/applying
        // - auto-adjust: Backend calls notifySelectionChange() after adjusting/applying
        // - User selection changes: Figma's selectionchange event triggers notifySelectionChange()
        //
        // The backend's notifySelectionChange() function:
        // 1. Detects current selection
        // 2. Queries bound variables (bound-variable detection)
        // 3. Sends selection-change message with variableBindings
        //
        // This handler then:
        // 1. Updates currentVariableBindings (source of truth for mode detection)
        // 2. Calls updateDevelopmentUI() which calls updateUIState()
        // 3. updateUIState() uses getUIMode() which checks currentVariableBindings
        // 4. UI state is updated based on bound-variable detection
        // ====================================================================
        
        // Track if we were in setup mode before this change
        const wasInSetupMode = dropdownState.setupMode;
        
        // Reset dropdown state when selection changes
        dropdownState.setupMode = false;
        dropdownState.selectedPrefix = null;
        dropdownState.mode = null;
        
        // Close all open dropdowns when selection changes
        closeAllDropdowns();
        
        // Update selected node information
        selectedNode = msg.node;
        parentNode = msg.parentNode;
        const childNodes = msg.childNodes || [];
        const directionalExtension = msg.directionalExtension || null;
        currentDirectionalExtension = directionalExtension; // Store for button click handler
        
        if (selectedNode) {
          // IMPORTANT: Set currentVariableBindings BEFORE updateDevelopmentUI()
          // because updateDevelopmentUI() calls updateUIState() which uses getUIMode()
          // and getUIMode() checks hasVariablesSet(currentVariableBindings)
          // This is the source of truth for bound-variable detection
          if (msg.variableBindings) {
            currentVariableBindings = msg.variableBindings;
          } else {
            currentVariableBindings = null;
          }
          
          // Check if node now has a prefix (transitioning from setup to adjust mode)
          const hasPrefix = ['parent.', 'child.', 'subChild.', 'hero.'].some(prefix => 
            selectedNode.name.startsWith(prefix)
          );
          
          // If we were in setup mode and node now has a prefix, ensure UI transitions to adjust mode
          if (wasInSetupMode && hasPrefix) {
            // Force transition to adjust mode
            updateUIState('(transitioning from setup to adjust mode)', { forceDropdownHidden: true, forceLayoutEnabled: true });
          }
          
          // Parse the prefix from the layer name and display with tag component (active style)
          updateLayerNameDisplay(selectedNode.name, false);
          
          if (parentNode) {
            // Display parent with reference tag style (subtle)
            updateParentLayerDisplay(parentNode.name);
          } else {
            parentLayerName.style.display = 'none';
          }
          
          // Update development UI sections (this will call updateUIState internally)
          // Now currentVariableBindings is set, so getUIMode() will correctly detect setup/adjust mode
          // This is the centralized update point - all UI state flows through here
          const layoutDirection = msg.layoutDirection || null;
          updateDevelopmentUI(selectedNode, parentNode, childNodes, directionalExtension, layoutDirection);
          
          // Update layout button states based on variable bindings
          if (msg.variableBindings) {
            updateLayoutButtonStates(msg.variableBindings);
          } else {
            // Reset all buttons to inactive if no bindings
            resetLayoutButtonStates();
          }
          
          // Update disabled states of variable mode inputs based on current bindings
          // This ensures inputs are disabled/enabled immediately when bindings change
          updateVariableModeInputsDisabledState();
        } else {
          currentLayerName.textContent = 'No layer selected';
          parentLayerName.style.display = 'none';
          
          // Clear development UI (this will call updateUIState internally)
          updateDevelopmentUI(null, null, [], null);
          
          // Reset layout button states
          currentVariableBindings = null;
          resetLayoutButtonStates();
        }
      } else if (msg.type === 'rename-success') {
        // Note: The backend already calls notifySelectionChange() after rename,
        // which will trigger a selection-change message with updated bound variables.
        // This handler just shows a success message - the actual UI state update
        // happens via the selection-change handler which uses centralized updateUIState()
        showMessage(`Renamed to ${msg.newName}`, 'success');
      } else if (msg.type === 'hierarchy-skip-prompt') {
        // Show the hierarchy skip modal
        showHierarchySkipModal(msg.skippedNodes);
      }
    };
    
    // Resize handle functionality
    const resizeHandle = document.createElement('div');
    resizeHandle.className = 'resize-handle';
    resizeHandle.innerHTML = `
      <svg width="20" height="20" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M16 0V16H0L16 0Z" fill="currentColor" opacity="0.3"/>
        <path d="M6.22577 16H3L16 3V6.22576L6.22577 16Z" fill="currentColor" opacity="0.5"/>
        <path d="M11.8602 16H8.63441L16 8.63441V11.8602L11.8602 16Z" fill="currentColor" opacity="0.5"/>
      </svg>
    `;
    document.body.appendChild(resizeHandle);
    
    let isResizing = false;
    let startX = 0;
    let startY = 0;
    let startWidth = 0;
    let startHeight = 0;
    
    const handlePointerMove = (e) => {
      if (!isResizing) return;
      
      const deltaX = e.clientX - startX;
      const deltaY = e.clientY - startY;
      
      const newWidth = Math.max(360, Math.floor(startWidth + deltaX));
      const newHeight = Math.max(300, Math.floor(startHeight + deltaY));
      
      parent.postMessage({
        pluginMessage: {
          type: 'resize',
          width: newWidth,
          height: newHeight
        }
      }, '*');
    };
    
    const handlePointerUp = (e) => {
      if (isResizing) {
        isResizing = false;
        document.removeEventListener('pointermove', handlePointerMove);
        document.removeEventListener('pointerup', handlePointerUp);
        document.removeEventListener('pointercancel', handlePointerUp);
      }
    };
    
    resizeHandle.addEventListener('pointerdown', (e) => {
      isResizing = true;
      startX = e.clientX;
      startY = e.clientY;
      startWidth = window.innerWidth;
      startHeight = window.innerHeight;
      resizeHandle.setPointerCapture(e.pointerId);
      e.preventDefault();
      
      document.addEventListener('pointermove', handlePointerMove);
      document.addEventListener('pointerup', handlePointerUp);
      document.addEventListener('pointercancel', handlePointerUp);
    });
    
    // Spacing Control Drag Handle Functionality
    let spacingControlInitialized = false;
    let isDragging = false;
    const TOTAL_DETENT_MARKERS = 7; // Total markers available (none = 0, XL = 6)
    let currentSpacingDropdown = null; // Track current dropdown state
    
    // Note: currentSizeIndex, sizeClasses, SPACING_INPUT_TO_MODE, and SPACING_MODE_TO_INPUT
    // are declared in shared scope above for access by button handler
    
    // Update CSS custom properties for layout object widths
    function updateSpacingControlWidths() {
      const spacingControlContainer = document.getElementById('spacingControlContainer');
      if (!spacingControlContainer) return;
      
      // Layout objects are fixed at 1/16th each (6.25%), totaling 1/8th (12.5%) for both
      const layoutObjectWidthPercentage = 100 / 16; // 1/16th = 6.25% per layout object
      
      // Set CSS custom property on the container (inherited by children)
      spacingControlContainer.style.setProperty('--spacing-layout-object-width', layoutObjectWidthPercentage + '%');
    }
    
    // Update detent markers visibility and drag control width based on size class index
    function updateDetentMarkers(sizeIndex) {
      const spacingControlContainer = document.getElementById('spacingControlContainer');
      if (!spacingControlContainer) return;
      
      const dragControl = spacingControlContainer.querySelector('.spacing-drag-control');
      const layoutObjects = spacingControlContainer.querySelectorAll('.spacing-layout-object');
      
      // Formula-based approach for flexible marker distribution
      // n = number of options in the array (including initial 'none' value)
      const n = sizeClasses.length; // Currently 6: ['none', 'XS', 'S', 'M', 'L', 'XL']
      const currentStep = sizeIndex; // Current step index (0-based: 0 = none, 1 = XS, ..., n-1 = XL)
      
      // Calculate maximum possible active detents in drag control
      // Formula: 2 * (n - 1) to account for initial value (0/none)
      // This represents the maximum number of detent positions (transitions between options)
      // For n=6: 2 * (6-1) = 10 maximum detent positions
      const maxPossibleActiveDetents = 2 * (n - 1);
      
      // Calculate maximum markers needed based on array length
      // Maximum needed = (n - 1) markers per side = 2 * (n - 1) total
      // For n=6: (6-1) = 5 per side = 10 total markers needed
      const maxMarkersPerSideNeeded = n - 1;
      const maxMarkersInDragControlNeeded = 2 * maxMarkersPerSideNeeded;
      
      // Ensure we have enough markers in the DOM - dynamically create if needed
      // This makes the component fully flexible and formula-driven
      if (dragControl) {
        const existingMarkers = dragControl.querySelectorAll('.spacing-detent-marker[data-index]');
        const markersNeeded = maxMarkersInDragControlNeeded;
        
        if (existingMarkers.length < markersNeeded) {
          // Find the variable mode select to insert markers around it
          const variableModeSelect = dragControl.querySelector('.spacing-variable-mode-select');
          const rightHandle = dragControl.querySelector('.spacing-handle[data-handle="right"]');
          
          // Re-index existing markers based on their DOM position (not their current data-index)
          // This ensures markers are correctly identified as left or right side
          const allMarkers = Array.from(dragControl.querySelectorAll('.spacing-detent-marker[data-index]'));
          const variableModeSelectIndex = variableModeSelect ? Array.from(dragControl.children).indexOf(variableModeSelect) : -1;
          
          // Re-index markers: left side gets indices 0 to (maxMarkersPerSideNeeded - 1)
          // Right side gets indices maxMarkersPerSideNeeded to (2 * maxMarkersPerSideNeeded - 1)
          let leftMarkerCount = 0;
          let rightMarkerCount = 0;
          
          allMarkers.forEach((marker) => {
            const markerIndex = Array.from(dragControl.children).indexOf(marker);
            if (variableModeSelectIndex >= 0 && markerIndex < variableModeSelectIndex) {
              // Left side marker
              marker.setAttribute('data-index', leftMarkerCount.toString());
              leftMarkerCount++;
            } else if (variableModeSelectIndex >= 0 && markerIndex > variableModeSelectIndex) {
              // Right side marker
              marker.setAttribute('data-index', (maxMarkersPerSideNeeded + rightMarkerCount).toString());
              rightMarkerCount++;
            }
          });
          
          // Get all existing marker indices after re-indexing
          const existingIndices = new Set(Array.from(dragControl.querySelectorAll('.spacing-detent-marker[data-index]')).map(m => 
            parseInt(m.getAttribute('data-index') || '0')
          ));
          
          // Add missing markers on the left side (before variable mode select)
          // Left side markers: indices 0 to (maxMarkersPerSideNeeded - 1)
          for (let i = 0; i < maxMarkersPerSideNeeded; i++) {
            if (!existingIndices.has(i)) {
              const marker = document.createElement('div');
              marker.className = 'spacing-detent-marker';
              marker.setAttribute('data-name', 'detentMarker');
              marker.setAttribute('data-index', i.toString());
              if (variableModeSelect && variableModeSelect.previousElementSibling) {
                variableModeSelect.previousElementSibling.insertAdjacentElement('afterend', marker);
              } else if (variableModeSelect) {
                variableModeSelect.insertAdjacentElement('beforebegin', marker);
              }
            }
          }
          
          // Add missing markers on the right side (after variable mode select)
          // Right side markers: indices maxMarkersPerSideNeeded to (2 * maxMarkersPerSideNeeded - 1)
          for (let i = 0; i < maxMarkersPerSideNeeded; i++) {
            const rightIndex = maxMarkersPerSideNeeded + i;
            if (!existingIndices.has(rightIndex)) {
              const marker = document.createElement('div');
              marker.className = 'spacing-detent-marker';
              marker.setAttribute('data-name', 'detentMarker');
              marker.setAttribute('data-index', rightIndex.toString());
              if (variableModeSelect && variableModeSelect.nextElementSibling) {
                variableModeSelect.nextElementSibling.insertAdjacentElement('beforebegin', marker);
              } else if (rightHandle) {
                rightHandle.insertAdjacentElement('beforebegin', marker);
              } else if (variableModeSelect) {
                variableModeSelect.insertAdjacentElement('afterend', marker);
              }
            }
          }
        }
      }
      
      // Now query again to get the actual count (including dynamically added markers)
      const availableMarkersInDragControl = dragControl ? dragControl.querySelectorAll('.spacing-detent-marker[data-index]').length : maxMarkersInDragControlNeeded;
      const availableMarkersPerSide = availableMarkersInDragControl / 2;
      
      // Use the formula-based calculation - no capping needed since we ensure markers exist
      const maxMarkersPerSide = maxMarkersPerSideNeeded;
      const maxMarkersInDragControl = maxMarkersInDragControlNeeded;
      const maxMarkersPerLayoutObject = TOTAL_DETENT_MARKERS; // 6 markers per layout object
      
      // Calculate total markers to show while dragging
      // Total = 2 * n (12 markers for n=6)
      const totalMarkersToShow = 2 * n;
      
      // Calculate active detents (markers) in drag control based on current step
      // Since markers are symmetric (on both sides of the input), we calculate per-side first
      // Formula: currentStep markers per side (1 marker per side per step)
      // Then double for total: 2 * markersPerSide
      // Step 0 (none): 0 markers per side = 0 total (no active detents)
      // Step 1 (XS): 1 marker per side = 2 total (1 left + 1 right)
      // Step 2 (S): 2 markers per side = 4 total (2 left + 2 right)
      // Step 3 (M): 3 markers per side = 6 total (3 left + 3 right)
      // Step 4 (L): 4 markers per side = 8 total (4 left + 4 right) - if enough markers exist in DOM
      // Step 5 (XL): 5 markers per side = 10 total (5 left + 5 right) - if enough markers exist in DOM
      let markersPerSide = 0;
      if (currentStep > 0) {
        // Calculate markers per side: currentStep (1 per side per step)
        const desiredMarkersPerSide = currentStep;
        // Only cap if we don't have enough markers in the DOM
        // maxMarkersPerSide is calculated above based on available DOM elements
        markersPerSide = Math.min(desiredMarkersPerSide, maxMarkersPerSide);
      }
      
      // Calculate total markers in drag control (double the per-side count)
      const markersInDragControl = markersPerSide * 2;
      
      // Calculate remaining markers to show in layout objects
      // Remaining = total markers to show - markers in drag control
      const totalMarkersInLayoutObjects = totalMarkersToShow - markersInDragControl;
      
      // Split markers evenly between left and right layout objects
      // Each layout object shows: totalMarkersInLayoutObjects / 2
      // But capped at maxMarkersPerLayoutObject (6)
      let markersPerLayoutObject = Math.min(
        Math.floor(totalMarkersInLayoutObjects / 2),
        maxMarkersPerLayoutObject
      );
      
      // Adjust for edge cases:
      // - At the last step (XL), all markers should be in drag control, none in layout objects
      // - At second-to-last step (L), show minimal markers in layout objects (1 per object = 2 total)
      let finalMarkersPerLayoutObject = markersPerLayoutObject;
      if (currentStep === n - 1) {
        // Last step (XL): 0 markers in layout objects
        finalMarkersPerLayoutObject = 0;
      } else if (currentStep === n - 2) {
        // Second-to-last step (L): show 1 marker per layout object (2 total)
        finalMarkersPerLayoutObject = 1;
      }
      
      // Calculate dynamic width for drag control using percentages
      // Original formula: 1/7th = 14.28% (for 7 total detents/options)
      // Now with n options: each detent = 1/n of total space
      // Formula: basePercentage = 100 / n, percentagePerDetent = 100 / n
      // Layout objects are fixed at 1/16th each (6.25%), totaling 1/8th (12.5%) for both
      // Maximum available for drag control = 100% - 12.5% = 87.5%
      const basePercentage = 100 / n; // Dynamic base width based on option count (1/n of total)
      const percentagePerDetent = 100 / n; // Each detent adds 1/n of total space
      const layoutObjectTotalWidth = 100 / 8; // Fixed 1/8th (12.5%) total for both layout objects
      const maxDragControlWidth = 100 - layoutObjectTotalWidth; // Maximum drag control width = 87.5%
      const dragControlPercentage = basePercentage + (sizeIndex * percentagePerDetent);
      
      if (dragControl) {
        // Cap at maximum available width (accounting for layout object minimums)
        const clampedPercentage = Math.min(dragControlPercentage, maxDragControlWidth);
        
        // Ensure transition is enabled before updating width
        // This is especially important when increasing width to ensure smooth animation
        dragControl.style.transition = 'width 0.2s ease, min-width 0.2s ease';
        
        // Use requestAnimationFrame to batch the width update with the next frame
        // This ensures the browser can properly apply the transition when width increases
        requestAnimationFrame(() => {
          dragControl.style.width = clampedPercentage + '%';
          dragControl.style.minWidth = clampedPercentage + '%';
          dragControl.style.maxWidth = 'none';
          dragControl.style.flex = '0 0 auto';
        });
        
        // Update drag control markers (symmetric around selection input)
        // Markers use data-index: 0,1,2... are on the left, maxMarkersPerSideNeeded+0, maxMarkersPerSideNeeded+1... are on the right
        // markersPerSide is already calculated above (per-side count)
        const dragMarkers = dragControl.querySelectorAll('.spacing-detent-marker[data-index]');
        
        dragMarkers.forEach((marker) => {
          const markerIndex = parseInt(marker.getAttribute('data-index') || '0');
          
          // Determine if this is a left or right side marker based on data-index
          // Left side markers: 0 to (maxMarkersPerSideNeeded - 1)
          // Right side markers: maxMarkersPerSideNeeded to (2 * maxMarkersPerSideNeeded - 1)
          const isLeftSide = markerIndex < maxMarkersPerSideNeeded;
          
          if (isLeftSide) {
            // Left side marker: show if index < markersPerSide
            if (markerIndex < markersPerSide) {
              marker.classList.add('visible');
              marker.classList.remove('hidden');
              marker.style.opacity = '1';
              marker.style.display = 'flex';
            } else {
              marker.classList.remove('visible');
              marker.classList.add('hidden');
              marker.style.opacity = '0';
              marker.style.display = 'none';
            }
          } else {
            // Right side marker: convert index to right-side relative index
            const rightSideIdx = markerIndex - maxMarkersPerSideNeeded;
            if (rightSideIdx < markersPerSide) {
              marker.classList.add('visible');
              marker.classList.remove('hidden');
              marker.style.opacity = '1';
              marker.style.display = 'flex';
            } else {
              marker.classList.remove('visible');
              marker.classList.add('hidden');
              marker.style.opacity = '0';
              marker.style.display = 'none';
            }
          }
        });
      }
      
      // Update layout object markers (only visible when dragging)
      // Always show finalMarkersPerLayoutObject markers in each layout object to maintain 12 total markers
      layoutObjects.forEach(layoutObject => {
        const layoutMarkers = layoutObject.querySelectorAll('.spacing-detent-marker[data-index]');
        layoutMarkers.forEach((marker, idx) => {
          // Show markers if dragging AND within the count needed for this layout object
          if (isDragging && idx < finalMarkersPerLayoutObject) {
            marker.classList.add('visible');
            marker.classList.remove('hidden');
            marker.style.opacity = '1';
            marker.style.display = 'flex';
          } else {
            marker.classList.remove('visible');
            marker.classList.add('hidden');
            marker.style.opacity = '0';
            marker.style.display = 'none';
          }
        });
      });
    }
    
    // Global drag handlers (only added once)
    // Track accumulated delta for hysteresis-based detent changes
    // This prevents jumping and provides smooth, predictable behavior
    let accumulatedDelta = 0;
    
    function handleSpacingDragMove(e) {
      if (!isDragging) return;
      
      const spacingControlContainer = document.getElementById('spacingControlContainer');
      if (!spacingControlContainer) return;
      
      // Calculate drag based on cursor delta from start point
      const deltaX = e.clientX - (handleSpacingDragMove.startX || 0);
      
      // Get drag control width range using percentage-based calculation
      const wrapper = spacingControlContainer.querySelector('.spacing-control-wrapper');
      const wrapperWidth = handleSpacingDragMove.wrapperRect ? handleSpacingDragMove.wrapperRect.width : (wrapper ? wrapper.offsetWidth : spacingControlContainer.offsetWidth);
      
      // Calculate percentage-based thresholds
      // Use dynamic calculation based on number of options (same as in updateDetentMarkers)
      const n = sizeClasses.length;
      const percentagePerDetent = 100 / n; // Dynamic percentage per detent
      
      // Calculate detent threshold based on total component width
      // Each detent represents a percentage of the wrapper width based on option count
      // Require movement of ~40-50% of one detent spacing to change detents
      // This provides a reasonable drag distance that scales with component size
      const detentSpacingPixels = (percentagePerDetent / 100) * wrapperWidth; // Dynamic percentage of wrapper width
      const detentThresholdPercentage = 0.45; // Require 45% of one detent spacing (â‰ˆ6.4% of total width)
      const detentThreshold = detentSpacingPixels * detentThresholdPercentage;
      
      // Use incremental movement tracking with hysteresis
      // Track incremental movement since last detent change, not total movement
      const incrementalDelta = deltaX - (handleSpacingDragMove.lastDeltaX || 0);
      accumulatedDelta += incrementalDelta;
      handleSpacingDragMove.lastDeltaX = deltaX;
      
      let newSizeIndex = currentSizeIndex;
      
      // Only change detents if accumulated movement crosses threshold
      // Change one detent at a time for smooth, predictable behavior
      if (Math.abs(accumulatedDelta) >= detentThreshold) {
        if (accumulatedDelta > 0) {
          // Moving right - increment detent
          newSizeIndex = Math.min(sizeClasses.length - 1, currentSizeIndex + 1);
          accumulatedDelta = 0; // Reset after detent change
        } else {
          // Moving left - decrement detent
          newSizeIndex = Math.max(0, currentSizeIndex - 1);
          accumulatedDelta = 0; // Reset after detent change
        }
      }
      
      if (newSizeIndex !== currentSizeIndex) {
        currentSizeIndex = newSizeIndex;
        const variableModeText = spacingControlContainer.querySelector('.spacing-variable-mode-text');
        if (variableModeText) {
          // Display "0" for 'none', otherwise show the size class name
          variableModeText.textContent = currentSizeIndex === 0 ? '0' : sizeClasses[currentSizeIndex] || 'S';
        }
        // Update detent markers based on new size class
        updateDetentMarkers(currentSizeIndex);
      }
      
      e.preventDefault();
    }
    
    function handleSpacingDragEnd(e) {
      if (!isDragging) return;
      
      isDragging = false;
      
      // Reset accumulated delta and tracking variables
      accumulatedDelta = 0;
      handleSpacingDragMove.lastDeltaX = null;
      handleSpacingDragMove.startX = null;
      handleSpacingDragMove.wrapperRect = null;
      
      const spacingControlContainer = document.getElementById('spacingControlContainer');
      
      if (spacingControlContainer) {
        // Remove dragging class to hide layout object detent markers and restore chevron
        spacingControlContainer.classList.remove('dragging');
        
        // Update detent markers (layout objects will hide, drag control keeps its markers)
        updateDetentMarkers(currentSizeIndex);
        
        // Explicitly restore chevron visibility (CSS display: none is removed by removing .dragging class)
        const chevronIcon = spacingControlContainer.querySelector('.spacing-chevron-icon');
        if (chevronIcon) {
          chevronIcon.style.display = 'flex'; // Restore display property
          chevronIcon.style.opacity = '1'; // Restore opacity
        }
        
        // Restore selection input state
        const variableModeSelect = spacingControlContainer.querySelector('.spacing-variable-mode-select');
        if (variableModeSelect) {
          variableModeSelect.style.opacity = '1';
          variableModeSelect.style.pointerEvents = 'auto';
          variableModeSelect.style.justifyContent = 'space-between'; // Restore normal layout
        }
        
        // Apply variable modes immediately on drag release
        if (selectedNode) {
          const currentSizeClass = sizeClasses[currentSizeIndex];
          const inputValue = currentSizeClass === 'none' ? '0' : currentSizeClass;
          const spacingVariableMode = SPACING_INPUT_TO_MODE[inputValue];
          
          if (spacingVariableMode) {
            parent.postMessage({
              pluginMessage: {
                type: 'update-spacing-variable-mode',
                mode: spacingVariableMode
              }
            }, '*');
          }
        }
      }
      
      // Release pointer capture
      if (e.target && e.target.releasePointerCapture) {
        e.target.releasePointerCapture(e.pointerId);
      }
      
      // TODO: Send message to plugin to update variable mode
      // parent.postMessage({
      //   pluginMessage: {
      //     type: 'update-spacing-variable-mode',
      //     sizeClass: sizeClasses[currentSizeIndex]
      //   }
      // }, '*');
    }
    
    function initializeSpacingControl() {
      const spacingControlContainer = document.getElementById('spacingControlContainer');
      if (!spacingControlContainer) return;
      
      const dragControl = spacingControlContainer.querySelector('.spacing-drag-control');
      const handles = spacingControlContainer.querySelectorAll('.spacing-handle');
      const variableModeSelect = spacingControlContainer.querySelector('.spacing-variable-mode-select');
      const variableModeText = spacingControlContainer.querySelector('.spacing-variable-mode-text');
      
      if (!dragControl || !variableModeSelect) return;
      
      // Update CSS custom properties for dynamic widths based on option count
      updateSpacingControlWidths();
      
      // Only add document-level listeners once
      if (!spacingControlInitialized) {
        document.addEventListener('pointermove', handleSpacingDragMove);
        document.addEventListener('pointerup', handleSpacingDragEnd);
        document.addEventListener('pointercancel', handleSpacingDragEnd);
        spacingControlInitialized = true;
      }
      
      // Handle drag start
      function handleDragStart(e) {
        if (isDragging) return;
        
        // Don't start drag if clicking on the selection input or its children
        const target = e.target;
        const variableModeSelect = spacingControlContainer.querySelector('.spacing-variable-mode-select');
        if (variableModeSelect && (variableModeSelect.contains(target) || variableModeSelect === target)) {
          return; // Let the click handler handle selection input clicks
        }
        
        isDragging = true;
        // Reset accumulated delta for new drag session
        accumulatedDelta = 0;
        handleSpacingDragMove.startX = e.clientX;
        handleSpacingDragMove.lastDeltaX = 0;
        const wrapper = spacingControlContainer.querySelector('.spacing-control-wrapper');
        handleSpacingDragMove.wrapperRect = wrapper ? wrapper.getBoundingClientRect() : null;
        
        // Add dragging class to show detent markers
        spacingControlContainer.classList.add('dragging');
        
        // Update detent markers visibility for current size class
        updateDetentMarkers(currentSizeIndex);
        
        // Capture pointer for better drag handling
        if (e.target && e.target.setPointerCapture) {
          e.target.setPointerCapture(e.pointerId);
        }
        
        e.preventDefault();
        e.stopPropagation();
      }
      
      // Add drag listeners to handles and drag control (remove old listeners first to prevent duplicates)
      handles.forEach(handle => {
        // Remove any existing listeners by cloning the element
        const newHandle = handle.cloneNode(true);
        handle.parentNode.replaceChild(newHandle, handle);
        newHandle.addEventListener('pointerdown', handleDragStart);
      });
      
      // Remove old listener and add new one for drag control
      const newDragControl = dragControl.cloneNode(true);
      dragControl.parentNode.replaceChild(newDragControl, dragControl);
      newDragControl.addEventListener('pointerdown', handleDragStart);
      
      // Re-query for variable mode select after cloning
      const newVariableModeSelect = spacingControlContainer.querySelector('.spacing-variable-mode-select');
      const newVariableModeText = spacingControlContainer.querySelector('.spacing-variable-mode-text');
      
      // Initialize size class display
      if (newVariableModeText) {
        // Display "0" for 'none', otherwise show the size class name
        newVariableModeText.textContent = currentSizeIndex === 0 ? '0' : sizeClasses[currentSizeIndex] || 'S';
      }
      
      // Initialize detent markers based on current size class
      updateDetentMarkers(currentSizeIndex);
      
      // Variable mode dropdown functionality
      if (newVariableModeSelect) {
        // Remove old listener if exists and add new one
        const newSelectClone = newVariableModeSelect.cloneNode(true);
        newVariableModeSelect.parentNode.replaceChild(newSelectClone, newVariableModeSelect);
        
        // Prevent drag from starting when clicking on selection input
        newSelectClone.addEventListener('pointerdown', (e) => {
          e.stopPropagation(); // Prevent drag control from receiving pointerdown
        });
        
        newSelectClone.addEventListener('click', (e) => {
          e.stopPropagation();
          e.preventDefault(); // Prevent any default behavior
          
          // If dropdown is already visible, close it
          if (currentSpacingDropdown && document.body.contains(currentSpacingDropdown)) {
            document.body.removeChild(currentSpacingDropdown);
            currentSpacingDropdown = null;
            return;
          }
          
          // Create dropdown menu - use centralized variable-mode-dropdown styling
          const dropdown = document.createElement('div');
          dropdown.className = 'variable-mode-dropdown';
          currentSpacingDropdown = dropdown; // Track the dropdown
          
          // Add size class options
          sizeClasses.forEach((sizeClass, index) => {
            const option = document.createElement('div');
            option.className = 'variable-mode-option';
            if (index === currentSizeIndex) {
              option.classList.add('selected');
            }
            
            // Display "0" for 'none', otherwise show the size class name
            const textSpan = document.createElement('span');
            textSpan.textContent = index === 0 ? '0' : sizeClass;
            option.appendChild(textSpan);
            
            // Add check icon
            const checkIcon = createCheckIcon();
            option.appendChild(checkIcon);
            
            option.addEventListener('click', () => {
              currentSizeIndex = index;
              const variableModeText = spacingControlContainer.querySelector('.spacing-variable-mode-text');
              if (variableModeText) {
                // Display "0" for 'none', otherwise show the size class name
                variableModeText.textContent = currentSizeIndex === 0 ? '0' : sizeClasses[currentSizeIndex] || 'S';
              }
              
              // Update detent markers based on new size class
              updateDetentMarkers(currentSizeIndex);
              
              // Remove dropdown
              if (document.body.contains(dropdown)) {
                document.body.removeChild(dropdown);
                currentSpacingDropdown = null; // Clear dropdown reference
              }
              
              // Apply variable modes immediately
              if (selectedNode) {
                const currentSizeClass = sizeClasses[currentSizeIndex];
                const inputValue = currentSizeClass === 'none' ? '0' : currentSizeClass;
                const spacingVariableMode = SPACING_INPUT_TO_MODE[inputValue];
                
                if (spacingVariableMode) {
                  parent.postMessage({
                    pluginMessage: {
                      type: 'update-spacing-variable-mode',
                      mode: spacingVariableMode
                    }
                  }, '*');
                }
              }
            });
            
            dropdown.appendChild(option);
          });
          
          // Position dropdown below the select input
          const rect = newSelectClone.getBoundingClientRect();
          dropdown.style.left = rect.left + 'px';
          dropdown.style.top = (rect.bottom + 4) + 'px';
          
          document.body.appendChild(dropdown);
          
          // Adjust padding based on scrollbar presence
          adjustDropdownPadding(dropdown);
          
          // Close dropdown when clicking outside
          function closeDropdown(e) {
            if (!dropdown.contains(e.target) && !newSelectClone.contains(e.target)) {
              if (document.body.contains(dropdown)) {
                document.body.removeChild(dropdown);
                currentSpacingDropdown = null; // Clear dropdown reference
              }
              document.removeEventListener('click', closeDropdown);
            }
          }
          
          setTimeout(() => {
            document.addEventListener('click', closeDropdown);
          }, 0);
        });
        
        // Add click handler to chevron icon to close dropdown if visible
        const chevronIcon = spacingControlContainer.querySelector('.spacing-chevron-icon');
        if (chevronIcon) {
          chevronIcon.addEventListener('click', (e) => {
            // If dropdown is visible, close it and prevent select from reopening
            if (currentSpacingDropdown && document.body.contains(currentSpacingDropdown)) {
              e.stopPropagation();
              document.body.removeChild(currentSpacingDropdown);
              currentSpacingDropdown = null;
            }
            // If dropdown is not visible, let the click bubble to select to open dropdown
          });
        }
      }
    }
    
    // Initialize spacing control when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initializeSpacingControl);
    } else {
      initializeSpacingControl();
    }
    
    // Re-initialize when spacing control becomes visible
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (mutation.type === 'attributes' && mutation.attributeName === 'style') {
          const spacingControlContainer = document.getElementById('spacingControlContainer');
          if (spacingControlContainer && spacingControlContainer.style.display !== 'none') {
            // Ensure handlers are set up
            initializeSpacingControl();
          }
        }
      });
    });
    
    const spacingControlContainer = document.getElementById('spacingControlContainer');
    if (spacingControlContainer) {
      observer.observe(spacingControlContainer, { attributes: true, attributeFilter: ['style'] });
    }</script></body></html>